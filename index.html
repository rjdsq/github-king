<!DOCTYPE html>
<html lang="zh-CN">
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
		<meta name="theme-color" content="#f0f2f5">
		<title>
			GitHub仓库管理器
		</title>
		<link rel="stylesheet" href="./style.css">
		<link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/font-awesome/7.0.0/css/all.min.css">
		  <!-- 放在 </head> 之前 -->
<script>
    (function() {
        try {
            const savedTheme = localStorage.getItem('app_theme') || 'light';
            const themeColorMeta = document.querySelector('meta[name="theme-color"]');
            
            if (savedTheme === 'light') {
                document.documentElement.classList.add('light-theme-loading');
                if (themeColorMeta) themeColorMeta.setAttribute('content', '#f0f2f5');
            } else {
                if (themeColorMeta) themeColorMeta.setAttribute('content', '#04091a');
            }
        } catch (e) {}
    })();
    
    document.addEventListener('DOMContentLoaded', function() {
        if (document.documentElement.classList.contains('light-theme-loading')) {
            document.body.classList.add('light-theme');
            requestAnimationFrame(() => {
                document.documentElement.classList.remove('light-theme-loading');
            });
        }
    });
</script>
	</head>
	<style>



	</style>
	<body>


	<canvas id="particle-canvas"></canvas>
		<!-- 认证页面 -->
		
		<div id="authScreen">
		
			<div class="auth-header">
			
				<i class="fa-brands fa-github"></i>
			
				<h1>
					GitHub仓库管理器
				</h1>
				<p>
					全方位的仓库管理工具
				</p>
			</div>
			
			
<div class="login-container">
    <div class="auth-form">
        <input type="text" id="tokenInput" placeholder="输入GitHub访问令牌">
        
        <div class="auth-buttons-container">
            
<button class="auth-button" id="manageAccountsBtn">
    
    <span>账号管理</span>
</button>
            <button id="authBtn"><span>登录</span><i class="fa fa-spinner fa-spin hidden"></i></button>
        </div>
    </div>
    
    
    
    

    <div class="token-instructions">
        <h4 class="lp"><i class="fa fa-key"></i> 令牌获取指南 <i class="fa-solid fa-chevron-down"></i></h4>
        <div class="token-content">
        
        <ol>
        
            <li>复制下面官网链接，直达令牌生成界面：
            <small>https://github.com/settings/tokens/new </small></li>
            <li>在浏览器中粘贴链接并登录账号
                <small>如果注册登录后，若未跳转到令牌生成页，请重新粘贴一次链接直达令牌生成界面</small>
            </li>
            <li>进入令牌 Token设置页面后，按以下步骤操作：
                <ul>
                    <li><strong>勾选：</strong>下滑页面，勾选所有权限选框</li>
                    <li><strong>效期：</strong>选择一个合适的有效期</li>
                    <li><strong>生成：</strong>点击底部绿色按钮生成令牌</li>
                </ul>
            </li>
            <li><strong>复制</strong> 生成的令牌粘贴到输入框内完成登录</li>
            
            <li><strong>提示：</strong>Github官网若无法访问，请使用小飞机</li>
            
        </ol>
</div>
    </div>
</div>
		</div>
		
		
	<!-- 提示消息框 -->
<!-- 提示消息框 -->
<div id="toast">
    <span id="toastMessage"></span>
</div>
		<!-- 主应用容器 -->
		<div id="app" class="hidden">
			<!-- 头部栏 -->
			



<header>
				<div class="header-left">
				<!-- class github图标 -->
					
					
    
					<h1 id="currentRepo">
						选择仓库
					</h1>
					<div id="branchSwitcherContainer" class="hidden">
					</div>
					<div id="pathNav">
					</div>
					<div id="pathNavContainer">
					</div>
				</div>
				<div class="header-right">
    <div id="globalSearchContainer" class="hidden">
    <input id="globalSearchInput" placeholder="搜仓库/@用户/链接/#文件" autocomplete="off">
    <div id="globalSearchHistoryContainer" class="custom-dropdown hidden"></div>
</div>
    <button id="globalSearchToggleBtn" class="btn-icon" title="全局搜索">
        <i class="fa fa-search"></i>
    </button>
    <button id="viewStarredBtn" class="btn-icon" title="查看星标仓库">
        <i class="fa-regular fa-star"></i>
    </button>
    
    <button id="sideNavToggleBtn" title="菜单">
        <i class="fa-regular fa-user"></i>
    </button>
</div>
			</header>
			<!-- 主内容区 -->
			
			<!-- 全局加载动画 -->
				<div id="mainLoader" class="loading-overlay hidden">
					<div class="spinner">
					</div>
				</div>
			<main>
			<div id="pull-to-refresh">
					
					<div class="ptr-spinner spinner"></div>
				</div>
				
				
				<!-- 文件工具栏 -->
				<div id="toolbar" class="hidden">
					<div class="toolbar-left">
						<input id="searchInput" placeholder="搜索文件/文件夹..." class="hidden">
					</div>
					<button id="searchToggleBtn" class="btn-icon" title="搜索">
						<i class="fa fa-search">
						</i>
					</button>
					<button id="proxyQuickToggle" title="代理状态">
						<i class="fa fa-power-off">
						</i>
					</button>
					<div class="toolbar-right">
						<div class="custom-select-container">
							<button id="sortToggleBtn" class="btn-icon" title="排序">
							<i class="fa-solid fa-up-down"></i>
							</button>
							<!-- 排序下拉菜单 -->
							<div id="customSortDropdown" class="hidden custom-dropdown">      
    <div class="dropdown-item" data-priority="dirs_first">
        <i class="fa-regular fa-folder"></i>
        文件夹优先
    </div>
    <div class="dropdown-item" data-priority="files_first">
        <i class="fa-regular fa-file"></i>
        文件优先
    </div>
    <div class="dropdown-divider"></div>
    <div class="dropdown-item" data-value="type_name_asc">
        按类型
    </div>
    <div class="dropdown-item" data-value="name_asc">
        名称 A→Z
    </div>
    <div class="dropdown-item" data-value="name_desc">
        名称 Z→A
    </div>
    
    <div class="dropdown-item" data-value="size_desc">
        大小 大→小
    </div>
    <div class="dropdown-item" data-value="size_asc">
        大小 小→大
    </div>
</div>
						</div>
						<button id="multiSelectToggleBtn" class="btn-icon" title="多项选择">
						<i class="fa-regular fa-circle-check"></i>
						</button>
						<button id="viewToggleBtn" title="切换视图">
							<i class="fa fa-th-large">
							</i>
						</button>
					</div>
				</div>
				<!-- 仓库列表 -->
				<div id="repoList">
					<div class="loading-spinner">
						<div class="spinner">
						</div>
					</div>
				</div>
				<!-- 文件列表 -->
				<div id="fileList" class="hidden">
					<div class="loading-spinner">
						<div class="spinner">
						</div>
					</div>
				</div>
			</main>
						<!-- 重命名弹窗 -->
			<div id="renameModal" class="modal-overlay hidden">
				<div class="modal-form-container">
					<h3 id="renameTitle">
						<span class="modal-title-text">
							重命名
						</span>
						<button class="btn-icon-sm" onclick="hideRenameModal()"
						title="关闭">
							<i class="fa fa-times">
							</i>
						</button>
					</h3>
					<input type="text" id="renameInput" value="" autocomplete="off">
					
					<!-- 【核心新增】在这里添加一个空的容器，作为“插槽” -->
					<div id="renameModalExtraSettings"></div>

					<div id="renameWarn" class="text-red-400" >
					</div>
					<div class="modal-buttons">
						<button id="renameCancel" class="btn btn-cancel">
							取消
						</button>
						<button id="renameConfirm" class="btn btn-primary" disabled>
							确认
						</button>
					</div>
				</div>
			</div>
			
			<!-- 文件编辑弹窗 -->
						<!-- 文件编辑弹窗 -->
			<div id="editModal" class="hidden">
				<div class="modal-content">
					<div class="modal-header">
    <h5 id="editFileName">
        编辑文件
    </h5>
    <button id="closeEditModal">
        <i class="fa fa-times">
        </i>
    </button>
</div>
					<div id="editStatus">
					</div>
					<div class="editor-container">
						<!-- 新增的搜索面板 -->
						<div id="editorSearchPanel" class="hidden">
							<input type="text" id="editorSearchInput" placeholder="搜索...">
							<span id="editorSearchMatchCount"></span>
							<button id="editorSearchPrevBtn" title="上一个"><i class="fa fa-chevron-up"></i></button>
							<button id="editorSearchNextBtn" title="下一个"><i class="fa fa-chevron-down"></i></button>
							<button id="editorSearchCloseBtn" title="关闭搜索"><i class="fa fa-times"></i></button>
						</div>

						<div id="editorOverlay">
							<div class="spinner-container">
								<i class="fa fa-spinner fa-spin">
								</i>
							</div>
						</div>
						<div id="saveNotification">
							<i class="fa fa-check">
							</i>
							保存成功
						</div>
						<textarea id="fileContent">
						</textarea>
					</div>
					<div class="modal-footer">
					
    <button id="revertEditBtn" title="撤销修改" disabled>
        <i class="fa fa-undo"></i>
        <span>撤销</span>
    </button>
    <button id="searchInFileBtn">
        <i class="fa fa-search"></i>
        <span>搜索</span>
    </button>
    
    <button id="toggleMaximizeModal" title="最大化">
        <i class="fa fa-expand"></i>
        <span>全屏</span>
    </button>
    <button id="cancelEdit">
        <i class="fa fa-times"></i>
        <span>取消</span>
    </button>
    <button id="saveEdit">
        <i class="fa-solid fa-check"></i>
        <span>保存</span>
    </button>
</div>
				</div>
			</div>
			
			
			<!-- 右键/长按菜单 -->
			<div id="contextMenu" class="hidden">
				<div id="contextMenuItems">
				</div>
			</div>
			
			<!-- 隐藏的文件上传输入框 -->
			<input type="file" id="fileUploadInput" multiple class="hidden">
			
			
			
			
			<div id="mainOverlay"></div>
<aside id="sideNav">
    <div class="user-profile-header">
        <div id="avatarContainer" title="点击更换头像">
            <i id="userAvatarPlaceholder" class="fa fa-github"></i>
            <img id="userAvatar" src="" alt="User Avatar" class="fa fa-github hidden">
        </div>
        <span id="userName">name</span>
    </div>
    
    <ul class="side-nav-main">
        <li><a href="javascript:void(0);" id="menuProxySettings"><i class="fa-solid fa-gears"></i>代理设置</a></li>
        <li><a href="javascript:void(0);" id="menuContextMenuSettings"><i class="fa-regular fa-hand-pointer"></i>菜单设置</a></li>
        <li><a href="javascript:void(0);" id="menuBatchPublishSites"><i class="fa-solid fa-layer-group"></i>网站部署</a></li>
        <li><a href="javascript:void(0);" id="ybp"><i class="fa-regular fa-lightbulb"></i>数据监控</a></li>
        <li><a href="javascript:void(0);" id="menuEffectsManager"><i class="fa-solid fa-wand-magic-sparkles"></i>特效管理</a></li>
        <li><a href="javascript:void(0);" id="menuUsageGuide"><i class="fa-regular fa-circle-question"></i>使用指南</a></li>
        
    </ul>

    <ul class="side-nav-bottom">
    
    
    
    <li><a href="javascript:void(0);" id="menuThemeToggle"><i class="fa-regular fa-cloud"></i>切换主题</a></li>
    
    
        <li><a href="javascript:void(0);" id="menuSwitchAccount"><i class="fa fa-exchange"></i>切换账号</a></li>
        <li><a href="javascript:void(0);" id="menuLogout"><i class="fa fa-sign-out"></i>退出登录</a></li>
    </ul>
</aside>

			<!-- 底部操作栏 -->
			<footer>
    <button id="backBtn" title="返回上级" class="hidden">
        <i class="fa-solid fa-arrow-left"></i>
    </button>
    <button id="newFolderBtn" title="新建仓库">
        <i class="fa-regular fa-folder-open"></i>
    </button>
    <button id="newReleaseBtn" title="发布新版本" class="hidden">
        <i class="fa fa-plus-circle"></i>
    </button>
    <button id="newFileBtn" title="新建文件" class="hidden">
        <i class="fa-solid fa-arrow-right"></i>
    </button>
    <button id="uploadBtn" title="上传文件" class="hidden">
        <i class="fa-solid fa-arrows-up-down"></i>
    </button>
</footer>
			<!-- 媒体文件预览容器 -->
			<div id="mediaPreview" class="hidden">
				<img id="mediaPreviewImg" style="display:none;" alt="预览图片">
				<video id="mediaPreviewVideo" style="display:none;" controls>
				</video>
			</div>
			
			
			
			
			
			</div>
			
			
			
			
			
			
			<!-- 新建仓库弹窗 -->
			<div id="createRepoModal" class="modal-overlay hidden">
				<div class="modal-form-container">
					<h3>
						<span class="modal-title-text">
							新建仓库
						</span>
						<button class="btn-icon-sm" onclick="hideCreateRepoModal()"
						title="关闭">
							<i class="fa fa-times">
							</i>
						</button>
					</h3>
					<input id="createRepoNameInput" placeholder="输入仓库名称（仅支持英文、数字、连字符）">
					<div id="repoNameError" class="text-red-400" style="font-size: 0.75rem; margin-top: -0.4rem; margin-bottom: 0.4rem; display: none;">
					</div>
					<textarea id="createRepoDescInput" placeholder="仓库描述（可选）">
					</textarea>
					<div class="checkbox-container">
						<input type="checkbox" id="createRepoPrivate">
						<label for="createRepoPrivate">
							公开仓库
						</label>
					</div>
					<div class="modal-buttons">
						<button id="createRepoCancel" class="btn btn-cancel">
							取消
						</button>
						<button id="createRepoConfirm" class="btn btn-primary" disabled>
							创建仓库
						</button>
					</div>
				</div>
			</div>
			<!-- 新建文件夹弹窗 -->
			<div id="createFolderModal" class="modal-overlay hidden">
				<div class="modal-form-container">
					<h3>
						<span class="modal-title-text">
							新建文件夹
						</span>
						<button class="btn-icon-sm" onclick="hideCreateFolderModal()"
						title="关闭">
							<i class="fa fa-times">
							</i>
						</button>
					</h3>
					<input id="createFolderInput" placeholder="输入文件夹名称">
					<div class="modal-buttons">
						<button id="createFolderCancel" class="btn btn-cancel">
							取消
						</button>
						<button id="createFolderConfirm" class="btn btn-primary" disabled>
							确认
						</button>
					</div>
				</div>
			</div>
			<!-- 新建文件弹窗 -->
			<div id="createFileModal" class="modal-overlay hidden">
				<div class="modal-form-container">
					<h3>
						<span class="modal-title-text">
							新建文件
						</span>
						<button class="btn-icon-sm" onclick="hideCreateFileModal()"
						title="关闭">
							<i class="fa fa-times">
							</i>
						</button>
					</h3>
					<input id="createFileNameInput" placeholder="输入文件名，如 example.txt">
					<textarea id="createFileContentInput" placeholder="文件内容（可选）">
					</textarea>
					<div class="modal-buttons">
						<button id="createFileCancel" class="btn btn-cancel">
							取消
						</button>
						<button id="createFileConfirm" class="btn btn-primary" disabled>
							确认
						</button>
					</div>
				</div>
			</div>
			
			
			<!-- 新建分支弹窗 -->
			<div id="createBranchModal" class="modal-overlay hidden">
				<div class="modal-form-container">
					<h3>
						<span class="modal-title-text">
							分支管理
						</span>
						<button class="btn-icon-sm" onclick="hideCreateBranchModal()"
						title="关闭">
							<i class="fa fa-times">
							</i>
						</button>
					</h3>
					<div class="form-group">
						<label for="createBranchNameInput">
							新分支名称:
						</label>
						<input id="createBranchNameInput" placeholder="输入新分支名称">
					</div>
					<div class="form-group">
						<label>
							基于分支:
						</label>
						<div class="branch-select-container">
							<div id="sourceBranchSelector" class="custom-branch-select-wrapper">
								<button class="custom-branch-select-trigger">
									<span>
									</span>
									<i class="fa fa-chevron-down">
									</i>
									
								</button>
								<div class="custom-branch-select-options">
								</div>
							</div>
							<button id="renameBranchBtn" class="btn-icon" title="重命名所选分支">
								<i class="fa fa-pencil">
								</i>
							</button>
							<button id="deleteBranchBtn" class="btn-icon danger" title="删除所选分支">
								<i class="fa-regular fa-trash-can">
								</i>
							</button>
						</div>
					</div>
					<div class="modal-buttons">
						<button id="createBranchCancel" class="btn btn-cancel">
							取消
						</button>
						<button id="createBranchConfirm" class="btn btn-primary" disabled>
							创建分支
						</button>
					</div>
				</div>
			</div>
	
	
<div id="setAsSiteModal" class="modal-overlay hidden">
    <div class="modal-form-container">
        <h3>
            <span class="modal-title-text">发布主网站</span>
            <button class="btn-icon-sm" id="setAsSiteCloseBtn" title="关闭"><i class="fa fa-times"></i></button>
        </h3>
        <p>选择一个分支作为您网站的发布源。</p>
        <div class="form-group">
            <label for="setAsSiteBranchSelector">选择分支:</label>
            <div id="setAsSiteBranchSelector" class="custom-branch-select-wrapper">
                <button class="custom-branch-select-trigger">
                    <span></span>
                    <i class="fa fa-chevron-down"></i>
                </button>
                <div class="custom-branch-select-options">
                    <!-- Branches will be populated here -->
                </div>
            </div>
        </div>
        <div class="modal-buttons">
            <button id="setAsSiteCancelBtn" class="btn btn-cancel">取消</button>
            <button id="setAsSiteConfirmBtn" class="btn btn-primary">确认发布</button>
        </div>
    </div>
</div>
		<!-- 文件上传面板 -->
		<div id="uploadPanel" class="hidden">
			<div id="uploadItems" class="scmz">
			</div>
		</div>
		<!-- 代理设置弹窗 -->
<div id="proxySettingsModal" class="modal-overlay hidden">
    <div class="modal-form-container">
        <!-- 弹窗头部 -->
        <h3>
            <span class="modal-title-text">代理设置</span>
            <div class="proxy-header-actions">
                <label class="switch" title="点击切换全局代理状态">
                    <input type="checkbox" id="proxyGlobalEnableToggle">
                    <span class="slider round"></span>
                </label>
                <button id="proxyCancelSettingsBtn" class="btn-icon-sm" title="关闭设置">
                    <i class="fa fa-times"></i>
                </button>
            </div>
        </h3>

        <!-- 代理列表区域 -->
        <div class="proxy-list-container" id="proxyListContainer">
            <div class="empty-state hidden" id="proxyListEmpty">
                <i class="fa fa-plug"></i>
                <p>暂无代理节点</p>
                <span>点击右下角的 <i class="fa fa-plus-circle"></i> 添加，或从工具栏 <i class="fa fa-cloud-download"></i> 导入</span>
            </div>
            <!-- 代理项动态生成 -->
        </div>

        <!-- 底部操作区 -->
        <div class="proxy-footer-actions">
            <div class="proxy-footer-toolbar">
                <button id="importBtn" class="btn-icon" title="从订阅链接导入并刷新">
    <i class="fa fa-cloud-download"></i>
    <span class="spinner-small hidden" id="importSpinner"></span>
</button>
                <button id="proxyTestAllBtn" class="btn-icon" title="全部测试延迟">
                    <i class="fa-solid fa-bolt"></i>
                    <span class="spinner-small hidden" id="proxyTestAllSpinner"></span>
                </button>
                <button id="proxyAutoSelectToggle" class="btn-icon" title="点击切换自动选择最低延迟代理">
                    <i class="fa fa-magic"></i>
                </button>
                <button id="proxyClearAllBtn" class="btn-icon danger" title="清空所有代理">
                    <i class="fa-regular fa-trash-can"></i>
                </button>
                <button id="proxyAddBtn" class="btn-icon" title="添加代理">
            <i class="fa fa-plus"></i>
        </button>
            </div>
            
            
        </div>
    </div>
</div>
		<!-- 添加/编辑代理弹窗 -->
<div id="addEditProxyModal" class="modal-overlay hidden">
    <div class="modal-form-container">
        <h3 id="addEditProxyTitle">
            <span class="modal-title-text">添加新代理</span>
            <button class="btn-icon-sm" onclick="closeAddEditProxyModal()" title="关闭">
                <i class="fa fa-times"></i>
            </button>
        </h3>

        <input id="addEditProxyUrlInput" type="url" placeholder="请输入代理域名或URL" autocomplete="off">
        
        <div id="addEditProxyError" class="text-red-400" style="font-size: 0.75rem; margin-top: -0.4rem; margin-bottom: 0.4rem; display: none;">
            
        </div>

      

        
        <div class="modal-buttons" style="margin-top:0.6rem;">
            <button id="addEditProxyCancelBtn" class="btn btn-cancel">取消</button>
            <button id="addEditProxySaveBtn" class="btn btn-primary" disabled>保存</button>
        </div>
    </div>
</div>
		<!-- 确认删除代理弹窗 -->
		<div id="confirmDeleteProxyModal" class="modal-overlay hidden">
			<div class="modal-form-container">
				<h3 id="confirmDeleteProxyTitle">
					<span class="modal-title-text">
						确认删除
					</span>
					<button class="btn-icon-sm" onclick="hideConfirmDeleteProxyModal()" title="取消">
						<i class="fa fa-times">
						</i>
					</button>
				</h3>
				<p id="confirmDeleteProxyMessage">
				</p>
				<div class="modal-buttons">
					<button id="confirmDeleteProxyCancelBtn" class="btn btn-cancel">
						取消
					</button>
					<button id="confirmDeleteProxyConfirmBtn" class="btn btn-danger">
						确认删除
					</button>
				</div>
			</div>
		</div>
		<!-- 确认清空代理弹窗 -->
		<div id="confirmClearAllProxiesModal" class="modal-overlay hidden">
			<div class="modal-form-container">
				<h3>
					<span class="modal-title-text">
						确认清空所有代理
					</span>
					<button class="btn-icon-sm" onclick="hideConfirmClearAllProxiesModal()"
					title="取消">
						<i class="fa fa-times">
						</i>
					</button>
				</h3>
				<p>
					这将删除所有代理
				</p>
				<div class="modal-buttons">
					<button id="clearAllProxiesCancelBtn" class="btn btn-cancel">
						取消
					</button>
					<button id="clearAllProxiesConfirmBtn" class="btn btn-danger">
						确认清空
					</button>
				</div>
			</div>
		</div>
		
		
		
		<!-- 多选操作栏 -->
		<div id="multi-select-bar">
			<button class="action-btn cancel-btn" id="cancel-select-btn" title="取消">
				<i class="fa fa-times">
				</i>
			</button>
			<div id="selected-count">
				未选择项目
			</div>
			<div class="action-buttons">
				<button class="action-btn delete-btn" id="delete-btn" title="删除" disabled>
					<i class="fa-regular fa-trash-can"></i>
				</button>
				
				<button class="action-btn" id="download-btn" title="下载" disabled>
					<i class="fa-regular fa-circle-down"></i>
				</button>
				<button class="action-btn" id="invert-select-btn" title="反选" disabled>
					<i class="fa-solid fa-repeat"></i>
				</button>
				<button class="action-btn" id="select-all-btn" title="全选">
					<i class="fa-regular fa-square-minus">
					</i>
				</button>
			</div>
		</div>
		<!-- API状态侧边栏 -->
<div id="apiStatusOverlay" class="api-status-overlay hidden"></div>
<div id="apiStatusPanel" class="api-status-panel">
    <div class.api-status-header">

    <!-- 头部操作按钮 -->
    <div class="api-status-header-actions">
        <h5>数据监控 仪表盘</h5>
        <!-- 刷新按钮 -->
        <button id="refreshApiStatusBtn" class="btn-icon-sm" title="刷新">
            <i class="fa fa-refresh"></i>
        </button>
        <!-- 关闭按钮 -->
        <button id="closeApiStatusPanel" class="btn-icon-sm" title="关闭">
            <i class="fa fa-times"></i>
        </button>
    </div>
</div>


    <div id="apiStatusContent" class="api-status-content"> 
        <!-- 内容动态生成 -->
        <div class="loading-spinner" style="height: auto; padding: 2rem 0;">
            <div class="spinner">
            </div>
        </div>
    </div>
    
</div>
		<!-- 右键菜单设置弹窗 -->
<div id="contextMenuSettingsModal" class="modal-overlay hidden">
    <div class="modal-form-container">
        <h3>
            <span class="modal-title-text">长按菜单项设置</span>
            <button class="btn-icon-sm" id="contextMenuSettingsCloseBtn" title="关闭"><i class="fa fa-times"></i></button>
        </h3>
        <p style="font-size:0.7rem; margin-top:-0.4rem; margin-bottom:0.4rem;">选择在长按时希望看到的快捷操作</p>
        <div class="context-menu-settings-tabs">
        <button class="tab-btn  active" data-tab="file">文件</button>
        <button class="tab-btn" data-tab="folder">文件夹</button>
            <button class="tab-btn" data-tab="repo">仓库</button>
            
            
        </div>
        <div id="contextMenuSettingsContent">
            <!-- 设置项动态生成 -->
        </div>
    </div>
</div>


<!-- 隐藏的头像上传输入框 -->
    <input type="file" id="avatarUploadInput" class="hidden" accept="image/*">
    
    <div id="editorScaleHint" class="hidden">双指缩放来调整大小</div>
    
    
    
    
    <!-- [添加] 账号管理模态框 -->
<div id="accountManagerModal" class="modal-overlay hidden">
    <div class="modal-form-container">
        <h3>
            <span class="modal-title-text">账号管理</span>
            <button class="btn-icon-sm" id="closeAccountManagerModalBtn" title="关闭"><i class="fa fa-times"></i></button>
        </h3>
        
        <!-- 这个容器用于动态显示已保存的账号列表 -->
        <div id="accountListContainer" class="scmz">
            <!-- 账号列表项会由 JavaScript 动态生成并插入到这里 -->
        </div>

        <!-- 当没有保存任何账号时，显示此提示信息 -->
        <div id="accountListEmpty" class="empty-state hidden">
            <i class="fa fa-key"></i>
            <p>您还没有保存任何账号</p>
        </div>

        <!-- 弹窗底部的按钮区域 -->
        <div class="modal-buttons">
            <button id="showAddAccountModalBtn" class="btn btn-primary">
                <i class="fa fa-plus-circle"></i> 添加新账号
            </button>
        </div>
    </div>
</div>




<!-- ====================================================== -->
<!--              添加与编辑账号的弹窗 (模态框)              -->
<!-- ====================================================== -->
<div id="addEditAccountModal" class="modal-overlay hidden">
    <div class="modal-form-container">
        <h3 id="addEditAccountTitle">
            <span class="modal-title-text">添加新账号</span>
            <button class="btn-icon-sm" id="closeAddEditAccountModalBtn" title="关闭"><i class="fa fa-times"></i></button>
        </h3>
        
        <!-- 输入框：用于设置账号的自定义名称 -->
        <input id="accountNameInput" type="text" placeholder="设置一个名称" autocomplete="off">
        
        <!-- 输入框：用于粘贴用户的 GitHub 访问令牌 -->
        <input id="accountTokenInput" type="text" placeholder="粘贴你的GitHub访问令牌" autocomplete="off">
        
        <!-- 用于显示错误信息的容器 -->
        <div id="addEditAccountError" class="text-red-400"></div>
        
        <!-- 弹窗底部的按钮区域 -->
        <div class="modal-buttons">
            <button id="addEditAccountCancelBtn" class="btn btn-cancel">取消</button>
            <button id="addEditAccountSaveBtn" class="btn btn-primary" disabled>
                <span>保存</span><i class="fa fa-spinner fa-spin hidden"></i>
            </button>
        </div>
    </div>
</div>


<!-- 网站发布管理弹窗 -->
<div id="publishManagerModal" class="modal-overlay hidden">
    <div class="modal-form-container">
       <h3>
    <span class="modal-title-text">网站管理</span>
    <div style="display: flex; align-items: center;">
        <button class="btn-icon-sm" id="showPublishHelpBtn" title="帮助说明" style="margin-right: 0.5rem;"><i class="fa fa-question-circle"></i></button>
        <button class="btn-icon-sm" id="closePublishManagerBtn" title="关闭"><i class="fa fa-times"></i></button>
    </div>
</h3>
        
        <div id="publishManageList" class="publish-list">
            <!-- 统一的仓库列表将在这里生成 -->
        </div>

        <div class="modal-buttons">
                    <div class="modal-buttons publish-manager-tabs">
            <button id="officialConfigTabBtn" class="btn btn-tab active">
                官方配置
            </button>
            <button id="customDomainTabBtn" class="btn btn-tab">
                 自定义域名
            </button>
        </div>
        </div>
    </div>
</div>

<!-- Fork 仓库弹窗 -->
<div id="forkRepoModal" class="modal-overlay hidden">
    <div class="modal-form-container">
        <h3>
            <span class="modal-title-text">复刻仓库</span>
            <button class="btn-icon-sm" id="closeForkRepoModalBtn" title="关闭"><i class="fa fa-times"></i></button>
        </h3>
        <p id="forkOriginInfo" class="fork-origin-info"></p>
        <input id="forkRepoNameInput" placeholder="输入新的仓库名称">
        <div id="forkRepoError" class="text-red-400" style="font-size: 0.75rem; margin-top: 0.4rem; display: none;"></div>
        <div class="modal-buttons">
            <button id="forkRepoCancelBtn" class="btn btn-cancel">取消</button>
            <button id="forkRepoConfirmBtn" class="btn btn-primary" disabled>确认复刻</button>
        </div>
    </div>
</div>
<!-- 删除确认弹窗 -->
			<div id="deleteModal" class="modal-overlay hidden">
				<div class="modal-form-container">
					<h3 id="deleteTitle">
						<span class="modal-title-text">
							确认删除
						</span>
						<button class="btn-icon-sm" onclick="hideDeleteModal()"
						title="关闭">
							<i class="fa fa-times">
							</i>
						</button>
					</h3>
					<p id="deleteDesc">
					</p>
					<div class="modal-buttons">
						<button id="deleteCancel" class="btn btn-cancel">
							取消
						</button>
						<button id="deleteConfirm" class="btn btn-danger">
							确认删除
						</button>
					</div>
				</div>
			</div>
			
			<!-- 配置自定义域名弹窗 -->
<div id="customDomainModal" class="modal-overlay hidden">
    <div class="modal-form-container">
        <h3>
            <span class="modal-title-text">配置自定义域名</span>
            <button class="btn-icon-sm" id="closeCustomDomainModalBtn" title="关闭"><i class="fa fa-times"></i></button>
        </h3>
        <p id="customDomainRepoName" style="font-size: 0.8rem; color: #a2a7c7; margin-bottom: 0.8rem;"></p>
        <input id="customDomainInput" type="text" placeholder="例如: 123.baidu.com" autocomplete="off">
        <div id="customDomainError" class="text-red-400" style="font-size: 0.75rem; margin-top: -0.4rem; margin-bottom: 0.4rem; display: none;"></div>
        <div class="modal-buttons">
            <button id="customDomainCancelBtn" class="btn btn-cancel">取消</button>
            <button id="customDomainSaveBtn" class="btn btn-primary" disabled>
                <span>确认</span><i class="fa fa-spinner fa-spin hidden"></i>
            </button>
        </div>
    </div>
</div>


<div id="publishHelpModal" class="modal-overlay hidden">
    <div class="publish-help-dialog">
        <div class="publish-help-header">
            <h3><i class="fa-regular fa-circle-question"></i> 网站部署功能指南</h3>
            <button class="btn-icon-sm" id="closePublishHelpBtn" title="关闭"><i class="fa fa-times"></i></button>
        </div>
        <div class="publish-help-content scmz">
        
            <h4 style="color: #f87171;"><i class="fa-solid fa-triangle-exclamation"></i> 核心规则：域名使用限制</h4>
            <p style="font-weight: bold;">
                自定义域名同一时间只能用于主站或项目网站之一，不能同时使用。为其中一类配置域名，会导致另一类的自定义域名失效。请务必提前规划。
            </p>
           
            <h4><i class="fa-solid fa-bolt"></i> 功能概览</h4>
            <p>
                此功能利用 GitHub Pages 服务，将您的公开仓库一键发布为可公开访问的静态网站。它分为两个管理面板：
            </p>
            <ul>
                <li><b>官方配置：</b> 在此管理所有公开仓库的发布状态。您可以将任何仓库发布为项目网站，或将特定仓库设为您的个人主站。发布的网站将通过 GitHub 官方域名 (<code>*.github.io</code>) 访问。</li>
                <li><b>自定义域名：</b> 在此为您已经发布的网站绑定您自己的域名，让访问更专业、更便捷。</li>
            </ul>

            <h4><i class="fa-solid fa-sitemap"></i> 操作流程</h4>
            <ul>
                 <li><b>发布为主站：</b> 在“官方配置”面板中，找到您想作为主站的仓库，点击“发布为主站”按钮。程序会自动将其重命名为 <code>您的用户名.github.io</code> 并发布。</li>
                 <li><b>发布为项目：</b> 对于其他公开仓库，点击“发布项目”按钮，即可将其发布。</li>
                 <li><b>配置自定义域名：</b> 切换到“自定义域名”面板，找到已发布的网站，点击“配置域名”并按提示操作。</li>
                 <li><b>复制链接：</b> 在任一面板中，直接点击已发布的仓库条目，即可快速复制其对应的访问链接。</li>
            </ul>

            <h4><i class="fa-solid fa-link"></i> 自定义域名配置指南</h4>
            <p>
                要成功绑定您的域名，通常需要以下两个步骤：
            </p>
            <p><strong>第 1 步：在您的域名提供商处添加解析记录</strong></p>
            <ul>
                <li><b>记录类型：</b> 选择 <code>CNAME</code></li>
                <li><b>主机记录：</b> 填入您想使用的前缀，例如 <code>www</code> 或 <code>blog</code>。</li>
                <li><b>记录值 (指向)：</b> 填入您的 GitHub Pages 主站地址，格式为 <code>您的用户名.github.io</code>。
                    <ul style="margin-top:0.4rem;">
                        <li>例如：<code>rjdsq.github.io</code></li>
                    </ul>
                </li>
            </ul>
             <p style="margin-top:0.8rem;">
                <strong>第 2 步 (必须)：将您的域名添加到 Cloudflare</strong>
            </p>
            <p>
                为确保您的网站在中国大陆地区能被稳定访问并自动启用 HTTPS，强烈建议将您的域名添加到免费的 Cloudflare 服务中。
            </p>
            <ul>
                <li><b>配置地址：</b><code style="user-select: text;">https://dash.cloudflare.com</code></li>
                <li><b>操作建议：</b> 登录后，直接添加您的顶级域名（例如 <code>baidu.com</code>），Cloudflare 会自动引导您完成后续设置。</li>
            </ul>
            
            <h4><i class="fa-solid fa-clipboard-list"></i> 重要提示</h4>
            <ul>
                <li><b>仓库要求：</b> 只有<b>公开 (Public)</b> 仓库才能被发布为网站。</li>
                <li><b>主站唯一性：</b> 一个 GitHub 账号只能拥有一个主站，其仓库名必须严格遵守 <code>用户名.github.io</code> 的格式。</li>
                <li><b>取消发布：</b> 对于项目网站，此操作会禁用其 GitHub Pages 功能；对于主站，为安全起见，程序会将其重命名为一个备份名称来使其下线，您的文件不会丢失。</li>
                <li><b>CNAME 文件：</b> 成功配置自定义域名后，系统会在您的仓库根目录下创建一个名为 <code>CNAME</code> 的文件，请不要手动删除或修改它。</li>
            </ul>
        </div>
    </div>
</div>





<div id="usageGuideModal" class="modal-overlay hidden">
    <div class="publish-help-dialog">
        <div class="publish-help-header">
            <h3><i class="fa-regular fa-circle-question"></i> 应用使用指南</h3>
            <button class="btn-icon-sm" id="closeUsageGuideBtn" title="关闭"><i class="fa fa-times"></i></button>
        </div>
        <div class="publish-help-content scmz">
            <p>
                欢迎使用 GitHub 仓库管理器！本指南将帮助您快速上手，并掌握所有能极大提升效率的功能和隐藏技巧。
            </p>
        
            <h4><i class="fa-solid fa-hand-pointer"></i> 核心交互 (必看技巧)</h4>
            <ul>
                <li><b>长按/右键菜单 (核心功能)：</b>在<b>任何</b>仓库、文件夹或文件上长按（移动端）或右键点击（桌面端），即可弹出包含所有可用操作的快捷菜单。<b>这是本应用最高效的操作方式。</b></li>
                <li><b>下拉刷新：</b>在仓库列表或文件列表的顶部，向下拉动页面即可刷新当前视图的内容，无需任何额外点击。</li>
                <li><b>返回手势：</b>应用完美支持浏览器的后退手势或手机的系统返回键，可以方便地在文件夹层级间后退，或从文件视图返回到仓库列表。</li>
                <li><b>顶部标题栏快捷返回：</b>在文件视图的深层目录中，直接点击顶部的<b>仓库名称标题</b>，可以一步到位快速返回到该仓库的根目录。</li>
            </ul>

            <h4><i class="fa-solid fa-users-gear"></i> 账号与设置</h4>
            <ul>
                <li><b>多账号管理：</b>通过主菜单的“切换账号”或登录页的“账号管理”，您可以添加、编辑和快速切换多个GitHub账号，无需频繁输入令牌。</li>
                <li><b>自定义菜单：</b>在主菜单的“菜单设置”中，您可以根据自己的使用习惯，自由开启或关闭长按菜单中的各个功能按钮，打造个性化的操作体验。</li>
                <li><b>主题切换：</b>点击主菜单按钮旁的图标，可以在精心设计的暗色与亮色主题间无缝切换。</li>
            </ul>

            <h4><i class="fa-solid fa-folder-tree"></i> 仓库与文件浏览</h4>
            <ul>
                <li><b>智能底部按钮：</b>在仓库列表页，底部的“新建”按钮是“新建仓库”；进入仓库后，它会自动变为“新建文件夹”和“新建文件”。</li>
                <li><b>仓库置顶：</b>在仓库上长按，选择“置顶”可以将其固定在列表最上方，方便您快速访问常用仓库。</li>
                <li><b>星标与主页切换：</b>在仓库列表页，点击顶部的<i class="fa-regular fa-star"></i>图标可以在“我的仓库”和“星标仓库”之间切换。当您不在主列表时，它会变为<i class="fa-regular fa-house"></i>图标，点击可快速返回主列表。</li>
                <li><b>强大的排序：</b>进入仓库后，工具栏的排序按钮提供按<b>修改时间</b>、名称、大小、类型等多种排序方式。默认按“上新下旧”排列。</li>
                <li><b>网格/列表视图：</b>工具栏的视图切换按钮可以让您在传统的列表模式和更适合预览图片的网格模式之间自由切换。</li>
            </ul>

            <h4><i class="fa-solid fa-magnifying-glass"></i> 全局与本地搜索</h4>
            <p>本应用提供两种强大的搜索模式：</p>
            <ul>
                <li><b>全局搜索 (顶部<i class="fa fa-search"></i>)：</b>在仓库列表页激活，支持多种搜索语法：
                    <ul>
                        <li><b>公共仓库：</b>直接输入关键词，如 <code>vue</code>。</li>
                        <li><b>指定用户：</b>使用 <code>@</code> 前缀，如 <code>@microsoft</code>。</li>
                        <li><b>我的文件：</b>使用 <code>#</code> 前缀，在您<b>所有</b>仓库中搜索文件，如 <code>#config.js</code>。</li>
                        <li><b>链接直达：</b>直接粘贴任意GitHub仓库或文件的链接。</li>
                    </ul>
                </li>
                <li><b>本地搜索 (工具栏<i class="fa fa-search"></i>)：</b>进入仓库后激活，仅在<b>当前仓库和文件夹</b>内进行文件和文件夹的递归搜索，结果更精确。</li>
            </ul>

            <h4><i class="fa-solid fa-rocket"></i> 高级工具</h4>
            <ul>
                <li><b>代理设置 (核心优势)：</b>内置强大的网络代理功能。您可以通过订阅链接一键导入节点。其核心是“<b>自动优选</b>”模式，它会自动测试所有节点并为您切换到延迟最低的线路。这能完美解决因网络问题导致的图片预览慢、文件下载失败等情况。</li>
                <li><b>多选模式：</b>进入仓库后，点击工具栏的 <i class="fa-regular fa-circle-check"></i> 图标即可进入多选模式。底部会弹出操作栏，支持批量删除、批量下载为ZIP压缩包、反选和全选等高效操作。</li>
                <li><b>API 仪表盘：</b>通过主菜单的“数据监控”进入。它可以实时显示您GitHub账号的API请求额度。当您遇到操作失败时，可以来这里检查是否是“核心”或“搜索”额度暂时耗尽。</li>
            </ul>

            <h4><i class="fa-solid fa-file-pen"></i> 文件编辑器</h4>
            <ul>
                <li><b>字体缩放：</b>在编辑器内，您可以通过双指捏合进行缩放文字大小 </li>
                <li><b>内容查找：</b>点击编辑器底部的<i class="fa fa-search"></i>图标，可以在当前打开的文件内进行关键词查找。</li>
                <li><b>全屏模式：</b>点击编辑器底部的<i class="fa fa-expand"></i>图标，可以进入沉浸式编辑状态，获得最大的编辑空间。</li>
                <li><b>撤销修改：</b>如果您修改了文件但尚未保存，可以点击<i class="fa fa-undo"></i>按钮一键撤销所有更改，恢复到文件原始状态。</li>
            </ul>
        </div>
    </div>
</div>




<div id="repoDetailsModal" class="modal-overlay hidden">
    <div class="repo-details-dialog">
        <div class="repo-details-header">
            <img id="repoDetailsAvatar" src="" alt="Owner Avatar">
            <div class="repo-details-title">
                <h3 id="repoDetailsName"></h3>
                <p id="repoDetailsOwner"></p>
            </div>
            <button id="repoDetailsCloseBtn" class="btn-icon-sm" title="关闭"><i class="fa fa-times"></i></button>
        </div>

        <div class="repo-details-stats">
            <span id="repoDetailsStars"><i class="fa-regular fa-star"></i> ---</span>
            <span id="repoDetailsForks"><i class="fa-solid fa-code-fork"></i> ---</span>
            <span id="repoDetailsWatchers"><i class="fa-regular fa-eye"></i> ---</span>
        </div>

        <div class="repo-details-body">
            <p id="repoDetailsDescription"></p>
        </div>

        <div class="repo-details-topics" id="repoDetailsTopics">
        </div>

        <div class="repo-details-meta">
            <p id="repoDetailsLanguage"><strong>语言：</strong> ---</p>
            <p id="repoDetailsLicense"><strong>许可证：</strong> ---</p>
            <p id="repoDetailsDates">---</p>
        </div>

        <div class="repo-details-footer">
            <button id="repoDetailsGoToBtn" class="btn btn-primary">进入仓库</button>
        </div>
    </div>
</div>


<!-- 待上传文件管理面板 -->
<div id="preUploadModal" class="modal-overlay hidden">
    <div class="modal-form-container">
        <h3>
            <span class="modal-title-text">待上传文件</span>
            <button class="btn-icon-sm" onclick="hidePreUploadModal()" title="关闭">
                <i class="fa fa-times"></i>
            </button>
        </h3>
        
        <div id="preUploadList" class="scmz" style="max-height: 300px; overflow-y: auto; margin: 10px 0; border: 1px solid #374151; border-radius: 4px; padding: 5px;">
            <div class="empty-state" style="padding: 20px;">
                <p>暂无文件，请点击下方按钮添加</p>
            </div>
        </div>

        <div class="modal-buttons" style="justify-content: space-between;">
            <button id="preUploadAddBtn" class="btn btn-secondary">
                <i class="fa fa-plus"></i> 添加文件
            </button>
            <div style="display: flex; gap: 10px;">
                <button id="preUploadClearBtn" class="btn btn-danger">清空</button>
                <button id="preUploadStartBtn" class="btn btn-primary">开始上传</button>
            </div>
        </div>
    </div>
</div>




<!-- 版本管理/发布弹窗 (修复缺失部分) -->
<div id="releaseManagerModal" class="modal-overlay hidden">
    <div class="modal-form-container">
        <h3>
            <span class="modal-title-text">发布新版本</span>
            <button class="btn-icon-sm" id="closeReleaseManagerBtn" title="关闭">
                <i class="fa fa-times"></i>
            </button>
        </h3>
        
        <!-- 发布表单 -->
        <div id="createReleaseForm" class="flex flex-col gap-2">
        
        <div class="form-group">
                <label style="font-size:0.75rem; color:#a2a7c7;">标题</label>
                <input id="releaseNameInput" placeholder="版本标题 (可选)">
            </div>
            
            <div class="form-group">
                <label style="font-size:0.75rem; color:#a2a7c7;">版本号</label>
                <input id="releaseTagNameInput" placeholder="v1.0.0">
            </div>
            
            
            
            <div class="form-group">
                <label style="font-size:0.75rem; color:#a2a7c7;">描述内容</label>
                <textarea id="releaseBodyInput" placeholder="本次更新了什么..." style="min-height:100px;"></textarea>
            </div>

            <div class="checkbox-container" style="margin-bottom:10px;">
                <input type="checkbox" id="releasePrerelease">
                <label for="releasePrerelease">设为预发布 (Pre-release)</label>
            </div>

            <div class="modal-buttons">
                <button id="cancelReleaseBtn" class="btn btn-cancel">取消</button>
                <button id="submitReleaseBtn" class="btn btn-primary">发布版本</button>
            </div>
        </div>
        
        <!-- 这里的隐藏元素是为了兼容原有JS逻辑防止报错 -->
        <div id="releaseManagerList" class="hidden"></div>
        <span id="releaseCountBadge" class="hidden"></span>
        <button id="toggleCreateReleaseFormBtn" class="hidden"><i class="fa fa-chevron-down"></i></button>
    </div>
</div>



<!-- 特效管理弹窗 -->
<div id="effectsManagerModal" class="modal-overlay hidden">
    <div class="modal-form-container">
        <h3>
            <span class="modal-title-text">特效管理</span>
            <button class="btn-icon-sm" id="closeEffectsManagerBtn" title="关闭"><i class="fa fa-times"></i></button>
        </h3>
        <p style="font-size: 0.8rem; color: #9ca3af; margin-bottom: 0.8rem;">
      特效为云端更新，可叠加多个使用；支持特效层级切换，部分特效暂不支持切换。
        </p>
        <div id="effectsList" class="scmz" style="max-height: 400px; min-height: 260px;overflow-y: auto; display: flex; flex-direction: column; gap: 0.5rem; padding-bottom: 0.3rem;">
            <!-- 列表由 JS 动态生成 -->
        </div>
    </div>
</div>
<script>

let currentManagingRepo = null;
let imageObserver = null;
const CURRENT_VERSION = "3.8";
document.documentElement.style.userSelect = 'none';
const toastQueue = [];
let isToastVisible = false;
let modalLastTapTime = 0;
let modalLastTappedRepoId = null;
let currentFetchController = null;
let isContextMenuClosing = false;
const PROXY_TEST_URL = 'https://raw.githubusercontent.com/rjdsq/rjdsq.github.io/main/github/代理.txt';
const IMAGE_EXTS = ['png', 'jpg', 'jpeg', 'gif', 'webp', 'ico', 'bmp', 'svg'];
const VIDEO_EXTS = ['mp4', 'webm', 'ogg', 'mov', 'avi', 'mkv'];
const AUDIO_EXTS = ['mp3', 'wav', 'ogg', 'flac', 'm4a'];
const ZIP_EXTS = ['zip',];
const uiStateStack = [];


const NON_EDITABLE_EXTS = [
    'zip', 'rar', '7z', 'tar', 'gz', 'iso', 'bin',
    'pdf', 'doc', 'docx', 'xls', 'xlsx', 'ppt', 'pptx',
    'exe', 'dll', 'so', 'dmg', 'app', 'apk',
    'woff', 'woff2', 'ttf', 'otf',
    'db', 'sqlite', 'mdb'
];

const state = {
    
    accounts: JSON.parse(localStorage.getItem('github_accounts') || '[]'),
    activeAccountId: localStorage.getItem('active_github_account_id') || null,
    token: null,
    localAvatar: null,
    viewingOwner: null,
    pendingUploadFiles: [], 
    currentRepo: null,
    currentPath: '',
    currentBranch: null,
    branches: [],
    files: [],
    publicSearchQuery: '',
    displayFiles: [],
    isRefreshing: false,
    repos: [],
    starredRepos: [],
    selectedFile: null,
    selectedRepo: null,
    uploadQueue: [],
    releases: [],                      // 用于存储当前仓库的版本列表
    currentRelease: null,              // 用于存储当前正在查看的单个版本对象
    viewingReleasesForRepo: null,   
    
    editingFile: null,
    fileSha: '',
    publishManagerActiveTab: 'official',
    configuringDomainRepoFullName: null,
    
    publicSearchPage: 1,
    publicSearchTotalResults: 0,
    publicSearchPerPage: 20, 
    
    repoListScrollPosition: 0,
    publicSearchCache: new Map(),
    
    
    myRepos: [],
    
    
    originalContent: '',
    proxies: JSON.parse(localStorage.getItem('proxies') || '[]'),
    activeProxyIndex: parseInt(localStorage.getItem('active_proxy_index') || '0'),
    proxyGlobalEnable: JSON.parse(localStorage.getItem('proxy_global_enable') || 'true'),
    autoSelectProxy: JSON.parse(localStorage.getItem('proxy_auto_select') || 'false'),
    editingProxyIndex: null,
    user: null,
    fileCache: new Map(),
    viewMode: localStorage.getItem('view_mode') || 'grid',
    sortBy: localStorage.getItem('sort_by') || 'name_asc',
    
    
        directorySortPriority: localStorage.getItem('directory_sort_priority') || 'dirs_first',
    searchQuery: '',
    REPOS_PER_PAGE: 20,
    myReposPage: 1,
    starredReposPage: 1,
    userReposPage: 1,
    
   
    
    isMultiSelectMode: false,
    selectedItems: new Set(),
    contextMenuVisibility: {},
    shouldAnimateList: true,
    currentView: 'own_repos',
    viewingOwner: null,
    editorSearchState: {
    query: '',
    matches: [],
    currentIndex: -1
},


    
    isSearchResultsView: false,
    isLocalSearchResultsView: false,
    lastSearchResults: [],
    currentRepoList: [],
   searchHistory: [],
  
    pullToRefresh: {
        active: false,
        startY: 0,
        pullDistance: 0,
        threshold: 60,
        el: null,
        indicator: null
    }
};

if (state.proxies.length === 0) {
    state.activeProxyIndex = -1;
} else if (state.activeProxyIndex < 0 || state.activeProxyIndex >= state.proxies.length) {
    state.activeProxyIndex = 0;
}


initializeActiveToken(); 
const CONTEXT_MENU_DEFINITIONS = {
    repo: [
        { action: 'togglePin', icon: 'fa-thumbtack', text: '置顶/取消' },
        { action: 'forkRepo', icon: 'fa-code-fork', text: '复刻仓库' },
        
        { action: 'viewUserRepos', icon: 'fa-solid fa-user-group', text: '所有仓库' },
        { action: 'renameRepo', icon: 'fa-pencil', text: '仓库设置' },
        { action: 'createBranch', icon: 'fa-code-fork', text: '分支管理' },
        { action: 'manageReleases', icon: 'fa-tags', text: '版本管理' },
        { action: 'downloadRepoDirect', icon: 'fa-regular fa-circle-down', text: '代理下载' },
        { action: 'copyMainSiteLink', icon: 'fa-link', text: '主站链接' },
        { action: 'copyProjectSiteLink', icon: 'fa-link', text: '网站链接' },
        { action: 'copyCustomDomainLink', icon: 'fa-link', text: '域名链接' },
        { action: 'copyRepoGitHubLink', icon: 'fa-link', text: '仓库链接' },
        { action: 'viewDetails', icon: 'fa-regular fa-eye', text: '仓库详情' },
        { action: 'deleteRepo', icon: 'fa-trash', text: '删除', className: 'text-red-400' }
    ],
    
    folder: [
        { action: 'copyPagesLink', icon: 'fa-globe', text: '网站链接' },
        { action: 'copyGitHubLink', icon: 'fa-link', text: '仓库链接' },
        { action: 'rename', icon: 'fa-pencil', text: '重命名' },
        { action: 'downloadFolder', icon: 'fa-regular fa-circle-down', text: '下载 ZIP' },
        { action: 'delete', icon: 'fa-trash', text: '删除', className: 'text-red-400' }
    ],
    
    file: [
        { action: 'goToDirectory', icon: 'fa-regular fa-folder-open', text: '进入目录' }, 
        { action: 'edit', icon: 'fa-edit', text: '编辑' },
        { action: 'rename', icon: 'fa-pencil', text: '重命名' },
        { action: 'download', icon: 'fa-download', text: '代理下载' },
        { action: 'copyPagesLink', icon: 'fa-link', text: '网站链接' },
        { action: 'copyCustomDomainLink', icon: 'fa-link', text: '域名链接' },
        { action: 'copyGitHubLink', icon: 'fa-link', text: '仓库链接' },
        { action: 'copyLink', icon: 'fa-link', text: '复制raw链接' },
        { action: 'copyProxy', icon: 'fa-link', text: '复制代理链接' },
        { action: 'unzip', icon: 'fa-regular fa-circle-down', text: '解压缩(仅ZIP)' },
        { action: 'delete', icon: 'fa-trash', text: '删除', className: 'text-red-400' }
    ]
};
const DEFAULT_MENU_VISIBILITY = {
    repo: CONTEXT_MENU_DEFINITIONS.repo.reduce((acc, item) => ({ ...acc, [item.action]: true }), {}),
    folder: CONTEXT_MENU_DEFINITIONS.folder.reduce((acc, item) => ({ ...acc, [item.action]: true }), {}),
    file: CONTEXT_MENU_DEFINITIONS.file.reduce((acc, item) => ({ ...acc, [item.action]: true }), {})
};

const el = {

main: document.querySelector('main'), 
    authScreen: document.getElementById('authScreen'),
    app: document.getElementById('app'),
    tokenInput: document.getElementById('tokenInput'),
    authBtn: document.getElementById('authBtn'),
    fileList: document.getElementById('fileList'),
    repoList: document.getElementById('repoList'),
    pathNav: document.getElementById('pathNav'),
    pathNavContainer: document.getElementById('pathNavContainer'),
    ybp: document.getElementById('ybp'),
    branchSwitcherContainer: document.getElementById('branchSwitcherContainer'),
    backBtn: document.getElementById('backBtn'),
    newFolderBtn: document.getElementById('newFolderBtn'),
    uploadBtn: document.getElementById('uploadBtn'),
    sideNav: document.getElementById('sideNav'),
    // 在 const el = { ... } 内部添加：
    newReleaseBtn: document.getElementById('newReleaseBtn'),
    mainOverlay: document.getElementById('mainOverlay'),
    sideNavToggleBtn: document.getElementById('sideNavToggleBtn'),
    menuUsageGuide: document.getElementById('menuUsageGuide'), // <--- 添加这一行
    usageGuideModal: document.getElementById('usageGuideModal'),   // <--- 添加这一行
    closeUsageGuideBtn: document.getElementById('closeUsageGuideBtn'),
    contextMenu: document.getElementById('contextMenu'),
    contextMenuItems: document.getElementById('contextMenuItems'),
    toast: document.getElementById('toast'),
    toastMessage: document.getElementById('toastMessage'),
    uploadPanel: document.getElementById('uploadPanel'),
    uploadItems: document.getElementById('uploadItems'),
    editModal: document.getElementById('editModal'),
    editFileName: document.getElementById('editFileName'),
    fileContent: document.getElementById('fileContent'),
    closeEditModal: document.getElementById('closeEditModal'),
    cancelEdit: document.getElementById('cancelEdit'),
    saveEdit: document.getElementById('saveEdit'),
    editStatus: document.getElementById('editStatus'),
    editorOverlay: document.getElementById('editorOverlay'),
    saveNotification: document.getElementById('saveNotification'),
    setAsSiteModal: document.getElementById('setAsSiteModal'),
setAsSiteCloseBtn: document.getElementById('setAsSiteCloseBtn'),
setAsSiteCancelBtn: document.getElementById('setAsSiteCancelBtn'),
setAsSiteConfirmBtn: document.getElementById('setAsSiteConfirmBtn'),
    fileUploadInput: document.getElementById('fileUploadInput'),
    mainLoader: document.getElementById('mainLoader'),
    repoDetailsModal: document.getElementById('repoDetailsModal'),
    menuLogout: document.getElementById('menuLogout'),
    menuProxySettings: document.getElementById('menuProxySettings'),
    proxyTestAllBoltIcon: document.querySelector('#proxyTestAllBtn > i'),
    
    menuBatchPublishSites: document.getElementById('menuBatchPublishSites'),
    newFileBtn: document.getElementById('newFileBtn'),
    
     publishManageList: document.getElementById('publishManageList'),
       customDomainTabBtn: document.getElementById('customDomainTabBtn'),


    releaseManagerModal: document.getElementById('releaseManagerModal'),
    closeReleaseManagerBtn: document.getElementById('closeReleaseManagerBtn'),
    releaseTagNameInput: document.getElementById('releaseTagNameInput'),
    releaseNameInput: document.getElementById('releaseNameInput'),
    releaseBodyInput: document.getElementById('releaseBodyInput'),
    releasePrerelease: document.getElementById('releasePrerelease'),
    submitReleaseBtn: document.getElementById('submitReleaseBtn'),
    cancelReleaseBtn: document.getElementById('cancelReleaseBtn'),




    customDomainModal: document.getElementById('customDomainModal'),
    closeCustomDomainModalBtn: document.getElementById('closeCustomDomainModalBtn'),
    customDomainRepoName: document.getElementById('customDomainRepoName'),
    customDomainInput: document.getElementById('customDomainInput'),
    customDomainError: document.getElementById('customDomainError'),
    customDomainCancelBtn: document.getElementById('customDomainCancelBtn'),
    customDomainSaveBtn: document.getElementById('customDomainSaveBtn'),
menuUsageGuide: document.getElementById('menuUsageGuide'),
    preUploadModal: document.getElementById('preUploadModal'),
    preUploadList: document.getElementById('preUploadList'),
    preUploadAddBtn: document.getElementById('preUploadAddBtn'),
    preUploadStartBtn: document.getElementById('preUploadStartBtn'),
    preUploadClearBtn: document.getElementById('preUploadClearBtn'),
    customDomainTabBtn: document.getElementById('customDomainTabBtn'),
    toolbar: document.getElementById('toolbar'),
    searchInput: document.getElementById('searchInput'),
    viewToggleBtn: document.getElementById('viewToggleBtn'),
    proxyQuickToggle: document.getElementById('proxyQuickToggle'),
    proxySettingsModal: document.getElementById('proxySettingsModal'),
    proxyAutoSelectToggle: document.getElementById('proxyAutoSelectToggle'),
    userName: document.getElementById('userName'),
    importBtn: document.getElementById('importBtn'),
    proxyGlobalEnableToggle: document.getElementById('proxyGlobalEnableToggle'),
    proxyAddBtn: document.getElementById('proxyAddBtn'),
    proxyListContainer: document.getElementById('proxyListContainer'),
    proxyListEmpty: document.getElementById('proxyListEmpty'),
    proxyTestAllBtn: document.getElementById('proxyTestAllBtn'),
    proxyTestAllSpinner: document.getElementById('proxyTestAllSpinner'),
    proxyClearAllBtn: document.getElementById('proxyClearAllBtn'),
    proxyCancelSettingsBtn: document.getElementById('proxyCancelSettingsBtn'),
    addEditProxyModal: document.getElementById('addEditProxyModal'),
    addEditProxyTitle: document.getElementById('addEditProxyTitle'),
    addEditProxyUrlInput: document.getElementById('addEditProxyUrlInput'),
    addEditProxyError: document.getElementById('addEditProxyError'),
    addEditProxySaveBtn: document.getElementById('addEditProxySaveBtn'),
    confirmDeleteProxyModal: document.getElementById('confirmDeleteProxyModal'),
    confirmDeleteProxyTitle: document.getElementById('confirmDeleteProxyTitle'),
        importSpinner: document.getElementById('importSpinner'),
    confirmDeleteProxyMessage: document.getElementById('confirmDeleteProxyMessage'),
    confirmDeleteProxyCancelBtn: document.getElementById('confirmDeleteProxyCancelBtn'),
    confirmDeleteProxyConfirmBtn: document.getElementById('confirmDeleteProxyConfirmBtn'),
    confirmClearAllProxiesModal: document.getElementById('confirmClearAllProxiesModal'),
    clearAllProxiesCancelBtn: document.getElementById('clearAllProxiesCancelBtn'),
    clearAllProxiesConfirmBtn: document.getElementById('clearAllProxiesConfirmBtn'),
    renameModal: document.getElementById('renameModal'),
    renameTitle: document.getElementById('renameTitle'),
    renameInput: document.getElementById('renameInput'),
    renameWarn: document.getElementById('renameWarn'),
    renameCancel: document.getElementById('renameCancel'),
    renameConfirm: document.getElementById('renameConfirm'),
    renameBranchBtn: document.getElementById('renameBranchBtn'),
    deleteModal: document.getElementById('deleteModal'),
    deleteTitle: document.getElementById('deleteTitle'),
    deleteDesc: document.getElementById('deleteDesc'),
    deleteCancel: document.getElementById('deleteCancel'),
    deleteConfirm: document.getElementById('deleteConfirm'),
    createRepoModal: document.getElementById('createRepoModal'),
    createRepoNameInput: document.getElementById('createRepoNameInput'),
    createRepoDescInput: document.getElementById('createRepoDescInput'),
    createRepoPrivate: document.getElementById('createRepoPrivate'),
    repoNameError: document.getElementById('repoNameError'),
    createRepoCancel: document.getElementById('createRepoCancel'),
    createRepoConfirm: document.getElementById('createRepoConfirm'),
    createFolderModal: document.getElementById('createFolderModal'),
    createFolderInput: document.getElementById('createFolderInput'),
    createFolderCancel: document.getElementById('createFolderCancel'),
    createFolderConfirm: document.getElementById('createFolderConfirm'),
    createFileModal: document.getElementById('createFileModal'),
    createFileNameInput: document.getElementById('createFileNameInput'),
    createFileContentInput: document.getElementById('createFileContentInput'),
    createFileCancel: document.getElementById('createFileCancel'),
    createFileConfirm: document.getElementById('createFileConfirm'),
    createBranchModal: document.getElementById('createBranchModal'),
    createBranchNameInput: document.getElementById('createBranchNameInput'),
    createBranchCancel: document.getElementById('createBranchCancel'),
    createBranchConfirm: document.getElementById('createBranchConfirm'),
    deleteBranchBtn: document.getElementById('deleteBranchBtn'),
    searchToggleBtn: document.getElementById('searchToggleBtn'),
    sortToggleBtn: document.getElementById('sortToggleBtn'),
    customSortDropdown: document.getElementById('customSortDropdown'),
    avatarContainer: document.getElementById('avatarContainer'),
    avatarUploadInput: document.getElementById('avatarUploadInput'),
    userAvatar: document.getElementById('userAvatar'),
    userAvatarPlaceholder: document.getElementById('userAvatarPlaceholder'),
    multiSelectToggleBtn: document.getElementById('multiSelectToggleBtn'),
    multiSelectBar: document.getElementById('multi-select-bar'),
    cancelSelectBtn: document.getElementById('cancel-select-btn'),
    selectAllBtn: document.getElementById('select-all-btn'),
    invertSelectBtn: document.getElementById('invert-select-btn'),
    downloadBtn: document.getElementById('download-btn'),
    deleteBtn: document.getElementById('delete-btn'),
    selectedCountSpan: document.getElementById('selected-count'),
    menuContextMenuSettings: document.getElementById('menuContextMenuSettings'),
    contextMenuSettingsModal: document.getElementById('contextMenuSettingsModal'),
    contextMenuSettingsCloseBtn: document.getElementById('contextMenuSettingsCloseBtn'),
    contextMenuSettingsContent: document.getElementById('contextMenuSettingsContent'),
    currentRepo: document.getElementById('currentRepo'),
    apiStatusPanel: document.getElementById('apiStatusPanel'),
    apiStatusOverlay: document.getElementById('apiStatusOverlay'),
    apiStatusContent: document.getElementById('apiStatusContent'),
    closeApiStatusPanel: document.getElementById('closeApiStatusPanel'),
    refreshApiStatusBtn: document.getElementById('refreshApiStatusBtn'),
    revertEditBtn: document.getElementById('revertEditBtn'),
    editorScaleHint: document.getElementById('editorScaleHint'),
    searchInFileBtn: document.getElementById('searchInFileBtn'),
editorSearchPanel: document.getElementById('editorSearchPanel'),
editorSearchInput: document.getElementById('editorSearchInput'),
editorSearchMatchCount: document.getElementById('editorSearchMatchCount'),
editorSearchPrevBtn: document.getElementById('editorSearchPrevBtn'),
editorSearchNextBtn: document.getElementById('editorSearchNextBtn'),
editorSearchCloseBtn: document.getElementById('editorSearchCloseBtn'),
    manageAccountsBtn: document.getElementById('manageAccountsBtn'),
    menuSwitchAccount: document.getElementById('menuSwitchAccount'),
    accountManagerModal: document.getElementById('accountManagerModal'),
    closeAccountManagerModalBtn: document.getElementById('closeAccountManagerModalBtn'),
    accountListContainer: document.getElementById('accountListContainer'),
    accountListEmpty: document.getElementById('accountListEmpty'),
    showAddAccountModalBtn: document.getElementById('showAddAccountModalBtn'),
    addEditAccountModal: document.getElementById('addEditAccountModal'),
    addEditAccountTitle: document.getElementById('addEditAccountTitle'),
    closeAddEditAccountModalBtn: document.getElementById('closeAddEditAccountModalBtn'),
    accountNameInput: document.getElementById('accountNameInput'),
    accountTokenInput: document.getElementById('accountTokenInput'),
    addEditAccountError: document.getElementById('addEditAccountError'),
    addEditAccountCancelBtn: document.getElementById('addEditAccountCancelBtn'),
    addEditAccountSaveBtn: document.getElementById('addEditAccountSaveBtn'),
    menuThemeToggle: document.getElementById('menuThemeToggle'),
    publishManagerModal: document.getElementById('publishManagerModal'),
    closePublishManagerBtn: document.getElementById('closePublishManagerBtn'),
    publishManageList: document.getElementById('publishManageList'),
    officialConfigTabBtn: document.getElementById('officialConfigTabBtn'),
    showPublishHelpBtn: document.getElementById('showPublishHelpBtn'),
    publishHelpModal: document.getElementById('publishHelpModal'),
    closePublishHelpBtn: document.getElementById('closePublishHelpBtn')
    
};

function handleBackPress() {
    if (uiStateStack.length > 0) {
        const closeFunction = uiStateStack.pop();
        if (typeof closeFunction === 'function') {
            closeFunction();
        }
        history.pushState(history.state, '', window.location.href);
        return true;
    }
    return false;
}







const themeManager = {
    apply(theme) {
        const themeToggle = document.getElementById('menuThemeToggle');
        if (!themeToggle) return;
        const icon = themeToggle.querySelector('i');
        
        document.documentElement.classList.remove('light-theme-loading');

        const oldThemeMeta = document.querySelector('meta[name="theme-color"]');
        if (oldThemeMeta) {
            oldThemeMeta.remove();
        }
        
        const oldAppleMeta = document.querySelector('meta[name="apple-mobile-web-app-status-bar-style"]');
        if (oldAppleMeta) {
            oldAppleMeta.remove();
        }

        const newThemeMeta = document.createElement('meta');
        newThemeMeta.setAttribute('name', 'theme-color');
        
        const newAppleMeta = document.createElement('meta');
        newAppleMeta.setAttribute('name', 'apple-mobile-web-app-status-bar-style');

        if (theme === 'light') {
            document.body.classList.add('light-theme');
            if (icon) icon.className = 'fa-regular fa-moon';
            newThemeMeta.setAttribute('content', '#f0f2f5');
            newAppleMeta.setAttribute('content', 'default');
        } else {
            document.body.classList.remove('light-theme');
            if (icon) icon.className = 'fa-regular fa-cloud';
            newThemeMeta.setAttribute('content', '#04091a');
            newAppleMeta.setAttribute('content', 'black-translucent');
        }
        
        setTimeout(() => {
            document.head.appendChild(newThemeMeta);
            document.head.appendChild(newAppleMeta);
        }, 0);
    },
    toggle() {
        const currentTheme = document.body.classList.contains('light-theme') ? 'light' : 'dark';
        const newTheme = currentTheme === 'light' ? 'dark' : 'light';
        this.apply(newTheme);
        try {
            localStorage.setItem('app_theme', newTheme);
        } catch (e) {
            console.error('无法保存主题设置:', e);
        }
    },
    init() {
        try {
            const savedTheme = localStorage.getItem('app_theme') || 'light';
            this.apply(savedTheme);
        } catch (e) {
            console.error('无法加载主题设置:', e);
            this.apply('light');
        }
    }
};






function loadSearchHistory() {
    try {
        const history = JSON.parse(localStorage.getItem('search_history') || '[]');
        state.searchHistory = Array.isArray(history) ? history : [];
    } catch (e) {
        state.searchHistory = [];
    }
}

function saveSearchHistory() {
    localStorage.setItem('search_history', JSON.stringify(state.searchHistory));
}

function addSearchToHistory(query) {
    if (!query) return;
    const trimmedQuery = query.trim();
    if (!trimmedQuery) return;
    
    const existingIndex = state.searchHistory.indexOf(trimmedQuery);
    if (existingIndex > -1) {
        state.searchHistory.splice(existingIndex, 1);
    }
    state.searchHistory.unshift(trimmedQuery);
    state.searchHistory = state.searchHistory.slice(0, 10);
    saveSearchHistory();
}

function clearSearchHistory() {
    state.searchHistory = [];
    saveSearchHistory();
    renderSearchHistory();
}

function renderSearchHistory() {
    const container = document.getElementById('globalSearchHistoryContainer');
    container.innerHTML = '';

    if (state.searchHistory.length === 0) {
        container.classList.add('hidden');
        return;
    }

    state.searchHistory.forEach(query => {
        const item = document.createElement('div');
        item.className = 'history-item';
        item.textContent = query;

        item.addEventListener('mousedown', (e) => {
            e.preventDefault();
            const searchInput = document.getElementById('globalSearchInput');
            searchInput.value = query;
            handleGlobalSearch(query);
            container.classList.add('hidden');
        });
        container.appendChild(item);
    });

    const footer = document.createElement('div');
    footer.className = 'search-history-footer';
    
    const clearBtn = document.createElement('button');
    clearBtn.id = 'clearSearchHistoryBtn';
    clearBtn.textContent = '清空搜索历史';
    
    clearBtn.addEventListener('mousedown', (e) => {
        e.preventDefault();
        clearSearchHistory();
    });
    
    footer.appendChild(clearBtn);
    container.appendChild(footer);

    container.classList.remove('hidden');
}



function formatNumber(num) {
    if (num === null || num === undefined) return '---';
    if (num < 1000) return num.toString();
    if (num < 1000000) return (num / 1000).toFixed(1).replace(/\.0$/, '') + 'k';
    return (num / 1000000).toFixed(1).replace(/\.0$/, '') + 'M';
}

function showRepoDetailsModal(repo) {
    if (!repo) return;
    
    document.getElementById('repoDetailsAvatar').src = repo.owner.avatar_url;
    document.getElementById('repoDetailsName').textContent = repo.name;
    document.getElementById('repoDetailsOwner').textContent = repo.owner.login;

    document.getElementById('repoDetailsStars').innerHTML = `<i class="fa-regular fa-star"></i> ${formatNumber(repo.stargazers_count)}`;
    document.getElementById('repoDetailsForks').innerHTML = `<i class="fa-solid fa-code-fork"></i> ${formatNumber(repo.forks_count)}`;
    document.getElementById('repoDetailsWatchers').innerHTML = `<i class="fa-regular fa-eye"></i> ${formatNumber(repo.watchers_count)}`;
    
    const descriptionEl = document.getElementById('repoDetailsDescription');
    descriptionEl.textContent = repo.description || '这个仓库没有描述。';
    descriptionEl.scrollTop = 0;

    const topicsContainer = document.getElementById('repoDetailsTopics');
    topicsContainer.innerHTML = '';
    if (repo.topics && repo.topics.length > 0) {
        repo.topics.forEach(topic => {
            const tag = document.createElement('span');
            tag.className = 'topic-tag';
            tag.textContent = topic;
            topicsContainer.appendChild(tag);
        });
    }

    document.getElementById('repoDetailsLanguage').innerHTML = `<strong>语言：</strong> ${repo.language || '未知'}`;
    document.getElementById('repoDetailsLicense').innerHTML = `<strong>许可证：</strong> ${repo.license ? repo.license.name : '无'}`;
    document.getElementById('repoDetailsDates').textContent = `创建于 ${formatRelativeTime(new Date(repo.created_at))} · 更新于 ${formatRelativeTime(new Date(repo.updated_at))}`;

    const goToBtn = document.getElementById('repoDetailsGoToBtn');
    goToBtn.onclick = (e) => {
        e.stopPropagation();
        hideRepoDetailsModal();
        navigateToRepo(repo, repo.default_branch);
    };

    el.repoDetailsModal.classList.remove('hidden');
    uiStateStack.push(hideRepoDetailsModal);
}

function hideRepoDetailsModal() {
    el.repoDetailsModal.classList.add('hidden');
    const index = uiStateStack.indexOf(hideRepoDetailsModal);
    if (index > -1) uiStateStack.splice(index, 1);
}






function initializeActiveToken() {
    state.token = null; 
    if (state.activeAccountId && state.accounts.length > 0) {
        const activeAccount = state.accounts.find(acc => acc.id === state.activeAccountId);
        if (activeAccount) {
            state.token = activeAccount.token;
        } else {

            state.activeAccountId = null;
            localStorage.removeItem('active_github_account_id');
        }
    }
}



function showAccountManagerModal() {
    renderAccountList();
    el.accountManagerModal.classList.remove('hidden');
    uiStateStack.push(closeAccountManagerModal);
}

function closeAccountManagerModal() {
    el.accountManagerModal.classList.add('hidden');
    const index = uiStateStack.indexOf(closeAccountManagerModal);
    if (index > -1) uiStateStack.splice(index, 1);
}


function showAddEditAccountModal(accountId = null) {
    editingAccountId = accountId;
    const title = el.addEditAccountTitle.querySelector('.modal-title-text');
    const saveBtn = el.addEditAccountSaveBtn;

    el.addEditAccountError.style.display = 'none';
    saveBtn.disabled = true;

    if (accountId) { 
        
        const account = state.accounts.find(acc => acc.id === accountId);
        title.textContent = '编辑账号'; 
        el.accountNameInput.style.display = 'block'; 
        el.accountNameInput.value = account.name;
        el.accountTokenInput.value = account.token; 

    } else { 
        
        title.textContent = '添加新账号';
        el.accountNameInput.style.display = 'none'; 
        el.accountNameInput.value = '';
        el.accountTokenInput.value = '';
    }
    
    el.addEditAccountModal.classList.remove('hidden');
    uiStateStack.push(closeAddEditAccountModal);
}

function closeAddEditAccountModal() {
    el.addEditAccountModal.classList.add('hidden');
    const index = uiStateStack.indexOf(closeAddEditAccountModal);
    if (index > -1) uiStateStack.splice(index, 1);
}


async function handleSaveAccount() {
    const name = el.accountNameInput.value.trim(); 
    const token = el.accountTokenInput.value.trim();
    const saveBtn = el.addEditAccountSaveBtn;
    const spinner = saveBtn.querySelector('i');
    
    saveBtn.disabled = true;
    spinner.classList.remove('hidden');
    el.addEditAccountError.style.display = 'none';

    try {
        if (editingAccountId) {
            
            const account = state.accounts.find(acc => acc.id === editingAccountId);
            
            if (token !== account.token) {
                
                const res = await fetch('https://api.github.com/user', { headers: { Authorization: `token ${token}` } });
                if (!res.ok) throw new Error('新令牌无效或已过期');
                
                
                account.token = token;
            }
            
            account.name = name; 
            saveAccounts();

            if (state.activeAccountId === editingAccountId) {
                initializeActiveToken();
            }

            renderAccountList();
            closeAddEditAccountModal();
            showToast('账号信息已更新');

        } else {
            
            const res = await fetch('https://api.github.com/user', { headers: { Authorization: `token ${token}` } });
            if (!res.ok) throw new Error('令牌无效或已过期');
            
            const userData = await res.json(); 
            const githubUsername = userData.login; 

            const newAccount = {
                id: `gh_${Date.now()}`,
                name: githubUsername, 
                token: token
            };
            state.accounts.push(newAccount);
            saveAccounts();
            renderAccountList();
            closeAddEditAccountModal();
            showToast(`账号 "${githubUsername}" 添加成功`);
        }
    } catch (error) {
        el.addEditAccountError.textContent = error.message;
        el.addEditAccountError.style.display = 'block';
    } finally {
        saveBtn.disabled = false;
        spinner.classList.add('hidden');
    }
}

function getFileIcon(filename) {
    const ext = filename.split('.').pop().toLowerCase();
    const icons = {
    js: 'fa-solid fa-code', html: 'fa-brands fa-html5', css: 'fa-brands fa-css3', php: 'fa-regular fa-file-code', py: 'fa-regular fa-file-code',
    java: 'fa-regular fa-file-code', rb: 'fa-regular fa-file-code', cpp: 'fa-regular fa-file-code', c: 'fa-regular fa-file-code',
    cs: 'fa-regular fa-file-code', swift: 'fa-regular fa-file-code', go: 'fa-regular fa-file-code', xml: 'fa-regular fa-file-code',
    json: 'fa-regular fa-file-code', yml: 'fa-regular fa-file-code', yaml: 'fa-regular fa-file-code', sql: 'fa-solid fa-database',
    csv: 'fa-regular fa-file-excel', ini: 'fa-solid fa-gear', conf: 'fa-solid fa-gear', log: 'fa-regular fa-file-lines',
    md: 'fa-regular fa-file-lines', txt: 'fa-regular fa-file-lines', rtf: 'fa-regular fa-file-word', pdf: 'fa-regular fa-file-pdf',
    doc: 'fa-regular fa-file-word', docx: 'fa-regular fa-file-word', xls: 'fa-regular fa-file-excel', xlsx: 'fa-regular fa-file-excel',
    ppt: 'fa-regular fa-file-powerpoint', pptx: 'fa-regular fa-file-powerpoint', png: 'fa-regular fa-file-image',
    jpg: 'fa-regular fa-file-image', jpeg: 'fa-regular fa-file-image', gif: 'fa-regular fa-file-image', svg: 'fa-regular fa-file-image',
    bmp: 'fa-regular fa-file-image', ico: 'fa-regular fa-file-image', webp: 'fa-regular fa-file-image', mp3: 'fa-regular fa-file-audio',
    wav: 'fa-regular fa-file-audio', ogg: 'fa-regular fa-file-audio', flac: 'fa-regular fa-file-audio', m4a: 'fa-regular fa-file-audio',
    mp4: 'fa-regular fa-file-video', webm: 'fa-regular fa-file-video', mov: 'fa-regular fa-file-video', mkv: 'fa-regular fa-file-video',
    avi: 'fa-regular fa-file-video', flv: 'fa-regular fa-file-video', zip: 'fa-regular fa-file-zipper', rar: 'fa-regular fa-file-zipper',
    '7z': 'fa-regular fa-file-zipper', tar: 'fa-regular fa-file-zipper', gz: 'fa-regular fa-file-zipper', git: 'fa-brands fa-git-alt',
    apk: 'fa-brands fa-android', exe: 'fa-solid fa-gears', dmg: 'fa-brands fa-apple', ttf: 'fa-solid fa-font', otf: 'fa-solid fa-font',
    woff: 'fa-solid fa-font', woff2: 'fa-solid fa-font'
}
    return icons[ext] || 'fa-file';
}


function getFileCategory(file) {
    if (file.type === 'dir') {
        return 'folder';
    }
    const ext = file.name.split('.').pop().toLowerCase();
    if (IMAGE_EXTS.includes(ext)) {
        return 'image';
    }
    if (VIDEO_EXTS.includes(ext)) {
        return 'video';
    }
    if (AUDIO_EXTS.includes(ext)) {
        return 'audio';
    }
    const archiveExts = ['zip', 'rar', '7z', 'tar', 'gz'];
    if (archiveExts.includes(ext)) {
        return 'archive';
    }
    const docExts = ['pdf', 'doc', 'docx', 'xls', 'xlsx', 'ppt', 'pptx', 'txt', 'md'];
    if (docExts.includes(ext)) {
        return 'document';
    }
    return 'z_other';
}

function formatSize(bytes) {
    if (!bytes && bytes !== 0) return '';
    const k = 1024;
    const sizes = ['B', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.max(0, Math.log(bytes || 1) / Math.log(k)));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

function formatRelativeTime(date) {
    const diffMs = new Date() - date;
    const diffMins = Math.floor(diffMs / 60000);
    const diffHours = Math.floor(diffMins / 60);
    const diffDays = Math.floor(diffHours / 24);
    if (diffMins < 1) return '刚刚';
    if (diffMins < 60) return `${diffMins}分钟前`;
    if (diffHours < 24) return `${diffHours}小时前`;
    if (diffDays < 30) return `${diffDays}天前`;
    return date.toLocaleDateString();
}

function escapeHtml(unsafe) {
    return unsafe.replace(/&/g, "&amp;").replace(/</g, "&lt;")
        .replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
}

function getDomainFromUrl(url) {
    try {
        const urlObj = new URL(url.startsWith('http') ? url : `https://${url}`);
        return urlObj.hostname;
    } catch (e) {
        return '';
    }
}

function getProxiedUrl(originalUrl) {
    if (!state.proxyGlobalEnable || state.proxies.length === 0 || state.activeProxyIndex === -1) {
        return originalUrl;
    }
    const activeProxy = state.proxies[state.activeProxyIndex];
    if (!activeProxy || !activeProxy.url || activeProxy.status === 'fail' || !activeProxy.type) {
        return originalUrl;
    }
    const isRawGitHubUserContent = originalUrl.startsWith('https://raw.githubusercontent.com/');
    if (!isRawGitHubUserContent) {
        return originalUrl;
    }
    let proxiedUrl = originalUrl;
    const proxyInputUrl = (activeProxy.url || '').trim();
    const proxyDomain = getDomainFromUrl(proxyInputUrl);
    if (activeProxy.type === 'prefix') {
        let base = proxyInputUrl;
        if (!base.endsWith('/')) {
            base += '/';
        }
        proxiedUrl = base + originalUrl;
    } else if (activeProxy.type === 'raw_domain_replace') {
        proxiedUrl = originalUrl.replace(/^(https?:\/\/raw\.)githubusercontent\.com(\/.*)$/i, `$1${proxyDomain}$2`);
        if (!proxiedUrl.startsWith('http')) {
            proxiedUrl = 'https://' + proxiedUrl;
        }
    } else {
        proxiedUrl = originalUrl;
    }
    return proxiedUrl;
}

function applyFiltersAndSort() {
    let arr = Array.isArray(state.files) ? [...state.files] : [];
    const q = (state.searchQuery || '').toLowerCase();
    if (q) {
        arr = arr.filter(f => (f.name || '').toLowerCase().includes(q));
    }

    const directorySorter = (a, b) => {
        if (a.type === b.type) return 0;
        if (state.directorySortPriority === 'files_first') {
            return a.type === 'file' ? -1 : 1;
        }
        return a.type === 'dir' ? -1 : 1;
    };

    // 定义类型权重，数字越小越靠前
    const getTypeWeight = (file) => {
        const cat = getFileCategory(file);
        const weights = {
            'image': 1,
            'video': 2,
            'audio': 3,
            'document': 4,
            'archive': 5,
            'folder': 0, // 文件夹权重通常由 directorySorter 处理，这里作为后备
            'z_other': 6
        };
        return weights[cat] || 99;
    };

    const by = state.sortBy;
    
    const sorters = {
        name_asc: (a, b) => {
            const dirCompare = directorySorter(a, b);
            return dirCompare !== 0 ? dirCompare : a.name.localeCompare(b.name);
        },
        name_desc: (a, b) => {
            const dirCompare = directorySorter(a, b);
            return dirCompare !== 0 ? dirCompare : b.name.localeCompare(a.name);
        },
        size_desc: (a, b) => {
            const dirCompare = directorySorter(a, b);
            if (dirCompare !== 0) return dirCompare;
            return (b.size || 0) - (a.size || 0);
        },
        size_asc: (a, b) => {
            const dirCompare = directorySorter(a, b);
            if (dirCompare !== 0) return dirCompare;
            return (a.size || 0) - (b.size || 0);
        },
        // 核心修改：类型优先，同类型按时间倒序（新的在上方），无时间则按名称
        type_name_asc: (a, b) => {
            const dirCompare = directorySorter(a, b);
            if (dirCompare !== 0) return dirCompare;

            // 1. 比较类型权重
            const weightA = getTypeWeight(a);
            const weightB = getTypeWeight(b);
            if (weightA !== weightB) {
                return weightA - weightB;
            }

            // 2. 如果有时间信息，新的在上方 (时间倒序)
            if (a.last_modified && b.last_modified) {
                const dateA = new Date(a.last_modified);
                const dateB = new Date(b.last_modified);
                if (dateA.getTime() !== dateB.getTime()) {
                    return dateB - dateA;
                }
            }

            // 3. 最后按名称排序
            return a.name.localeCompare(b.name);
        }
    };

    (sorters[by] || sorters.type_name_asc) && arr.sort(sorters[by]);
    state.displayFiles = arr;
}




let editingAccountId = null; 

function saveAccounts() {
    localStorage.setItem('github_accounts', JSON.stringify(state.accounts));
}

function setActiveAccount(accountId) {
    state.activeAccountId = accountId;
    localStorage.setItem('active_github_account_id', accountId);
    initializeActiveToken(); 
}

function renderAccountList() {
    const container = el.accountListContainer;
    container.innerHTML = '';

    if (state.accounts.length === 0) {
        el.accountListEmpty.classList.remove('hidden');
        return;
    }
    el.accountListEmpty.classList.add('hidden');

    state.accounts.forEach(account => {
        const item = document.createElement('div');
        item.className = 'account-item';
        item.dataset.id = account.id;
        if (account.id === state.activeAccountId) {
            item.classList.add('active');
        }

        item.innerHTML = `
            <span class="account-name">${escapeHtml(account.name)}</span>
            <div class="account-actions">
                <button class="btn-icon-sm edit-account-btn" title="编辑名称"><i class="fa fa-pencil"></i></button>
                <button class="btn-icon-sm delete-account-btn danger" title="删除账号"><i class="fa-regular fa-trash-can"></i></button>
            </div>
        `;

        
        item.addEventListener('click', () => {
    if (el.app.classList.contains('hidden')) {
        const selectedToken = state.accounts.find(acc => acc.id === account.id).token;
        if (selectedToken) {
            el.tokenInput.value = selectedToken;
            showToast(`已选择账号: ${account.name}，正在自动登录...`);
            closeAccountManagerModal();
            el.authBtn.click();
        }
    } else {
        if (account.id === state.activeAccountId) {
            closeAccountManagerModal();
            return;
        }
        switchAccount(account.id);
    }
});
        
        item.querySelector('.edit-account-btn').addEventListener('click', (e) => {
            e.stopPropagation();
            showAddEditAccountModal(account.id);
        });

        item.querySelector('.delete-account-btn').addEventListener('click', (e) => {
            e.stopPropagation();
            showDeleteModal(null, false, '确认删除账号', `确定要删除账号 "${escapeHtml(account.name)}" 吗？`, async () => {
                state.accounts = state.accounts.filter(acc => acc.id !== account.id);
                if (state.activeAccountId === account.id) {
                    setActiveAccount(null); 
                }
                saveAccounts();
                renderAccountList();
                showToast('账号已删除');
            });
        });

        container.appendChild(item);
    });
}

async function switchAccount(accountId) {
    closeAccountManagerModal();
    hideMainMenuPopup();
    el.mainLoader.classList.remove('hidden');
    showToast('正在切换账号...');

    setActiveAccount(accountId);

    state.currentRepo = null;
    state.repos = [];
    state.starredRepos = [];
    state.myRepos = [];
    state.fileCache.clear();
    state.currentView = 'own_repos';

    const viewStarredBtn = document.getElementById('viewStarredBtn');
    if (viewStarredBtn) {
        const icon = viewStarredBtn.querySelector('i');
        icon.className = 'fa-regular fa-star';
        viewStarredBtn.title = '查看星标仓库';
    }

    try {
        state.shouldAnimateList = true;
        
        await Promise.all([
            fetchUserInfo(),
            fetchRepos(true, false),
            fetchStarredRepos(true, false)
        ]);
        
        state.myRepos = [...state.repos];
        showRepoListView();
        renderRepoList();

        const res = await fetch('https://api.github.com/user', { headers: { Authorization: `token ${state.token}` } });
        if (res.ok) {
            const scopesHeader = res.headers.get('x-oauth-scopes') || '';
            if (!scopesHeader.includes('repo')) {
                showToast('此令牌无权限，大部分功能将无法使用。', 'error', 5000);
            }
        }

    } catch (error) {
        showToast(`切换失败: ${error.message}`, 'error');
        showAuth();
    } finally {
        el.mainLoader.classList.add('hidden');
        renderPublishManagerLists();
    }
}

function updateFileListViewMode() {
    if (!el.fileList) return;
    if (state.viewMode === 'grid') {
        el.fileList.classList.add('grid');
        el.viewToggleBtn && el.viewToggleBtn.classList.add('active');
        if (el.viewToggleBtn) {
            el.viewToggleBtn.title = '切换为列表视图';
            el.viewToggleBtn.innerHTML = '<i class="fa fa-align-justify"></i>';
        }
    } else {
        el.fileList.classList.remove('grid');
        el.viewToggleBtn && el.viewToggleBtn.classList.remove('active');
        if (el.viewToggleBtn) {
            el.viewToggleBtn.title = '切换为网格视图';
            el.viewToggleBtn.innerHTML = '<i class="fa-regular fa-chart-bar"></i>';
        }
    }
}



function updateAllProxySwitchUI() {
    const isEnabled = !!state.proxyGlobalEnable;
    const currentProxy = state.proxies[state.activeProxyIndex];
    const title = isEnabled && currentProxy ? `代理已开启 (${currentProxy.url})` : '代理已关闭';
    if (el.proxyQuickToggle) {
        el.proxyQuickToggle.classList.toggle('active', isEnabled);
        el.proxyQuickToggle.title = title;
    }
    if (el.proxyGlobalEnableToggle) {
        el.proxyGlobalEnableToggle.checked = isEnabled;
        const label = el.proxyGlobalEnableToggle.parentElement;
        if (label) {
            label.title = isEnabled ? '点击关闭全局代理' : '点击开启全局代理';
        }
    }
}

function updateProxyUI() {
    updateAllProxySwitchUI();
}

function preloadRepoImages() {
    if (!state.repoTreeCache || !state.currentRepo || !state.currentBranch) return;
    
    if (!state.loadedImageMap) state.loadedImageMap = new Map();

    const [owner, repo] = state.currentRepo.split('/');
    const currentBranchRef = state.currentBranch;
    
    const images = state.repoTreeCache.filter(item => {
        if (item.type !== 'blob') return false;
        const ext = item.path.split('.').pop().toLowerCase();
        return IMAGE_EXTS.includes(ext);
    });

    if (images.length === 0) return;

    let index = 0;
    const batchSize = 6;

    const runPreload = () => {
        if (state.currentRepo !== `${owner}/${repo}`) return;

        for (let i = 0; i < batchSize && index < images.length; i++) {
            const item = images[index++];
            
            // 如果这个路径已经在 Map 里了（说明之前某个代理已经加载成功），跳过预加载
            if (state.loadedImageMap.has(item.path)) continue;

            const encodedPath = item.path.split('/').map(p => encodeURIComponent(p)).join('/');
            const rawUrl = `https://raw.githubusercontent.com/${owner}/${repo}/${currentBranchRef}/${encodedPath}`;
            
            // 获取最新代理URL
            const proxiedUrl = getProxiedUrl(rawUrl);
            
            const img = new Image();
            img.onload = () => {
                // 加载成功，存入 Map
                state.loadedImageMap.set(item.path, proxiedUrl);
                
                // 尝试刷新UI上的 loading 状态
                const thumbContainer = document.querySelector(`.file-item[data-file-path="${CSS.escape(item.path)}"] .file-thumbnail-container.loading`);
                if (thumbContainer) {
                    loadThumbnailImage(thumbContainer);
                }
            };
            img.src = proxiedUrl;
        }

        if (index < images.length) {
            if ('requestIdleCallback' in window) {
                requestIdleCallback(runPreload);
            } else {
                setTimeout(runPreload, 200);
            }
        }
    };
    runPreload();
}

function setActiveProxy(index, showNotification = true) {
    if (index < 0 || index >= state.proxies.length) return;
    
    const previousIndex = state.activeProxyIndex;
    state.proxyGlobalEnable = true;
    state.activeProxyIndex = index;
    
    saveProxyConfig();
    renderProxyList();
    
    if (showNotification && previousIndex !== index) {
        showToast(`已切换全局代理`);
    }

    if (state.currentRepo) {
        state.shouldAnimateList = false;
        renderFileList();
        preloadRepoImages();
    }
}

async function setProxyGlobalState(isEnabled, shouldRefreshFiles = false) {
    if (state.proxyGlobalEnable === isEnabled) {
        return;
    }
    state.proxyGlobalEnable = isEnabled;
    localStorage.setItem('proxy_global_enable', JSON.stringify(isEnabled));
    updateAllProxySwitchUI();
    showToast(isEnabled ? '全局代理已开启' : '全局代理已关闭');
    
    if (shouldRefreshFiles && state.currentRepo && !el.fileList.classList.contains('hidden')) {
        renderFileList();
        if (isEnabled) {
            preloadRepoImages();
        }
    }
}

function toggleView(showRepoList) {
    const viewStarredBtn = document.getElementById('viewStarredBtn');
    const globalSearchToggleBtn = document.getElementById('globalSearchToggleBtn');
    const globalSearchContainer = document.getElementById('globalSearchContainer');

    if (showRepoList) {
        el.main.classList.remove('has-toolbar');
        el.repoList.classList.remove('hidden');
        el.fileList.classList.add('hidden');
        el.toolbar.classList.add('hidden');
        el.pathNavContainer.classList.add('hidden');
        el.branchSwitcherContainer.classList.add('hidden');
        
        if (viewStarredBtn) viewStarredBtn.classList.remove('hidden');
    } else {
        el.main.classList.add('has-toolbar');
        el.repoList.classList.add('hidden');
        el.fileList.classList.remove('hidden');
        el.toolbar.classList.remove('hidden');
        el.pathNavContainer.classList.remove('hidden');
        el.branchSwitcherContainer.classList.remove('hidden');
        
        updateFileListViewMode();
        if (viewStarredBtn) viewStarredBtn.classList.remove('hidden');
        
        if (globalSearchToggleBtn && globalSearchToggleBtn.classList.contains('active')) {
            globalSearchToggleBtn.classList.remove('active');
            globalSearchContainer.classList.add('hidden');
        }
    }
}
function showAuth() {
    el.authScreen.classList.remove('hidden');
    el.app.classList.add('hidden');
    document.documentElement.classList.remove('app-visible-loading');
    document.documentElement.classList.add('auth-visible-loading');
}

function showApp() {
    el.authScreen.classList.add('hidden');
    el.app.classList.remove('hidden');
    document.documentElement.classList.remove('auth-visible-loading');
    document.documentElement.classList.add('app-visible-loading');
    document.body.classList.remove('app-visible-loading');
}

function showEditorScaleHintOnce() {
    const hintKey = 'editor_scale_hint_shown';
    try {
        if (localStorage.getItem(hintKey)) {
            return;
        }
        const hintElement = el.editorScaleHint;
        if (!hintElement) {
            return;
        }
        
        hintElement.classList.remove('hidden');
        
        setTimeout(() => {
            hintElement.style.transition = 'opacity 0.5s ease-out';
            hintElement.style.opacity = '0';
            setTimeout(() => {
                hintElement.classList.add('hidden');
                hintElement.style.opacity = '';
                hintElement.style.transition = '';
            }, 500);
        }, 3000);

        localStorage.setItem(hintKey, 'true');
    } catch (e) {
        console.error("Could not show editor scale hint:", e);
    }
}


function showToast(message, type = 'info', duration = 1800) {
    toastQueue.push({ message, type, duration });
    processToastQueue();
}

function processToastQueue() {
    if (isToastVisible || toastQueue.length === 0) {
        return;
    }
    isToastVisible = true;
    const { message, type, duration } = toastQueue.shift();
    
    const toastEl = document.getElementById('toast');
    const messageEl = document.getElementById('toastMessage');

    toastEl.className = '';

    messageEl.innerHTML = message.replace(/\n/g, '<br>');
    toastEl.classList.add(`toast-${type}`);

    toastEl.classList.add('show');

    setTimeout(() => {
        toastEl.classList.remove('show');
        setTimeout(() => {
            isToastVisible = false;
            processToastQueue();
        }, 400);
    }, duration);
}

function showSaveNotification() {
    el.saveNotification.classList.add('show');
    setTimeout(() => el.saveNotification.classList.remove('show'), 3000);
}

async function fetchUserInfo() {
    try {
        const res = await fetch('https://api.github.com/user', {
            headers: {
                Authorization: `token ${state.token}`,
                'User-Agent': 'Mozilla/5.0'
            }
        });
        if (res.ok) {
            state.user = await res.json();
            updateUserUI();
        }
    } catch (e) {
        console.error("Failed to fetch user info", e);
    }
}



function loadAndCacheUserAvatar() {
    const cacheKey = 'user_avatar_cache';
    const CACHE_DURATION = 5 * 60 * 1000;
    const avatarUrl = state.user.avatar_url;
    if (!avatarUrl) return;

    let cachedData = null;
    try {
        cachedData = JSON.parse(localStorage.getItem(cacheKey));
    } catch (e) {}

    if (cachedData && cachedData.url === avatarUrl && (Date.now() - cachedData.timestamp < CACHE_DURATION)) {
        el.userAvatar.src = cachedData.url;
        el.userAvatar.classList.remove('hidden');
        el.userAvatarPlaceholder.classList.add('hidden');
        return;
    }

    const tempImg = new Image();
    tempImg.src = avatarUrl;
    tempImg.onload = () => {
        el.userAvatar.src = avatarUrl;
        el.userAvatar.classList.remove('hidden');
        el.userAvatarPlaceholder.classList.add('hidden');
        try {
            localStorage.setItem(cacheKey, JSON.stringify({
                url: avatarUrl,
                timestamp: Date.now()
            }));
        } catch (e) {
            console.error("Failed to update user avatar cache.", e);
        }
    };
    tempImg.onerror = () => {
        console.error("Failed to load user avatar from network.");
    };
}

function updateUserUI() {
    el.userName.textContent = state.user ? state.user.login : 'User';

    if (state.localAvatar) {
        el.userAvatar.src = state.localAvatar;
        el.userAvatar.classList.remove('hidden');
        el.userAvatarPlaceholder.classList.add('hidden');
        return;
    }

    el.userAvatar.classList.add('hidden');
    el.userAvatarPlaceholder.classList.remove('hidden');

    if (state.user && state.user.avatar_url) {
        loadAndCacheUserAvatar();
    }
}


async function fetchRepos(forceRefresh = false, updateView = true) {
    const cacheKey = 'cached_repos';
    const cacheTimeKey = 'repos_cache_time';
    const CACHE_LIFETIME = 5 * 60 * 1000;

    if (!forceRefresh && localStorage.getItem(cacheKey) && (Date.now() - parseInt(localStorage.getItem(cacheTimeKey)) < CACHE_LIFETIME)) {
        try {
            state.repos = JSON.parse(localStorage.getItem(cacheKey));
            state.myRepos = [...state.repos];
            if (updateView) {
                renderRepoList(state.repos);
                showRepoListView();
            }
            return;
        } catch (e) {}
    }

    try {
        const res = await fetch('https://api.github.com/user/repos?timestamp=' + Date.now(), {
            headers: { Authorization: `token ${state.token}`, 'User-Agent': 'Mozilla/5.0' },
            cache: 'no-store'
        });

        if (!res.ok) {
            let errorMsg = `获取仓库失败 (HTTP ${res.status})`;
            if (res.status === 401) errorMsg = '令牌无效或已过期，请重新登录。';
            if (res.status === 403) errorMsg = 'API请求频率超限，请稍后再试。';
            throw new Error(errorMsg);
        }

        const repos = await res.json();
        state.repos = repos;
        state.myRepos = [...state.repos];

        await autoClearCacheIfNeeded();
        const reposString = JSON.stringify(state.repos);
        if (reposString.length < 2 * 1024 * 1024) {
            localStorage.setItem(cacheKey, reposString);
            localStorage.setItem(cacheTimeKey, Date.now().toString());
        } else {
            localStorage.removeItem(cacheKey);
        }
        
        if (updateView) {
            renderRepoList();
            showRepoListView();
        }
    } catch (err) {
        if (updateView) showToast(`加载仓库失败: ${err.message}`);
        state.repos = [];
        if (updateView) {
            renderRepoList();
            showRepoListView();
        }
    }
}





async function fetchStarredRepos(forceRefresh = false, updateView = true, showMainLoader = true) {
    const cacheKey = 'cached_starred_repos';
    const cacheTimeKey = 'starred_repos_cache_time';
    const CACHE_LIFETIME = 5 * 60 * 1000;

    if (!forceRefresh && localStorage.getItem(cacheKey) && (Date.now() - parseInt(localStorage.getItem(cacheTimeKey)) < CACHE_LIFETIME)) {
        try {
            state.starredRepos = JSON.parse(localStorage.getItem(cacheKey));
            if (updateView) {
                renderRepoList(state.starredRepos);
            }
            return;
        } catch (e) {
            console.error('星标仓库缓存解析失败:', e);
        }
    }

    // --- 核心修改：只有在需要时才显示主加载动画 ---
    if (updateView && showMainLoader) {
        el.repoList.innerHTML = '<div class="loading-spinner"><div class="spinner"></div></div>';
    }

    try {
        const res = await fetch('https://api.github.com/user/starred', {
            headers: { Authorization: `token ${state.token}`, 'User-Agent': 'Mozilla/5.0' },
            cache: 'no-store'
        });

        if (!res.ok) {
            throw new Error(`获取星标仓库失败 (HTTP ${res.status})`);
        }
        
        const repos = await res.json();
        state.starredRepos = repos;
        const reposToCache = state.starredRepos.map(repo => ({
    id: repo.id,
    full_name: repo.full_name,
    name: repo.name,
    owner: {
        login: repo.owner.login,
        avatar_url: repo.owner.avatar_url
    },
    description: repo.description,
    private: repo.private,
    size: repo.size,
    updated_at: repo.updated_at,
    default_branch: repo.default_branch,
    has_pages: repo.has_pages,
    html_url: repo.html_url
}));

try {
    localStorage.setItem(cacheKey, JSON.stringify(reposToCache));
} catch (e) {
    console.error("即使瘦身处理后，缓存星标仓库时仍然超出配额:", e);
    showToast('您关注的仓库数量过多，缓存功能已禁用以保证应用运行。', 'error', 5000);
    localStorage.removeItem(cacheKey);
}
        localStorage.setItem(cacheTimeKey, Date.now().toString());

        if (updateView) {
            renderRepoList(state.starredRepos);
        }
    } catch (err) {
        if (updateView) {
            showToast(err.message, 'error');
            el.repoList.innerHTML = `<div class="empty-state"><i class="fa fa-exclamation-circle"></i><p>${err.message}</p></div>`;
        }
    }
}



function invalidateCacheForPathAndParents(path) {
    if (typeof path !== 'string') return;
    let currentPath = path;
    while (true) {
        const cacheKey = `${state.currentRepo}:${state.currentBranch}:${currentPath}`;
        state.fileCache.delete(cacheKey);
        if (currentPath === '') {
            break;
        }
        let tempPath = currentPath.endsWith('/') ? currentPath.slice(0, -1) : currentPath;
        let lastSlashIndex = tempPath.lastIndexOf('/');
        if (lastSlashIndex === -1) {
            currentPath = '';
        } else {
            currentPath = tempPath.substring(0, lastSlashIndex) + '/';
        }
    }
}

function renderRepoList(reposSource) {
    if (reposSource === undefined) {
        reposSource = state.currentView === 'starred_repos' ? state.starredRepos : 
                      state.currentView === 'other_user_repos' ? state.currentRepoList : state.repos;
    }

    const pinnedRepoIds = JSON.parse(localStorage.getItem('pinned_repos') || '[]');
    let allRepos = [...(reposSource || [])];

    const pinnedRepos = allRepos.filter(r => pinnedRepoIds.includes(r.id)).sort((a, b) => new Date(b.updated_at) - new Date(a.updated_at));
    const unpinnedRepos = allRepos.filter(r => !pinnedRepoIds.includes(r.id)).sort((a, b) => new Date(b.updated_at) - new Date(a.updated_at));
    allRepos = [...pinnedRepos, ...unpinnedRepos];
    state.currentRepoList = allRepos;

    let currentPage = 1;
    switch (state.currentView) {
        case 'own_repos': currentPage = state.myReposPage; break;
        case 'starred_repos': currentPage = state.starredReposPage; break;
        case 'other_user_repos': currentPage = state.userReposPage; break;
        case 'public_search_results': currentPage = state.publicSearchPage; break;
    }

    let reposToRender;
    if (state.currentView === 'public_search_results') {
        reposToRender = allRepos;
    } else {
        const startIndex = (currentPage - 1) * state.REPOS_PER_PAGE;
        const endIndex = startIndex + state.REPOS_PER_PAGE;
        reposToRender = allRepos.slice(startIndex, endIndex);
    }

    const container = el.repoList;
    if (reposToRender.length === 0) {
        const message = state.currentView === 'starred_repos' ? '当前还未关注仓库' : '没有找到仓库';
        container.innerHTML = `<div class="empty-state"><i class="fa-brands fa-github"></i><p>${message}</p></div>`;
        return;
    }

    const starredRepoFullNames = new Set((state.starredRepos || []).map(r => r.full_name));
    const newNodes = reposToRender.map((repo, index) => {
        const repoId = String(repo.id);
        const displayName = (state.currentView === 'own_repos' || state.currentView === 'other_user_repos') ? repo.name : repo.full_name;
        
        let iconContainerClass = 'file-icon';
        let iconDataAttr = '';
        let avatarUrl = '';
        const ownerLogin = repo.owner.login;
        const cacheKey = `avatar_cache_${ownerLogin}`;
        const CACHE_DURATION = 48 * 60 * 60 * 1000;
        try {
            const cachedItem = localStorage.getItem(cacheKey);
            if (cachedItem) {
                const { timestamp } = JSON.parse(cachedItem);
                if (Date.now() - timestamp < CACHE_DURATION) {
                    iconContainerClass += ' has-cached-avatar';
                }
            }
        } catch (e) {}

        if (state.currentView === 'own_repos' && state.user && (state.user.avatar_url || state.localAvatar)) {
            iconContainerClass += ' is-user-avatar-icon';
            avatarUrl = state.localAvatar || state.user.avatar_url;
        } else if (state.currentView !== 'own_repos' && repo.owner && repo.owner.avatar_url) {
            avatarUrl = repo.owner.avatar_url;
        }
        
        if (avatarUrl) {
            iconDataAttr = `data-avatar-url="${escapeHtml(avatarUrl)}"`;
        }

        const iconHTML = `<div class="${iconContainerClass}" ${iconDataAttr}><i class="fa-brands fa-github"></i></div>`;

        let starButtonHTML = '';
        let releasesButtonHTML = '';
        const isNotOwnRepo = state.currentView !== 'own_repos' && state.user && repo.owner.login !== state.user.login;

        if (isNotOwnRepo) {
            releasesButtonHTML = `<button class="star-text-btn js-view-releases-btn" title="查看版本" data-repo-fullname="${escapeHtml(repo.full_name)}">版本</button>`;
            
            const isStarred = starredRepoFullNames.has(repo.full_name);
            const buttonText = isStarred ? '取消关注' : '关注';
            const buttonClass = isStarred ? 'star-text-btn starred' : 'star-text-btn';
            starButtonHTML = `<button class="${buttonClass}" data-repo-fullname="${escapeHtml(repo.full_name)}">${buttonText}</button>`;
        }

        const item = document.createElement('div');
        item.className = 'file-item';
        
        if (pinnedRepoIds.includes(repo.id)) {
            item.classList.add('pinned-repo');
        }

        item.dataset.repoId = repoId;
        item.dataset.owner = repo.owner.login;
        
        item.innerHTML = `
            ${iconHTML}
            <div class="file-info">
                <div class="repo-name-header">
                    <p class="file-name">${displayName}</p>
                    <div class="repo-item-actions">
                        ${releasesButtonHTML}
                        ${starButtonHTML}
                    </div>
                </div>
                <p class="file-meta">
                    ${repo.private ? '私有仓库' : '公开仓库'} ${repo.size || repo.updated_at ? ' · ' : ''}
                    ${repo.size ? formatSize(repo.size * 1024) : ''}
                    ${repo.size && repo.updated_at ? ' · ' : ''}
                    ${formatRelativeTime(new Date(repo.updated_at))}
                </p>
                <p class="file-meta repo-description">${repo.description || ''}</p>
            </div>`;
            
        let pressTimer = null;
        let isLongPress = false;
        item.addEventListener('touchstart', (e) => { isLongPress = false; pressTimer = setTimeout(() => { isLongPress = true; }, 500); }, { passive: true });
        item.addEventListener('touchmove', () => { clearTimeout(pressTimer); });
        item.addEventListener('touchend', () => { clearTimeout(pressTimer); });
        item.addEventListener('click', async (e) => {
            if (e.target.closest('button')) return; if (isLongPress) return;
            state.repoListScrollPosition = el.main.scrollTop;
            state.shouldAnimateList = true; state.viewingOwner = repo.owner.login;
            try {
                const lastBranch = localStorage.getItem(`last_branch_${repo.full_name}`);
                navigateToRepo(repo, lastBranch || repo.default_branch);
            } catch (error) { showToast('加载仓库失败'); console.error(error); showRepoListView(); }
        });
        item.addEventListener('contextmenu', (e) => { e.preventDefault(); clearTimeout(pressTimer); isLongPress = true; state.selectedRepo = repo; showRepoContextMenu(e, repo); });
        
        if (state.shouldAnimateList) {
            item.classList.add('file-item-enter');
            item.style.animationDelay = `${index * 30}ms`;
        } else {
            item.style.opacity = 1;
        }

        return item;
    });

    container.innerHTML = '';
    newNodes.forEach(node => container.appendChild(node));
    setTimeout(processRepoAvatars, 0);
    if (state.shouldAnimateList) {
        state.shouldAnimateList = false;
    }
    updatePaginationUI();
}





function handleNextRepoPage() {
    let pageStateKey, repoSource;

    switch (state.currentView) {
        case 'own_repos':
            pageStateKey = 'myReposPage';
            repoSource = state.repos;
            break;
        case 'starred_repos':
            pageStateKey = 'starredReposPage';
            repoSource = state.starredRepos;
            break;
        case 'other_user_repos':
            pageStateKey = 'userReposPage';
            repoSource = state.currentRepoList;
            break;
        default:
            return;
    }

    if (!repoSource || repoSource.length === 0) return;

    const totalPages = Math.ceil(repoSource.length / state.REPOS_PER_PAGE);
    let currentPage = state[pageStateKey];

    if (totalPages <= 1) {
        showToast('仓库列表没有超过20个，没有下一页。');
        return;
    }

    if (currentPage >= totalPages) {
        showToast('已经是最后一页了');
        return;
    }

    currentPage++;
    state[pageStateKey] = currentPage;
    renderRepoList();
    updatePaginationUI();
}



function handlePrevRepoPage() {
    let pageStateKey, repoSource;

    switch (state.currentView) {
        case 'own_repos':
            pageStateKey = 'myReposPage';
            repoSource = state.repos;
            break;
        case 'starred_repos':
            pageStateKey = 'starredReposPage';
            repoSource = state.starredRepos;
            break;
        case 'other_user_repos':
            pageStateKey = 'userReposPage';
            repoSource = state.currentRepoList;
            break;
        default:
            return;
    }

    if (!repoSource || repoSource.length === 0) return;

    const totalPages = Math.ceil(repoSource.length / state.REPOS_PER_PAGE);
    let currentPage = state[pageStateKey];

    if (totalPages <= 1) {
        showToast('仓库列表没有超过20个，没有上一页。');
        return;
    }
    
    if (currentPage <= 1) {
        showToast('已经是第一页了');
        return;
    }

    currentPage--;
    state[pageStateKey] = currentPage;
    renderRepoList();
    updatePaginationUI();
}

async function processRepoAvatars() {
    const iconsToProcess = document.querySelectorAll('#repoList .file-icon[data-avatar-url]');
    
    for (const iconContainer of iconsToProcess) {
        const url = iconContainer.dataset.avatarUrl;
        if (!url) continue;
        
        const ownerLogin = iconContainer.closest('.file-item')?.dataset.owner;
        if (!ownerLogin) continue;
        
        const cacheKey = `avatar_${ownerLogin}`;
        
        try {
            const cachedBlob = await getAvatarFromDB(cacheKey, ownerLogin);
            let imageUrl;

            if (cachedBlob) {
                imageUrl = URL.createObjectURL(cachedBlob);
            } else {
                const response = await fetch(url);
                const blob = await response.blob();
                await saveAvatarToDB(cacheKey, blob);
                imageUrl = URL.createObjectURL(blob);
            }

            const avatarImg = new Image();
            avatarImg.className = 'repo-avatar';
            avatarImg.src = imageUrl;
            avatarImg.onload = () => {
                iconContainer.appendChild(avatarImg);
                setTimeout(() => avatarImg.classList.add('loaded'), 10);
            };
            avatarImg.onerror = () => URL.revokeObjectURL(imageUrl);

        } catch (e) {
            console.error("处理头像缓存时出错:", e);
            iconContainer.removeAttribute('data-avatar-url');
        }
    }
}



/**
 * [新增] 获取并显示指定仓库的版本列表
 * @param {string} repoFullName - 仓库全名 (e.g., "owner/repo")
 * @param {boolean} updateHistory - 是否更新浏览器历史记录
 */
async function fetchAndDisplayReleases(repoFullName, updateHistory = true) {
    state.viewingReleasesForRepo = repoFullName;
    state.currentView = 'releases_list'; // 设置新的视图状态
    
    // 更新UI
    el.repoList.innerHTML = '<div class="loading-spinner"><div class="spinner"></div></div>';
    el.currentRepo.textContent = `版本 - ${repoFullName.split('/')[1]}`;
    updateHomeStarredButtonState(); // 更新顶部按钮状态
    updatePaginationUI(); 
    
    if (updateHistory) {
        history.pushState({ view: 'releases_list', repo: repoFullName }, '', window.location.pathname);
    }

    try {
        const res = await fetch(`https://api.github.com/repos/${repoFullName}/releases`, {
            headers: { Authorization: `token ${state.token}` }
        });
        if (!res.ok) throw new Error(`获取版本列表失败 (HTTP ${res.status})`);
        
        const releases = await res.json();
        state.releases = releases; // 存储到 state
        renderReleasesList(releases);

    } catch (error) {
        showToast(error.message, 'error');
        el.repoList.innerHTML = `<div class="empty-state"><p>${error.message}</p></div>`;
    }
}

function renderReleasesList(releases) {
    el.repoList.innerHTML = '';
    
    const [owner] = state.viewingReleasesForRepo.split('/');
    const isOwner = state.user && owner === state.user.login;

    if (releases.length === 0) {
        const empty = document.createElement('div');
        empty.className = 'empty-state';
        empty.innerHTML = '<p>该仓库没有发布任何版本</p>';
        el.repoList.appendChild(empty);
        return;
    }

    const fragment = document.createDocumentFragment();
    releases.forEach(release => {
        const item = document.createElement('div');
        item.className = 'file-item';
        
        const deleteBtnHTML = isOwner ? 
            `<button class="btn-icon-sm danger delete-release-btn" style="margin-left:auto; z-index:2; flex-shrink:0;" title="删除">
                <i class="fa fa-trash"></i>
             </button>` : '';

        item.innerHTML = `
            <div class="file-icon"><i class="fa fa-folder"></i></div>
            <div class="file-info">
                <p class="file-name">
                    ${escapeHtml(release.name || release.tag_name)}
                    ${release.prerelease ? '<span class="label-prerelease" style="font-size:0.6em; background:#f59e0b; color:white; padding:1px 3px; border-radius:2px; margin-left:5px;">Pre</span>' : ''}
                </p>
                <p class="file-meta">
                    ${formatRelativeTime(new Date(release.published_at))} · ${release.assets.length} 文件
                </p>
            </div>
            ${deleteBtnHTML}
        `;
        
        item.addEventListener('click', (e) => {
            if (e.target.closest('.delete-release-btn')) return;
            fetchAndDisplayAssets(release);
        });

        if (isOwner) {
            const delBtn = item.querySelector('.delete-release-btn');
            delBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                showDeleteModal(null, false, '删除版本', `确定删除版本 <strong>${release.tag_name}</strong> 吗？此操作不可撤销。`, async () => {
                    await deleteReleaseInMainView(release.id, state.viewingReleasesForRepo);
                }, '删除', 'btn-danger');
            });
        }

        fragment.appendChild(item);
    });
    el.repoList.appendChild(fragment);
    updatePaginationUI();
}
async function createRelease() {
    const tagName = document.getElementById('releaseTagNameInput').value.trim();
    const name = document.getElementById('releaseNameInput').value.trim();
    const body = document.getElementById('releaseBodyInput').value.trim();
    const prerelease = document.getElementById('releasePrerelease').checked;
    const btn = document.getElementById('submitReleaseBtn');
    
    // 安全检查
    if (!currentManagingRepo) {
        showToast('操作上下文丢失，请重新点击底部加号按钮', 'error');
        hideReleaseManagerModal();
        return;
    }

    if (!tagName) {
        showToast('版本号不能为空', 'error');
        return;
    }
    
    let repoFullName = currentManagingRepo.full_name;
    if (!repoFullName && currentManagingRepo.owner && currentManagingRepo.name) {
        repoFullName = `${currentManagingRepo.owner.login}/${currentManagingRepo.name}`;
    }

    btn.disabled = true;
    btn.innerHTML = '发布中... <i class="fa fa-spinner fa-spin"></i>';
    
    try {
        const payload = {
            tag_name: tagName,
            target_commitish: currentManagingRepo.default_branch || 'main',
            name: name || tagName,
            body: body,
            draft: false,
            prerelease: prerelease
        };
        
        const res = await fetch(`https://api.github.com/repos/${repoFullName}/releases`, {
            method: 'POST',
            headers: { 
                'Authorization': `token ${state.token}`,
                'Content-Type': 'application/json',
                'Accept': 'application/vnd.github.v3+json'
            },
            body: JSON.stringify(payload)
        });
        
        if (!res.ok) {
            const err = await res.json().catch(() => ({}));
            throw new Error(err.message || '发布失败');
        }
        
        showToast('版本发布成功！', 'success');
        
        hideReleaseManagerModal();
        
        // 如果当前正好在版本列表页面，立即刷新列表
        if (state.currentView === 'releases_list' && state.viewingReleasesForRepo === repoFullName) {
            fetchAndDisplayReleases(repoFullName, false);
        }
        
    } catch (e) {
        showToast(`发布失败: ${e.message}`, 'error');
    } finally {
        btn.disabled = false;
        btn.textContent = '发布版本';
    }
}

async function deleteReleaseInMainView(releaseId, repoFullName) {
    try {
        const res = await fetch(`https://api.github.com/repos/${repoFullName}/releases/${releaseId}`, {
            method: 'DELETE',
            headers: { 
                'Authorization': `token ${state.token}`
            }
        });
        
        if (!res.ok && res.status !== 404) throw new Error('删除失败');
        
        showToast('版本已删除');
        hideDeleteModal();
        fetchAndDisplayReleases(repoFullName, false);
        
    } catch (e) {
        showToast(e.message, 'error');
    }
}
function hideReleaseManagerModal() {
    if (el.releaseManagerModal) {
        el.releaseManagerModal.classList.add('hidden');
        // 清理 UI 栈（如果使用了 uiStateStack）
        const index = uiStateStack.indexOf(hideReleaseManagerModal);
        if (index > -1) uiStateStack.splice(index, 1);
    }
}


function showReleaseManagerModal(repo, autoOpenForm = false) {
    currentManagingRepo = repo; // 关键：保存当前操作的仓库上下文
    
    // 1. 重置输入框
    document.getElementById('releaseTagNameInput').value = '';
    document.getElementById('releaseNameInput').value = '';
    document.getElementById('releaseBodyInput').value = '';
    document.getElementById('releasePrerelease').checked = false;
    
    // 2. 处理表单显示状态
    const form = document.getElementById('createReleaseForm');
    const icon = document.querySelector('#toggleCreateReleaseFormBtn i');
    const listSection = document.getElementById('releaseManagerList');

    if (autoOpenForm) {
        // 如果是从底部按钮点击进来的，强制展开表单，并隐藏列表（因为主界面已经是列表了）
        form.classList.remove('hidden');
        icon.className = 'fa fa-chevron-up';
        if (listSection) listSection.style.display = 'none';
    } else {
        // 默认状态（如从其他地方进入）：折叠表单，显示列表
        form.classList.add('hidden');
        icon.className = 'fa fa-chevron-down';
        if (listSection) listSection.style.display = 'block';
    }

    // 3. 显示模态框
    document.getElementById('releaseCountBadge').textContent = '0';
    el.releaseManagerModal.classList.remove('hidden');
    uiStateStack.push(hideReleaseManagerModal);
}

/**
 * [新增] 显示指定版本的资源列表 (无需API请求)
 * @param {object} release - 单个版本对象
 * @param {boolean} updateHistory - 是否更新浏览器历史记录
 */
function fetchAndDisplayAssets(release, updateHistory = true) {
    state.currentRelease = release;
    state.currentView = 'assets_list'; // 更新视图状态
    
    // 更新UI
    el.currentRepo.textContent = `文件 - ${release.name || release.tag_name}`;
    if (updateHistory) {
        history.pushState({ view: 'assets_list', repo: state.viewingReleasesForRepo, releaseId: release.id }, '', window.location.pathname);
    }
    
    renderAssetsList(release.assets);
}

function renderAssetsList(assets) {
    // 1. 强制标记当前视图为“版本详情”
    state.currentView = 'assets_list'; 
    
    el.repoList.innerHTML = '';
    
    // 2. 更新底部按钮（变成上传图标）
    updatePaginationUI();

    if (assets.length === 0) {
        const empty = document.createElement('div');
        empty.className = 'empty-state';
        empty.innerHTML = '<p>此版本暂无文件，点击底部按钮上传</p>';
        el.repoList.appendChild(empty);
        return;
    }

    const fragment = document.createDocumentFragment();
    assets.forEach(asset => {
        const item = document.createElement('div');
        item.className = 'file-item';
        item.innerHTML = `
            <div class="file-icon"><i class="fa ${getFileIcon(asset.name)}"></i></div>
            <div class="file-info">
                <p class="file-name">${escapeHtml(asset.name)}</p>
                <p class="file-meta">
                    ${formatSize(asset.size)} · ${asset.download_count} 次下载
                </p>
            </div>
        `;
        
        item.addEventListener('click', () => {
            downloadReleaseAsset(asset);
        });
        fragment.appendChild(item);
    });
    el.repoList.appendChild(fragment);
}




async function refreshAssetsList() {
    if (!state.currentRelease || !state.viewingReleasesForRepo) return;
    showToast('正在刷新版本信息...');
    try {
        const res = await fetch(`https://api.github.com/repos/${state.viewingReleasesForRepo}/releases`, {
            headers: { Authorization: `token ${state.token}` }
        });
        if (!res.ok) throw new Error('刷新失败');
        const releases = await res.json();
        state.releases = releases;
        const updatedRelease = releases.find(r => r.id === state.currentRelease.id);
        if (updatedRelease) {
            fetchAndDisplayAssets(updatedRelease, false); // 找到更新后的版本并重新渲染
        } else {
            showToast('此版本可能已被删除，返回上一页', 'error');
            goUp(); // 如果版本找不到了，自动返回
        }
    } catch(e) {
        showToast(e.message, 'error');
    }
}





function showRepoListView() {
    state.isSearchResultsView = false;
    el.searchToggleBtn.classList.remove('hidden');
    el.multiSelectToggleBtn.classList.remove('hidden');
    el.sortToggleBtn.classList.remove('hidden');
    state.shouldAnimateList = true;
    el.repoList.classList.remove('hidden');
    el.fileList.classList.add('hidden');
    el.pathNavContainer.classList.add('hidden');
    el.branchSwitcherContainer.classList.add('hidden');

    const globalSearchContainer = document.getElementById('globalSearchContainer');
    const globalSearchToggleBtn = document.getElementById('globalSearchToggleBtn');
    if (globalSearchContainer && !globalSearchContainer.classList.contains('hidden')) {
        globalSearchContainer.classList.add('hidden');
        globalSearchToggleBtn.classList.remove('active');
    }
    
    if (state.currentView === 'own_repos') {
        el.currentRepo.textContent = '选择仓库';
    } else if (state.currentView === 'starred_repos') {
        el.currentRepo.textContent = '星标仓库';
    } else if (state.currentView === 'other_user_repos') {
        el.currentRepo.textContent = `${state.viewingOwner} 的仓库`;
    }

    toggleView(true);
    state.currentRepo = null;
    state.currentPath = '';
    state.currentBranch = null;
    state.branches = [];
    
    updateGlobalSearchVisibility();
   
    setTimeout(() => { el.main.scrollTop = state.repoListScrollPosition; }, 0);
}

async function fetchBranches(repo) {
    try {
        const res = await fetch(`https://api.github.com/repos/${repo.full_name}/branches`, {
            headers: {
                Authorization: `token ${state.token}`,
                'User-Agent': 'Mozilla/5.0'
            }
        });
        if (res.ok) {
            state.branches = await res.json();
            state.branches.reverse();
        } else {
            state.branches = [];
            showToast('获取分支列表失败');
        }
    } catch (e) {
        state.branches = [];
        showToast('获取分支列表失败');
        console.error(e);
    }
}

function renderBranchSwitcher() {
    const container = el.branchSwitcherContainer;
    container.innerHTML = '';
    if (!state.branches || state.branches.length === 0) {
        container.classList.add('hidden');
        return;
    }
    const wrapper = document.createElement('div');
    wrapper.className = 'custom-branch-select-wrapper';
    const trigger = document.createElement('button');
    trigger.className = 'custom-branch-select-trigger';
    trigger.innerHTML = `
        <span>${escapeHtml(state.currentBranch)}</span>
        <i class="fa fa-chevron-down"></i>
    `;
    const optionsPanel = document.createElement('div');
    optionsPanel.className = 'custom-branch-select-options';
    state.branches.forEach(branch => {
        const option = document.createElement('div');
        option.className = 'custom-branch-select-option';
        if (branch.name === state.currentBranch) {
            option.classList.add('selected');
        }
        option.textContent = branch.name;
        option.dataset.branchName = branch.name;
        option.addEventListener('click', () => {
            const selectedBranch = option.dataset.branchName;
            if (selectedBranch === state.currentBranch) {
                wrapper.classList.remove('open');
                return;
            }
            state.shouldAnimateList = true;
            const previouslySelected = optionsPanel.querySelector('.custom-branch-select-option.selected');
            if (previouslySelected) {
                previouslySelected.classList.remove('selected');
            }
            option.classList.add('selected');
            state.currentBranch = selectedBranch;
            state.currentPath = '';
            localStorage.setItem(`last_branch_${state.currentRepo}`, state.currentBranch);
            el.fileList.innerHTML = '<div class="loading-spinner"><div class="spinner"></div></div>';
            const newState = { repo: state.currentRepo, path: '', branch: state.currentBranch };
            history.replaceState(newState, '', `#/${state.currentRepo}/`);
            renderPathNav();
            fetchFiles(true);
            trigger.querySelector('span').textContent = selectedBranch;
            wrapper.classList.remove('open');
        });
        optionsPanel.appendChild(option);
    });
    wrapper.appendChild(trigger);
    wrapper.appendChild(optionsPanel);
    container.appendChild(wrapper);
    container.classList.remove('hidden');
    trigger.addEventListener('click', (e) => {
        e.stopPropagation();
        wrapper.classList.toggle('open');
    });
    document.addEventListener('click', (e) => {
        if (!wrapper.contains(e.target)) {
            wrapper.classList.remove('open');
        }
    });
}

function preloadSubdirectories(files) {
    const dirs = files.filter(f => f.type === 'dir').slice(0, 15);
    if (dirs.length === 0) return;

    const run = () => {
        dirs.forEach(dir => {
            const cacheKey = `${state.currentRepo}:${state.currentBranch}:${dir.path}`;
            if (state.fileCache.has(cacheKey)) return;

            fetch(`https://api.github.com/repos/${state.currentRepo}/contents/${dir.path}?ref=${state.currentBranch}`, {
                headers: {
                    Authorization: `token ${state.token}`,
                    'User-Agent': 'Mozilla/5.0'
                }
            })
            .then(res => {
                if (res.ok) return res.json();
                throw new Error('Preload failed');
            })
            .then(data => {
                if (Array.isArray(data)) {
                    let fetchedFiles = data.map(file => {
                        const isImage = IMAGE_EXTS.includes(file.name.split('.').pop()?.toLowerCase());
                        if (isImage) {
                            return { ...file, isImageLoaded: false };
                        }
                        return file;
                    });
                    fetchedFiles.sort((a, b) => a.type === 'dir' && b.type !== 'dir' ? -1 : a.type !== 'dir' && b.type === 'dir' ? 1 : a.name.localeCompare(b.name));
                    state.fileCache.set(cacheKey, fetchedFiles);
                }
            })
            .catch(() => {});
        });
    };

    if ('requestIdleCallback' in window) {
        requestIdleCallback(run);
    } else {
        setTimeout(run, 500);
    }
}


function getFilesFromLocalTree(path) {
    if (!state.repoTreeCache) return null;
    const targetPath = path ? (path.endsWith('/') ? path : path + '/') : '';
    const files = [];
    for (const item of state.repoTreeCache) {
        if (!item.path.startsWith(targetPath)) continue;
        const relativePath = item.path.slice(targetPath.length);
        if (!relativePath) continue;
        if (relativePath.indexOf('/') !== -1) continue;
        
        files.push({
            name: relativePath,
            path: item.path,
            sha: item.sha,
            size: item.size,
            type: item.type === 'tree' ? 'dir' : 'file',
            html_url: `https://github.com/${state.currentRepo}/${item.type === 'tree' ? 'tree' : 'blob'}/${state.currentBranch}/${item.path}`
        });
    }
    return files;
}
async function loadRecursiveRepoTree() {
    try {
        const [owner, repo] = state.currentRepo.split('/');
        const currentBranchRef = state.currentBranch; 
        const currentRepoRef = state.currentRepo; 

        const url = `https://api.github.com/repos/${owner}/${repo}/git/trees/${currentBranchRef}?recursive=1`;
        const res = await fetch(url, {
            headers: {
                Authorization: `token ${state.token}`
            }
        });
        
        if (res.ok) {
            const data = await res.json();
            if (data.truncated) {
                showToast('仓库文件过多，部分深度目录可能需要单独加载', 'info');
            }
            state.repoTreeCache = data.tree;

            const images = data.tree.filter(item => {
                if (item.type !== 'blob') return false;
                const ext = item.path.split('.').pop().toLowerCase();
                return IMAGE_EXTS.includes(ext);
            });

            if (images.length > 0) {
                let index = 0;
                
                const preloadBatch = () => {
                    if (state.currentRepo !== currentRepoRef || state.currentBranch !== currentBranchRef) return;
                    
                    const batchSize = 4;
                    for (let i = 0; i < batchSize && index < images.length; i++) {
                        const item = images[index++];
                        const encodedPath = item.path.split('/').map(p => encodeURIComponent(p)).join('/');
                        const rawUrl = `https://raw.githubusercontent.com/${owner}/${repo}/${currentBranchRef}/${encodedPath}`;
                        const img = new Image();
                        img.src = getProxiedUrl(rawUrl);
                    }

                    if (index < images.length) {
                        if ('requestIdleCallback' in window) {
                            requestIdleCallback(preloadBatch);
                        } else {
                            setTimeout(preloadBatch, 200);
                        }
                    }
                };
                preloadBatch();
            }
        }
    } catch (e) {
        console.error("后台树加载失败", e);
    }
}
async function uploadFilesInSequence(files, index) {
    if (index >= files.length) {
        setTimeout(() => {
            el.uploadPanel.classList.add('hidden');
        }, 500);
        invalidateCacheForPathAndParents(state.currentPath);
        await fetchFiles(true); 
        return;
    }

    const file = files[index];
    const statusElement = document.querySelector(`.upload-status[data-index="${index}"]`);
    const existingFile = state.files.find(f => f.name === file.name);
    let shouldUpload = true;

    if (existingFile) {
        const userAction = await new Promise((resolve) => {
            showDeleteModal(
                null,
                false,
                '文件冲突',
                `文件 "${escapeHtml(file.name)}" 已存在，是否覆盖？
                <br><br>注意：覆盖后的文件生效时间较久，你马上操作的话还是原先的文件`,
                () => {
                    hideDeleteModal();
                    resolve('overwrite');
                },
                '覆盖',
                'btn-primary',
                () => {
                    hideDeleteModal();
                    resolve('skip');
                }
            );
        });

        if (userAction === 'skip') {
            shouldUpload = false;
            if (statusElement) {
                statusElement.textContent = '已跳过';
                statusElement.className = 'upload-status';
                statusElement.style.color = '#9ca3af';
            }
        }
    }

    if (shouldUpload) {
        try {
            await uploadSingleFile(file, index);
        } catch (error) {
            console.error(error);
        }
    }
    
    await uploadFilesInSequence(files, index + 1);
}

async function uploadSingleFile(file, index) {
    const MAX_FILE_SIZE_BYTES = 100 * 1024 * 1024;
    return new Promise((resolve, reject) => {
        const progressBar = document.querySelector(`.upload-progress[data-index="${index}"]`);
        const statusElement = document.querySelector(`.upload-status[data-index="${index}"]`);
        const percentTextEl = progressBar ? progressBar.querySelector(`.percent-text[data-index="${index}"]`) : null;
        
        if (file.size > MAX_FILE_SIZE_BYTES) {
            if (statusElement) {
                statusElement.textContent = '文件过大 (>100MB)';
                statusElement.className = 'upload-status error';
            }
            resolve(); 
            return;
        }
        
        if (statusElement) statusElement.textContent = '正在上传...';
        const reader = new FileReader();
        reader.readAsArrayBuffer(file);
        
        reader.onload = async (e) => {
            let progress = 0;
            const progressTimer = setInterval(() => {
                if (progress < 90) {
                    progress += 2;
                    if (progressBar) progressBar.style.width = `${progress}%`;
                    if (percentTextEl) percentTextEl.textContent = `${progress}%`;
                }
            }, 100);

            try {
                const [owner, repo] = state.currentRepo.split('/');
                const filePath = state.currentPath ? `${state.currentPath}${file.name}` : file.name;
                const contentBase64 = arrayBufferToBase64(e.target.result);
                const url = `https://api.github.com/repos/${owner}/${repo}/contents/${filePath}`;
                
                const performUpload = async (sha = null) => {
                    const body = {
                        message: `Upload ${file.name}`,
                        content: contentBase64,
                        branch: state.currentBranch
                    };
                    if (sha) body.sha = sha;

                    const res = await fetch(url, {
                        method: 'PUT',
                        headers: { 
                            'Authorization': `token ${state.token}`, 
                            'Content-Type': 'application/json',
                            'User-Agent': 'Mozilla/5.0'
                        },
                        body: JSON.stringify(body)
                    });
                    
                    if (!res.ok) {
                        if (res.status === 409 || res.status === 422) {
                            throw { status: res.status, isConflict: true };
                        }
                        const errData = await res.json().catch(() => ({}));
                        throw new Error(errData.message || res.statusText);
                    }
                    return res.json();
                };

                try {
                    // 尝试直接上传
                    // 如果本地缓存有SHA，先带上，提高成功率
                    const cachedFile = state.files.find(f => f.name === file.name);
                    await performUpload(cachedFile ? cachedFile.sha : null);
                } catch (err) {
                    if (err.isConflict) {
                        // 如果发生冲突(409/422)，说明文件已存在但SHA不对
                        // 获取最新SHA并重试
                        if (statusElement) statusElement.textContent = '覆盖中...';
                        const getRes = await fetch(`${url}?ref=${state.currentBranch}`, {
                            headers: { 'Authorization': `token ${state.token}` }
                        });
                        if (getRes.ok) {
                            const getData = await getRes.json();
                            await performUpload(getData.sha);
                        } else {
                            throw new Error('无法获取文件状态以覆盖');
                        }
                    } else {
                        throw err;
                    }
                }

                clearInterval(progressTimer);
                if (progressBar) progressBar.style.width = '100%';
                if (percentTextEl) percentTextEl.textContent = '100%';
                if (statusElement) {
                    statusElement.textContent = '上传成功';
                    statusElement.className = 'upload-status success';
                }
                resolve();

            } catch (error) {
                clearInterval(progressTimer);
                if (statusElement) {
                    statusElement.textContent = '失败: ' + error.message;
                    statusElement.className = 'upload-status error';
                }
                console.error(error);
                resolve(); // 即使失败也resolve，以便继续队列
            }
        };
    });
}

function navigateToRepo(repoData, branch, path = '', updateHistory = true) {
    // 1. 核心修复：强制更新当前视图状态为 "文件列表"
    state.currentView = 'file_list'; 
    state.isSearchResultsView = false;

    // 清理旧的树缓存，防止数据串味
    if (state.currentRepo !== repoData.full_name || state.currentBranch !== branch) {
        state.repoTreeCache = null; 
    }
    
    state.currentRepo = repoData.full_name;
    state.currentPath = path;
    state.currentBranch = branch;

    if (updateHistory) {
        const newState = {
            view: 'file_list',
            repo: repoData.full_name,
            path: path,
            branch: branch
        };
        history.pushState(newState, '', `#/${repoData.full_name}/${path}`);
    }

    el.currentRepo.textContent = repoData.name;
    
    // 切换界面显示
    toggleView(false);
    el.searchToggleBtn.classList.remove('hidden');
    el.multiSelectToggleBtn.classList.remove('hidden');
    el.sortToggleBtn.classList.remove('hidden');
    updateGlobalSearchVisibility();
    
    // 先显示加载动画
    el.fileList.innerHTML = '<div class="loading-spinner"><div class="spinner"></div></div>';

    renderPathNav();
    fetchBranches(repoData).then(renderBranchSwitcher);
    
    // 加载文件
    fetchFiles();
    if (!state.repoTreeCache) {
        loadRecursiveRepoTree();
    }
    
    // 2. 最后更新底部按钮，此时 state.currentView 已经是 'file_list' 了，逻辑就会正确
    updatePaginationUI();
}

async function fetchFiles(forceRefresh = false, showLoader = true) {
    if (!state.currentRepo || !state.currentBranch) return;

    const pathForFetch = state.currentPath;
    
    // 1. 优先尝试从本地全量树中获取（极大提速）
    if (!forceRefresh && state.repoTreeCache) {
        const localFiles = getFilesFromLocalTree(pathForFetch);
        if (localFiles) {
            state.files = localFiles;
            applyFiltersAndSort();
            renderFileList();
            // 即使本地有数据，如果是图片文件夹，可以后台预加载图片信息（可选）
            return;
        }
    }

    // 2. 其次尝试传统缓存
    const cacheKey = `${state.currentRepo}:${state.currentBranch}:${pathForFetch}`;
    if (!forceRefresh && state.fileCache.has(cacheKey)) {
        state.files = state.fileCache.get(cacheKey);
        applyFiltersAndSort();
        renderFileList();
        return;
    }

    // 3. 最后才走网络请求
    if (showLoader) {
        el.fileList.innerHTML = '<div class="loading-spinner"><div class="spinner"></div></div>';
    }
    await fetchFilesFromNetwork(true, pathForFetch);
}

async function fetchFilesFromNetwork(isInitialLoad = false, pathForFetch) {
    try {
        const timestamp = Date.now();
        const url = `https://api.github.com/repos/${state.currentRepo}/contents/${pathForFetch}?ref=${state.currentBranch}&t=${timestamp}`;
        const res = await fetch(url, {
            headers: {
                Authorization: `token ${state.token}`,
                'User-Agent': 'Mozilla/5.0'
            },
            cache: 'no-store'
        });

        if (!res.ok) {
            if (res.status === 404) {
                if (pathForFetch === state.currentPath) {
                    state.files = [];
                    applyFiltersAndSort();
                    renderFileList();
                }
                return;
            }
            throw new Error('加载文件失败');
        }

        const data = await res.json();
        if (data.message) throw new Error(data.message);

        let fetchedFiles = Array.isArray(data) ? data : [];

        const filesWithImageState = fetchedFiles.map(file => {
            const isImage = IMAGE_EXTS.includes(file.name.split('.').pop()?.toLowerCase());
            if (isImage) {
                return { ...file, isImageLoaded: false };
            }
            return file;
        });

        fetchedFiles = filesWithImageState;
        fetchedFiles.sort((a, b) => a.type === 'dir' && b.type !== 'dir' ? -1 : a.type !== 'dir' && b.type === 'dir' ? 1 : a.name.localeCompare(b.name));

        const cacheKey = `${state.currentRepo}:${state.currentBranch}:${pathForFetch}`;
        state.fileCache.set(cacheKey, [...fetchedFiles]);

        if (pathForFetch === state.currentPath) {
            state.files = fetchedFiles;
            applyFiltersAndSort();

            if (isInitialLoad) {
                state.shouldAnimateList = true;
            } else {
                state.shouldAnimateList = false;
            }
            renderFileList();
            preloadSubdirectories(fetchedFiles);
        }

    } catch (err) {
        if (err.name === 'AbortError') {
            return;
        }
        if (pathForFetch === state.currentPath) {
            showToast('加载文件失败: ' + err.message);
        }
        console.error(err);
    }
}


function renderFileList() {
    if (!state.loadedImageMap) state.loadedImageMap = new Map();

    const list = (state.displayFiles && state.displayFiles.length >= 0) ? state.displayFiles : state.files;
    const fragment = document.createDocumentFragment();
    const imageExtensions = ['png', 'jpg', 'jpeg', 'ico', 'gif', 'webp', 'bmp', 'svg'];
    const isGridView = state.viewMode === 'grid';
    
    if (!list || list.length === 0) {
        const emptyState = document.createElement('div');
        emptyState.className = 'empty-state';
        const emptyMessage = state.currentPath ? '文件夹为空' : '此分支为空';
        emptyState.innerHTML = `<i class="fa-brands fa-github"></i><p>${emptyMessage}</p>`;
        fragment.appendChild(emptyState);
    } else {
        list.forEach((file, index) => {
            const isDir = file.type === 'dir';
            const icon = isDir ? 'fa-folder' : getFileIcon(file.name);
            const item = document.createElement('div');
            const fileExtension = file.name.split('.').pop()?.toLowerCase();
            const isImage = !isDir && imageExtensions.includes(fileExtension);
            
            item.className = 'file-item';
            item.dataset.filePath = file.path; 
            
            if (state.shouldAnimateList) {
                item.classList.add('file-item-enter');
                item.style.animationDelay = `${index * 30}ms`;
            } else {
                item.style.opacity = 1;
            }
            
            if (state.selectedItems.has(file.path)) {
                item.classList.add('selected');
            }
            if (isGridView && isImage) {
                item.classList.add('is-image-grid');
            }
            
            const checkboxHTML = `
                <div class="select-checkbox-wrapper">
                    <div class="select-checkbox-bg"></div>
                    <i class="fa fa-check"></i>
                </div>
            `;
            
            let innerHTML = '';
            let fileMetaHTML;
            if (state.isLocalSearchResultsView) {
                fileMetaHTML = `<p class="file-meta">${isDir ? '文件夹' : formatSize(file.size)}</p>`;
            } else {
                fileMetaHTML = `
                    <p class="file-meta">
                        ${isDir ? '文件夹' : formatSize(file.size)}
                        ${(isDir || file.size) && file.last_modified ? ' · ' : ''}
                        ${file.last_modified ? formatRelativeTime(new Date(file.last_modified)) : ''}
                    </p>
                `;
            }

            // 获取缓存的URL（如果有）或生成新的URL，用于缩略图显示
            // 这里仅仅是为了显示缩略图，真正的点击逻辑在下方 click listener 中
            const rawUrlForThumb = file.download_url || file.html_url.replace('github.com', 'raw.githubusercontent.com').replace('/blob/', '/');
            const cachedUrlForThumb = state.loadedImageMap.get(file.path);
            const imageUrlForThumb = cachedUrlForThumb || getProxiedUrl(rawUrlForThumb);
            const isLoaded = !!cachedUrlForThumb || file.isImageLoaded;

            if (isGridView) {
                let gridContentHTML = '';
                if (isImage) {
                    if (isLoaded) {
                        gridContentHTML = `
                            <div class="file-thumbnail-container loaded" data-image-url="${escapeHtml(imageUrlForThumb)}" data-image-name="${escapeHtml(file.name)}">
                                 <img class="file-thumbnail" src="${escapeHtml(imageUrlForThumb)}" alt="${escapeHtml(file.name)}">
                            </div>
                            <div class="file-info">
                                <p class="file-name">${escapeHtml(file.name)}</p>
                                ${fileMetaHTML}
                            </div>
                        `;
                    } else {
                        gridContentHTML = `
                            <div class="file-thumbnail-container loading" data-image-url="${escapeHtml(imageUrlForThumb)}" data-image-name="${escapeHtml(file.name)}">
                                 <i class="fa fa-spinner fa-spin thumbnail-loader-icon"></i>
                                 <div class="thumbnail-error retry-trigger" title="点击重试"><i class="fa fa-repeat"></i></div>
                            </div>
                            <div class="file-info">
                                <p class="file-name">${escapeHtml(file.name)}</p>
                                ${fileMetaHTML}
                            </div>
                        `;
                    }
                } else {
                    gridContentHTML = `
                        <div class="file-icon"><i class="fa ${icon}"></i></div>
                        <div class="file-info">
                            <p class="file-name">${escapeHtml(file.name)}</p>
                            ${fileMetaHTML}
                        </div>
                    `;
                }
                innerHTML = checkboxHTML + gridContentHTML;
            } else {
                let listContentHTML = '';
                if (isImage) {
                     if (isLoaded) {
                         listContentHTML = `
                            <div class="file-thumbnail-container loaded" data-image-url="${escapeHtml(imageUrlForThumb)}" data-image-name="${escapeHtml(file.name)}">
                               <img class="file-thumbnail" src="${escapeHtml(imageUrlForThumb)}" alt="${escapeHtml(file.name)}">
                            </div>
                         `;
                     } else {
                         listContentHTML = `
                            <div class="file-thumbnail-container loading" data-image-url="${escapeHtml(imageUrlForThumb)}" data-image-name="${escapeHtml(file.name)}">
                               <i class="fa fa-spinner fa-spin thumbnail-loader-icon"></i>
                               <div class="thumbnail-error retry-trigger" title="点击重试"><i class="fa fa-repeat"></i></div>
                            </div>
                         `;
                     }
                } else {
                    listContentHTML = `<div class="file-icon"><i class="fa ${icon}"></i></div>`;
                }
                listContentHTML += `
                    <div class="file-info">
                        <p class="file-name">${escapeHtml(file.name)}</p>
                        ${fileMetaHTML}
                    </div>
                `;
                innerHTML = checkboxHTML + listContentHTML;
            }
            item.innerHTML = innerHTML;
            
            let pressTimer = null;
            let isLongPress = false;
            
            item.addEventListener('touchstart', () => {
                isLongPress = false;
                pressTimer = setTimeout(() => { isLongPress = true; }, 500);
            }, { passive: true });
            
            item.addEventListener('touchmove', () => clearTimeout(pressTimer));
            item.addEventListener('touchend', () => clearTimeout(pressTimer));
            
            item.addEventListener('click', (e) => {
                const retryTrigger = e.target.closest('.retry-trigger');
                if (retryTrigger) {
                    e.stopPropagation();
                    const container = retryTrigger.closest('.file-thumbnail-container');
                    if (container) {
                        if (file.path) state.loadedImageMap.delete(file.path);
                        const freshUrl = getProxiedUrl(file.download_url || file.html_url.replace('github.com', 'raw.githubusercontent.com').replace('/blob/', '/'));
                        container.dataset.imageUrl = freshUrl;
                        
                        container.classList.remove('error');
                        container.classList.add('loading');
                        loadThumbnailImage(container);
                    }
                    return;
                }

                if (isLongPress) return;

                e.stopPropagation();

                if (state.isMultiSelectMode) {
                    item.classList.toggle('selected');
                    if (state.selectedItems.has(file.path)) {
                        state.selectedItems.delete(file.path);
                    } else {
                        state.selectedItems.add(file.path);
                    }
                    updateActionBar();
                } else {
                    if (isDir) {
                        navigateToDir(file.name);
                    } else {
                        const fileExtension = file.name.split('.').pop()?.toLowerCase();
                        const isMedia = imageExtensions.includes(fileExtension) || VIDEO_EXTS.includes(fileExtension) || AUDIO_EXTS.includes(fileExtension);
                        const isNonEditable = NON_EDITABLE_EXTS.includes(fileExtension);

                        if (isMedia) {
                            const rawUrl = file.download_url || file.html_url.replace('github.com', 'raw.githubusercontent.com').replace('/blob/', '/');
                            
                            // [核心修改] 
                            // 在点击查看大图时，优先检查并使用 state.loadedImageMap 中的缓存URL
                            // 只有当缓存不存在时，才调用 getProxiedUrl 生成新链接
                            const cachedUrl = state.loadedImageMap.get(file.path);
                            const url = cachedUrl || getProxiedUrl(rawUrl);

                            if (AUDIO_EXTS.includes(fileExtension)) {
                                const nameWithoutExt = file.name.substring(0, file.name.lastIndexOf('.'));
                                if (typeof audioManager !== 'undefined') {
                                    audioManager.play(url, nameWithoutExt);
                                }
                                return;
                            }

                            const preview = document.getElementById('mediaPreview');
                            const img = document.getElementById('mediaPreviewImg');
                            const video = document.getElementById('mediaPreviewVideo');
                            
                            const openPreview = () => {
                                preview.classList.remove('hidden');
                                uiStateStack.push(hideMediaPreview);
                            };

                            if (imageExtensions.includes(fileExtension)) {
                                img.src = url;
                                img.style.display = '';
                                video.style.display = 'none';
                                openPreview();
                                
                                // 确保全屏查看成功的图片也进入缓存
                                if (!cachedUrl) {
                                    const imgForCache = new Image();
                                    imgForCache.onload = () => {
                                        state.loadedImageMap.set(file.path, url);
                                    };
                                    imgForCache.src = url;
                                }
                            } else if (VIDEO_EXTS.includes(fileExtension)) {
                                video.src = url;
                                video.style.display = '';
                                img.style.display = 'none';
                                openPreview();
                                video.load();
                            }

                        } else if (isNonEditable) {
                            downloadFile(file);
                        } else {
                            editFile(file);
                        }
                    }
                }
            });

            item.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                clearTimeout(pressTimer);
                isLongPress = true;
                showContextMenu(e, file);
            });
            
            fragment.appendChild(item);
        });
    }
    el.fileList.innerHTML = '';
    el.fileList.appendChild(fragment);
    updateActionBar();
    
    if (!state.isSearchResultsView) {
        processImagePlaceholders();
    }
    
    if (state.shouldAnimateList) {
        state.shouldAnimateList = false;
    }
}



function loadThumbnailImage(container) {
    if (container.classList.contains('loaded')) return;

    // 获取关键数据
    const imageUrl = container.dataset.imageUrl;
    const imageName = container.dataset.imageName;
    // 获取文件路径，这通常在父元素上
    const fileItem = container.closest('.file-item');
    const filePath = fileItem ? fileItem.dataset.filePath : null;

    if (!imageUrl) return;

    // 1. 检查缓存：如果该文件路径已经有成功加载过的URL（可能是旧代理的），优先使用缓存的URL
    // 这样切换代理后，已加载的图片不会变，也不会重新加载
    if (filePath && state.loadedImageMap.has(filePath)) {
        const cachedUrl = state.loadedImageMap.get(filePath);
        renderImageToContainer(container, cachedUrl, imageName);
        return;
    }

    const img = new Image();
    img.className = 'file-thumbnail';
    const lastDotIndex = imageName.lastIndexOf('.');
    const nameWithoutExt = lastDotIndex > 0 ? imageName.substring(0, lastDotIndex) : imageName;
    img.alt = nameWithoutExt;
    
    img.onload = () => {
        if (!document.body.contains(container)) return;
        
        // 2. 成功加载后，记录：路径 -> 这个URL
        if (filePath) {
            state.loadedImageMap.set(filePath, imageUrl);
        }

        renderImageToContainer(container, imageUrl, imageName, img);
        
        if (fileItem && filePath) {
            const fileInState = state.files.find(f => f.path === filePath);
            if (fileInState) fileInState.isImageLoaded = true;
        }
    };
    
    img.onerror = () => {
        if (!document.body.contains(container)) return;
        console.error('图片加载失败:', imageUrl);
        container.classList.remove('loading'); 
        container.classList.add('error');
    };
    
    img.src = imageUrl;
}

// 辅助函数：渲染图片DOM
function renderImageToContainer(container, url, name, imgElement = null) {
    if (!imgElement) {
        imgElement = new Image();
        imgElement.className = 'file-thumbnail';
        imgElement.src = url;
        const lastDotIndex = name.lastIndexOf('.');
        imgElement.alt = lastDotIndex > 0 ? name.substring(0, lastDotIndex) : name;
    }
    
    container.innerHTML = '';
    container.appendChild(imgElement);
    container.classList.remove('loading', 'error');
    container.classList.add('loaded');
}

function processImagePlaceholders() {
    const placeholders = document.querySelectorAll('.file-thumbnail-container.loading');
    placeholders.forEach(container => {
        loadThumbnailImage(container);
    });
}

function renderPathNav() {
    const navContainer = el.pathNavContainer;
    navContainer.innerHTML = '';
    navContainer.style.fontSize = '0.6rem';

    const parts = state.currentPath.split('/').filter(p => p);
    let currentPathAccumulator = '';

    parts.forEach((part, index) => {
        if (index > 0) {
            const separator = document.createElement('span');
            separator.className = 'path-separator';
            separator.textContent = '/';
            navContainer.appendChild(separator);
        }
        
        currentPathAccumulator += part + '/';
        const item = document.createElement('span');
        item.className = 'path-item';
        item.textContent = part;
        item.dataset.path = currentPathAccumulator;
        item.addEventListener('click', (e) => {
            navigateToPath(e.currentTarget.dataset.path);
        });
        navContainer.appendChild(item);
    });
}

function navigateToDir(dirName) {
state.isSearchResultsView = false;
    const newPath = state.currentPath ? `${state.currentPath}${dirName}/` : `${dirName}/`;
    navigateToPath(newPath);
}

function navigateToPath(path, updateHistory = true) {
    state.shouldAnimateList = true; 
    state.currentPath = path;
    if (updateHistory) {
        const newState = {
    view: 'file_list',
    repo: state.currentRepo,
    path: path,
    branch: state.currentBranch
};
history.pushState(newState, '', `#/${state.currentRepo}/${path}`);
    }
    fetchFiles();
    renderPathNav();
}

function updateSortDropdownUI() {
    const dropdown = el.customSortDropdown;
    if (!dropdown) return;
    Array.from(dropdown.children).forEach(item => {
        const value = item.dataset.value;
        const priority = item.dataset.priority;
        if (value) {
            item.classList.toggle('selected', state.sortBy === value);
        }
        if (priority) {
            item.classList.toggle('active', state.directorySortPriority === priority);
        }
    });
}


function closeSideNav() {
    el.sideNav.classList.remove('open');
    el.mainOverlay.classList.remove('open');
}


function hideSortDropdown() {
    el.customSortDropdown.classList.add('hidden');
    const index = uiStateStack.indexOf(hideSortDropdown);
    if (index > -1) uiStateStack.splice(index, 1);
}

function showSortDropdown() {
    el.customSortDropdown.classList.remove('hidden');
    uiStateStack.push(hideSortDropdown);
}

function showEditModal() {
    el.editModal.classList.remove('hidden');
    el.editModal.classList.add('flex');
    el.editorOverlay.classList.add('show');
    setTimeout(adjustEditorDimensions, 10);
    uiStateStack.push(hideEditModal);
}

function hideEditModal() {
    toggleEditorSearch(false);
    el.editModal.classList.add('hidden');
    el.editModal.classList.remove('flex');
    state.editingFile = state.fileSha = state.originalContent = '';
    el.saveEdit.classList.remove('modified');
    const index = uiStateStack.indexOf(hideEditModal);
    if (index > -1) uiStateStack.splice(index, 1);
}

function showEditStatus(text, type) {
    el.editStatus.textContent = text;
    el.editStatus.className = `edit-status ${type}`;
}

function adjustEditorDimensions() {
    const viewportHeight = window.innerHeight;
    const targetEditorHeight = viewportHeight * 0.48;
    const modal = el.editModal.querySelector('.modal-content');
    const headerHeight = modal.querySelector('.modal-header').offsetHeight;
    const statusHeight = el.editStatus.offsetHeight;
    const footerHeight = modal.querySelector('.modal-footer').offsetHeight;
    const paddingOffset = 20;
    const otherElementsHeight = headerHeight + statusHeight + footerHeight + paddingOffset;
    modal.style.height = `${targetEditorHeight + otherElementsHeight}px`;
    el.fileContent.style.height = `${targetEditorHeight}px`;
}

async function editFile(file) {
    state.editingFile = file;
    el.editFileName.textContent = `${file.name}`;
    el.fileContent.value = '';
    showEditStatus('', '');

    try {
        const shouldBeMaximized = localStorage.getItem('editor-maximized') === 'true';
        if (shouldBeMaximized) {
            el.editModal.classList.add('maximized');
            
            const maximizeButton = document.getElementById('toggleMaximizeModal');
            const icon = maximizeButton.querySelector('i');
            icon.classList.remove('fa-expand');
            icon.classList.add('fa-compress');
            maximizeButton.title = '恢复';
            
        }
    } catch(e) { console.error("无法应用最大化状态:", e); }

    showEditModal();
    const isOwner = state.user && state.viewingOwner === state.user.login;
    el.saveEdit.classList.toggle('hidden', !isOwner);
    el.revertEditBtn.classList.toggle('hidden', !isOwner);
    el.fileContent.readOnly = !isOwner;
    const cacheKey = `edit_cache_${state.currentRepo}_${state.currentBranch}_${state.editingFile.path}`;
    const cachedItem = localStorage.getItem(cacheKey);
    if (cachedItem) {
        try {
            const parsedData = JSON.parse(cachedItem);
            if (Date.now() - parsedData.timestamp < 3 * 60 * 1000) {
                el.fileContent.value = parsedData.content;
                el.editorOverlay.classList.remove('show');
                fetch(`https://api.github.com/repos/${state.currentRepo.split('/')[0]}/${state.currentRepo.split('/')[1]}/contents/${file.path}?ref=${state.currentBranch}`, { headers: { 'Authorization': `token ${state.token}` } })
                    .then(res => res.json())
                    .then(data => {
                        state.originalContent = decodeURIComponent(escape(atob(data.content)));
                        state.fileSha = data.sha;
                        el.fileContent.oninput = checkContentChanges;
                        checkContentChanges();
                        showEditorScaleHintOnce();
                    });
                return;
            } else {
                localStorage.removeItem(cacheKey);
            }
        } catch (e) {
            localStorage.removeItem(cacheKey);
        }
    }
    try {
        const res = await fetch(`https://api.github.com/repos/${state.currentRepo.split('/')[0]}/${state.currentRepo.split('/')[1]}/contents/${file.path}?ref=${state.currentBranch}`, {
            headers: { 'Authorization': `token ${state.token}`, 'User-Agent': 'Mozilla/5.0' }
        });
        if (!res.ok) throw new Error((await res.json()).message || '加载文件失败');
        
        const data = await res.json();
        const content = decodeURIComponent(escape(atob(data.content)));
        
        el.fileContent.value = content;
        state.originalContent = content;
        state.fileSha = data.sha;
        el.editorOverlay.classList.remove('show');
        el.fileContent.oninput = checkContentChanges;
        checkContentChanges();
        showEditorScaleHintOnce();
    } catch (e) {
        el.editorOverlay.classList.remove('show');
        showEditStatus(`错误：${e.message}`, 'error');
    }
}

function checkContentChanges() {
    const isModified = el.fileContent.value !== state.originalContent;
    el.saveEdit.classList.toggle('modified', isModified);
    el.revertEditBtn.disabled = !isModified;
}

async function saveEditedFile() {
await autoClearCacheIfNeeded();
    if (!state.editingFile || !state.fileSha) return;
    const currentContent = el.fileContent.value;
    if (currentContent === state.originalContent) {
        showToast('未检测到修改');
        return;
    }
    el.editorOverlay.classList.add('show');
    el.saveEdit.classList.add('btn-processing');
    try {
        const [owner, repo] = state.currentRepo.split('/');
        const encodedContent = btoa(unescape(encodeURIComponent(currentContent)));
        const url = `https://api.github.com/repos/${owner}/${repo}/contents/${state.editingFile.path}`;
        const requestBody = {
            message: `Update ${state.editingFile.name} via web editor`,
            content: encodedContent,
            sha: state.fileSha,
            branch: state.currentBranch
        };
        const requestHeaders = {
            'Authorization': `token ${state.token}`,
            'Content-Type': 'application/json',
            'User-Agent': 'Mozilla/5.0'
        };
        let res = await fetch(url, {
            method: 'PUT',
            headers: requestHeaders,
            body: JSON.stringify(requestBody)
        });
        if (!res.ok) {
            if (res.status === 409) {
                const latestInfoRes = await fetch(url, { headers: { 'Authorization': `token ${state.token}`, 'User-Agent': 'Mozilla/5.0' } });
                if (!latestInfoRes.ok) throw new Error('获取最新文件版本失败');
                const latestInfo = await latestInfoRes.json();
                
                requestBody.sha = latestInfo.sha;
                res = await fetch(url, {
                    method: 'PUT',
                    headers: requestHeaders,
                    body: JSON.stringify(requestBody)
                });
                if (!res.ok) {
                    const err = await res.json();
                    throw new Error(`保存失败: ${err.message}`);
                }
            } else {
                const err = await res.json();
                throw new Error(`保存失败: ${err.message}`);
            }
        }
        const result = await res.json();
        state.fileSha = result.content.sha;
        state.originalContent = currentContent;
        try {
    const CACHE_SIZE_LIMIT = 100 * 1024;
    const currentContentSize = new Blob([currentContent]).size;

    const cacheKey = `edit_cache_${state.currentRepo}_${state.currentBranch}_${state.editingFile.path}`;

    if (currentContentSize < CACHE_SIZE_LIMIT) {
        const cacheData = {
            content: currentContent,
            timestamp: Date.now()
        };
        localStorage.setItem(cacheKey, JSON.stringify(cacheData));
    } else {
        localStorage.removeItem(cacheKey);
        console.log(`文件大小 (${formatSize(currentContentSize)}) 超出本地缓存限制，已跳过缓存。`);
    }
} catch (e) {
    console.warn("保存本地编辑缓存失败，可能是存储空间已满:", e);
    showToast('本地存储空间已满，临时草稿无法保存', 'info');
}
        el.editorOverlay.classList.remove('show');
        showToast('文件已保存');
        showSaveNotification();
        fetchFiles(true);
        checkContentChanges();
    } catch (e) {
        el.editorOverlay.classList.remove('show');
        showEditStatus(`错误：${e.message}`, 'error');
        console.error(e);
    } finally {
        el.saveEdit.classList.remove('btn-processing');
    }
}





async function downloadReleaseAsset(asset) {
    showToast(`正在准备下载: ${asset.name}`);

    let downloadUrl = asset.browser_download_url;

    if (state.proxyGlobalEnable && state.proxies.length > 0 && state.activeProxyIndex !== -1) {
        const activeProxy = state.proxies[state.activeProxyIndex];
        if (activeProxy && activeProxy.url && activeProxy.type === 'prefix') {
            let proxyBase = activeProxy.url;
            if (!proxyBase.endsWith('/')) {
                proxyBase += '/';
            }
            downloadUrl = proxyBase + downloadUrl;
        }
    }

    try {
        const a = document.createElement('a');
        a.href = downloadUrl;
        a.download = asset.name;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);

    } catch (error) {
        showToast(`下载 "${asset.name}" 失败，请检查浏览器设置`, 'error');
        console.error(error);
    }
}




function hideMainMenuPopup() {
    
    const mainMenuPopup = document.getElementById('mainMenuPopup');
    if (mainMenuPopup) {
        mainMenuPopup.classList.add('hidden');
    }
}

async function downloadFile(item) {
    if (item.type === 'dir') return;

    const fileExtension = item.name.split('.').pop()?.toLowerCase();
    
    const displayableExtensions = [
        'png', 'jpg', 'jpeg', 'gif', 'webp', 'bmp', 'svg', 'ico',
        'txt', 'md', 'html', 'css', 'js', 'json', 'xml', 'log', 'ini', 'conf', 'yml', 'yaml',
        'pdf',
        'mp4', 'webm', 'mp3', 'ogg', 'wav', 'mov', 'mkv' 
    ];
    
    const shouldUseBlobDownload = displayableExtensions.includes(fileExtension);

    try {
        const rawUrl = (item.download_url) ? item.download_url : item.html_url.replace('github.com', 'raw.githubusercontent.com').replace('/blob/', '/');
        const url = getProxiedUrl(rawUrl);

        showToast(`正在准备下载: ${item.name}`);

        if (shouldUseBlobDownload) {
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`下载失败 (HTTP ${response.status})`);
            }

            const contentLength = response.headers.get('content-length');
            const totalSize = contentLength ? parseInt(contentLength, 10) : (item.size || 0);
            if (totalSize > 0) {
                showToast(`正在获取文件 (${formatSize(totalSize)})...`, 'info', 3000);
            }

            const blob = await response.blob();
            const objectUrl = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = objectUrl;
            a.download = item.name;
            document.body.appendChild(a);
            a.click();
            
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(objectUrl);
            }, 500);
        } else {
            const a = document.createElement('a');
            a.href = url;
            a.download = item.name;
            document.body.appendChild(a);
            a.click();
            setTimeout(() => {
                document.body.removeChild(a);
            }, 500);
        }
    } catch (e) {
        showToast(`下载出错: ${e.message}`, 'error');
        console.error(e);
    }
}
function copyLink(file) {
    const rawUrl = file.download_url || file.html_url.replace('github.com', 'raw.githubusercontent.com').replace('/blob/', '/');
    navigator.clipboard.writeText(rawUrl).then(() => {
        showToast('Raw 链接已复制');
    }).catch(e => {
        showToast(`复制失败: ${e.message || '应用剪切板权限没给'}`);
        console.error(e);
    });
}

function copyProxyLink(file) {
    const rawUrl = file.download_url || file.html_url.replace('github.com', 'raw.githubusercontent.com').replace('/blob/', '/');
    const activeProxy = state.proxies[state.activeProxyIndex];
    if (state.proxyGlobalEnable && activeProxy && activeProxy.url && activeProxy.type) {
        let proxiedUrl = rawUrl;
        const proxyDomain = getDomainFromUrl(activeProxy.url);
        
        if (activeProxy.type === 'prefix') {
            let base = activeProxy.url;
            if (!base.endsWith('/')) {
                base += '/';
            }
            proxiedUrl = base + rawUrl;
        } else if (activeProxy.type === 'raw_domain_replace') {
            proxiedUrl = rawUrl.replace(/^(https?:\/\/raw\.)githubusercontent\.com(\/.*)$/i, `$1${proxyDomain}$2`);
            if (!proxiedUrl.startsWith('http')) {
                proxiedUrl = 'https://' + proxiedUrl;
            }
        }
        navigator.clipboard.writeText(proxiedUrl).then(() => {
            const displayUrl = activeProxy.url.replace(/^https?:\/\//, '').replace(/\/$/, '');
            showToast(`已复制当前代理链接 [${displayUrl}]`);
        }).catch(e => {
            showToast(`复制失败: ${e.message || '应用剪切板权限没给'}`);
            console.error(e);
        });
    } else {
        navigator.clipboard.writeText(rawUrl).then(() => {
            showToast('代理未开启，已复制直连 Raw 链接');
        }).catch(e => {
            showToast(`复制失败: ${e.message || '应用剪切板权限没给'}`);
            console.error(e);
        });
    }
}

function positionContextMenu(e, menuWidth, menuHeight) {
    let clickX, clickY;
    if (e.touches && e.touches.length > 0) {
        clickX = e.touches[0].clientX;
        clickY = e.touches[0].clientY;
    } else {
        clickX = e.clientX;
        clickY = e.clientY;
    }
    const offsetX = 30;
    const offsetY = 30;
    let leftPos = clickX + offsetX;
    let topPos = clickY + offsetY;
    const windowWidth = window.innerWidth;
    const windowHeight = window.innerHeight;
    if (leftPos + menuWidth > windowWidth) {
        leftPos = clickX - menuWidth - offsetX;
    }
    if (topPos + menuHeight > windowHeight) {
        topPos = clickY - menuHeight - offsetY;
    }
    if (leftPos < 0) leftPos = 5;
    if (topPos < 0) topPos = 5;
    return { top: topPos, left: leftPos };
}

function renderContextMenuItems(file) {
    el.contextMenuItems.innerHTML = '';
    const isDir = file.type === 'dir';
    const category = isDir ? 'folder' : 'file';
    const fileExtension = file.name.split('.').pop()?.toLowerCase();

    const isOwner = state.user && state.viewingOwner === state.user.login;
    
    // 核心修改：先尝试获取完整的仓库对象
    const currentRepoObject = state.repos.find(repo => repo.full_name === state.currentRepo);

    const visibleItems = CONTEXT_MENU_DEFINITIONS[category].filter(item => {
        if (item.action === 'goToDirectory' && !state.isSearchResultsView) {
            return false;
        }

        if (!isOwner && ['edit', 'rename', 'delete', 'unzip'].includes(item.action)) {
            return false;
        }
        
        if (item.action === 'unzip' && !ZIP_EXTS.includes(fileExtension)) {
            return false;
        }
        
        // 如果需要仓库的额外信息，但我们暂时没有，就先不显示这个按钮
        if (['copyPagesLink', 'copyCustomDomainLink'].includes(item.action) && !currentRepoObject) {
            return false;
        }
        
        if (item.action === 'copyPagesLink' && currentRepoObject) {
            const isMainSiteRepo = state.user && currentRepoObject.name === `${state.user.login}.github.io`;
            if (!currentRepoObject.has_pages && !isMainSiteRepo) {
                return false;
            }
        }

        if (item.action === 'copyCustomDomainLink' && currentRepoObject) {
            return !!currentRepoObject.customDomain;
        }
        
        return state.contextMenuVisibility[category][item.action];
    });

    visibleItems.forEach(({ action, icon, text, className = '' }) => {
        const item = document.createElement('a');
        item.className = `context-menu-item ${className}`;
        item.dataset.action = action;
        item.innerHTML = `<i class="fa ${icon} mr-2"></i>${text}`;
        item.addEventListener('click', () => {
            handleContextMenuAction(action, state.selectedFile);
            hideContextMenu();
        });
        el.contextMenuItems.appendChild(item);
    });
}
function showContextMenu(e, file) {
    state.selectedFile = file;
    const menu = el.contextMenu;
    menu.style.opacity = '0';
    menu.style.transform = 'scale(0.8)';
    menu.classList.remove('hidden');
    renderContextMenuItems(file);
    const menuWidth = menu.offsetWidth;
    const menuHeight = menu.offsetHeight;
    const position = positionContextMenu(e, menuWidth, menuHeight);
    menu.style.top = `${position.top}px`;
    menu.style.left = `${position.left}px`;
    let start = null, duration = 150;
    function animate(timestamp) {
        if (!start) start = timestamp;
        const progress = Math.min((timestamp - start) / duration, 1);
        menu.style.opacity = progress.toString();
        menu.style.transform = `scale(${0.8 + 0.2 * progress})`;
        if (progress < 1) requestAnimationFrame(animate);
    }
    requestAnimationFrame(animate);
    uiStateStack.push(hideContextMenu);
}

async function showRepoContextMenu(e, repo) {
    state.selectedRepo = repo;
    const menu = el.contextMenu;
    menu.style.opacity = '0';
    menu.style.transform = 'scale(0.8)';
    menu.classList.remove('hidden');
    await renderRepoContextMenuItems(repo);
    const menuWidth = menu.offsetWidth;
    const menuHeight = menu.offsetHeight;
    const position = positionContextMenu(e, menuWidth, menuHeight);
    menu.style.top = `${position.top}px`;
    menu.style.left = `${position.left}px`;
    let start = null, duration = 150;
    function animate(timestamp) {
        if (!start) start = timestamp;
        const progress = Math.min((timestamp - start) / duration, 1);
        menu.style.opacity = progress.toString();
        menu.style.transform = `scale(${0.8 + 0.2 * progress})`;
        if (progress < 1) requestAnimationFrame(animate);
    }
    requestAnimationFrame(animate);
    uiStateStack.push(hideContextMenu);
}

async function renderRepoContextMenuItems(repo) {
    el.contextMenuItems.innerHTML = '';
    const isMainSiteRepo = state.user && repo.name === `${state.user.login}.github.io`;
    const isPublished = repo.has_pages;
    const pinnedRepos = JSON.parse(localStorage.getItem('pinned_repos') || '[]');
    const isPinned = pinnedRepos.includes(repo.id);
    const isOwner = state.user && repo.owner.login.toLowerCase() === state.user.login.toLowerCase();

    const visibleItems = CONTEXT_MENU_DEFINITIONS.repo.filter(item => {
        if (!state.contextMenuVisibility.repo[item.action]) {
            return false;
        }

        if (isOwner) {
            const disallowedActionsForOwner = ['forkRepo', 'unstarRepo', 'viewUserRepos'];
            if (disallowedActionsForOwner.includes(item.action)) {
                return false;
            }
        } else {
            const disallowedActionsForOthers = ['togglePin', 'renameRepo', 'createBranch', 'deleteRepo'];
            if (disallowedActionsForOthers.includes(item.action)) {
                return false;
            }
        }
        
if (item.action === 'viewUserRepos') {
            
            return !isOwner && state.currentView !== 'other_user_repos';
        }
        
        if (item.action === 'unstarRepo') {
             return state.currentView === 'starred_repos';
        }

        if (item.action === 'copyMainSiteLink') {
            return isMainSiteRepo;
        }
        if (item.action === 'copyProjectSiteLink') {
            return isPublished && !isMainSiteRepo;
        }
        if (item.action === 'copyCustomDomainLink') {
            return !!repo.customDomain;
        }
        return true;
    });

    visibleItems.forEach(({ action, icon, text, className = '' }) => {
        const item = document.createElement('a');
        item.className = `context-menu-item ${className}`;
        item.dataset.action = action;
        
        if (action === 'togglePin') {
            text = isPinned ? '取消置顶' : '置顶';
        }
        
        item.innerHTML = `<i class="fa ${icon} mr-2"></i>${text}`;
        item.addEventListener('click', () => {
            handleRepoContextMenuAction(action, state.selectedRepo);
            hideContextMenu();
        });
        el.contextMenuItems.appendChild(item);
    });
}

const hideContextMenu = () => {
    if (isContextMenuClosing) return; 
    const menu = el.contextMenu;
    if (menu.classList.contains('hidden')) return;

    isContextMenuClosing = true;

    let start = null,
        duration = 150;
    function animate(timestamp) {
        if (!start) start = timestamp;
        const progress = Math.min((timestamp - start) / duration, 1);
        menu.style.opacity = (1 - progress).toString();
        menu.style.transform = `scale(${1 - 0.2 * progress})`;
        if (progress < 1) {
            requestAnimationFrame(animate);
        } else {
            menu.classList.add('hidden');
            state.selectedFile = null;
            state.selectedRepo = null;
            isContextMenuClosing = false; 
        }
    }
    requestAnimationFrame(animate);
    const index = uiStateStack.indexOf(hideContextMenu);
    if (index > -1) uiStateStack.splice(index, 1);
};

async function deleteSingleItem(item) {
    const [owner, repo] = state.currentRepo.split('/');
    const deleteFile = async (path, sha) => {
        const res = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${path}`, {
            method: 'DELETE',
            headers: { Authorization: `token ${state.token}`, 'Content-Type': 'application/json' },
            body: JSON.stringify({ message: `Delete ${item.name}`, sha: sha, branch: state.currentBranch })
        });
        if (!res.ok) {
            let errorMessage;
            if (res.status === 401) errorMessage = '令牌无效或已过期。';
            else if (res.status === 403) errorMessage = '权限不足。';
            else if (res.status === 404) errorMessage = '文件未找到。';
            else if (res.status === 409) errorMessage = '文件冲突，请刷新后重试。';
            else errorMessage = `发生未知网络错误 (HTTP ${res.status})。`;
            throw new Error(errorMessage);
        }
    };
    const getAllFiles = async (path) => {
        let allFiles = [];
        const res = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${path}?ref=${state.currentBranch}`, { headers: { Authorization: `token ${state.token}` } });
        const items = await res.json();
        if (!Array.isArray(items)) return [];
        for (const i of items) {
            if (i.type === 'dir') {
                allFiles = allFiles.concat(await getAllFiles(i.path));
            } else {
                allFiles.push(i);
            }
        }
        return allFiles;
    };
    if (item.type === 'dir') {
        const filesToDelete = await getAllFiles(item.path);
        for (const f of filesToDelete.reverse()) {
            await deleteFile(f.path, f.sha);
        }
    } else {
        await deleteFile(item.path, item.sha);
    }
}

async function handleContextMenuAction(action, oldFileObject) {
    let currentFile;

    if (state.isSearchResultsView) {
        currentFile = oldFileObject;
    } else {
        currentFile = state.files.find(f => f.path === oldFileObject.path);
        if (!currentFile) {
            showToast('文件已更新，请重新选择或刷新页面');
            return;
        }
    }

    switch (action) {
        case 'goToDirectory':
            if (currentFile.repository) {
                const repoFullName = currentFile.repository.full_name;
                
                try {
                    const res = await fetch(`https://api.github.com/repos/${repoFullName}`, {
                        headers: { Authorization: `token ${state.token}` }
                    });
                    if (!res.ok) throw new Error('无法获取仓库详情');
                    
                    const fullRepoData = await res.json();
                    
                    const path = currentFile.path;
                    let dirPath = path.substring(0, path.lastIndexOf('/'));
                    if (dirPath) {
                        dirPath += '/';
                    }
                    
                    navigateToRepo(fullRepoData, fullRepoData.default_branch, dirPath);

                } catch (error) {
                    showToast(`跳转失败: ${error.message}`, 'error');
                }
            }
            break;
    
        case 'rename':
            if (state.isSearchResultsView) {
                try {
                    const repoRes = await fetch(`https://api.github.com/repos/${state.currentRepo}`, {
                        headers: { Authorization: `token ${state.token}` }
                    });
                    if (!repoRes.ok) throw new Error('无法获取仓库详情');
                    const repoData = await repoRes.json();
                    
                    state.currentBranch = repoData.default_branch;
                    
                    showRenameModal(currentFile);
                } catch (error) {
                    showToast(`操作失败: ${error.message}`, 'error');
                }
            } else {
                showRenameModal(currentFile);
            }
            break;
        
        case 'copyPagesLink':
            const [owner, repoName] = state.currentRepo.split('/');
            const isMainSiteRepo = state.user && repoName === `${state.user.login}.github.io`;
            
            const pagesUrl = isMainSiteRepo
                ? `https://${owner}.github.io/${currentFile.path}`
                : `https://${owner}.github.io/${repoName}/${currentFile.path}`;

            navigator.clipboard.writeText(pagesUrl).then(() => {
                showToast('项目网站链接已复制');
            }).catch(e => {
                showToast(`复制失败: ${e.message || '应用剪切板权限没给'}`);
            });
            break;
        case 'copyCustomDomainLink': {
            const currentRepoObject = state.repos.find(repo => repo.full_name === state.currentRepo);
            if (currentRepoObject && currentRepoObject.customDomain) {
                const customUrl = `https://${currentRepoObject.customDomain}/${currentFile.path}`;
                navigator.clipboard.writeText(customUrl).then(() => {
                    showToast(`自定义域名复制成功: ${customUrl}`);
                }).catch(e => {
                    showToast(`复制失败: ${e.message}`);
                });
            }
            break;
        }
        case 'unzip':
            unzipFile(currentFile);
            break;

        case 'delete':
            showDeleteModal(currentFile);
            break;
            
        case 'multiSelect':
            toggleMultiSelectMode(true);
            state.selectedItems.add(currentFile.path);
            renderFileList();
            updateActionBar();
            break;
        case 'download':
            downloadFile(currentFile);
            break;
        case 'downloadFolder':
            downloadFolderAsZip(currentFile);
            break;
        case 'copyLink':
            copyLink(currentFile);
            break;
        case 'copyProxy':
            copyProxyLink(currentFile);
            break;
        case 'copyGitHubLink':
            navigator.clipboard.writeText(currentFile.html_url).then(() => {
                showToast('GitHub 链接已复制');
            }).catch(e => {
                showToast(`复制失败: ${e.message || '应用剪切板权限没给'}`);
                console.error(e);
            });
            break;
        case 'edit':
            if (state.isSearchResultsView) {
                showToast('正在获取仓库信息...', 'info');
                try {
                    const repoRes = await fetch(`https://api.github.com/repos/${state.currentRepo}`, {
                        headers: { Authorization: `token ${state.token}` }
                    });
                    if (!repoRes.ok) throw new Error('无法获取仓库详情');
                    const repoData = await repoRes.json();
                    
                    state.currentBranch = repoData.default_branch;
                    
                    editFile(currentFile);
                } catch (error) {
                    showToast(`操作失败: ${error.message}`, 'error');
                }
            } else {
                editFile(currentFile);
            }
            break;
    }
}

async function handleRepoContextMenuAction(action, repo) {
    const isMainSiteRepo = state.user && repo.name === `${state.user.login}.github.io`;

    switch (action) {
        case 'viewDetails':
            showRepoDetailsModal(repo);
            break;
            
        case 'manageReleases':
    fetchAndDisplayReleases(repo.full_name);
    break;

        case 'togglePin': {
            const pinnedRepos = JSON.parse(localStorage.getItem('pinned_repos') || '[]');
            const repoId = repo.id;
            const index = pinnedRepos.indexOf(repoId);

            if (index > -1) {
                pinnedRepos.splice(index, 1);
                showToast(`仓库 "${repo.name}" 已取消置顶`);
            } else {
                pinnedRepos.push(repoId);
                showToast(`仓库 "${repo.name}" 已置顶`);
            }

            localStorage.setItem('pinned_repos', JSON.stringify(pinnedRepos));
            renderRepoList(state.currentView === 'own_repos' ? state.repos : state.starredRepos);
            break;
        }
       case 'forkRepo':
            showForkRepoModal(repo);
            break;
        
        case 'unstarRepo':
            showDeleteModal(
                null,
                false,
                '确认取消关注',
                `确定要取消关注仓库 "${escapeHtml(repo.name)}" 吗？`,
                async () => {
                    try {
                        const res = await fetch(`https://api.github.com/user/starred/${repo.full_name}`, {
                            method: 'DELETE',
                            headers: { 'Authorization': `token ${state.token}` }
                        });

                        if (!res.ok) {
                            throw new Error(`操作失败 (HTTP ${res.status})`);
                        }

                        showToast(`已取消关注 "${escapeHtml(repo.name)}"`);

                        state.starredRepos = state.starredRepos.filter(r => r.id !== repo.id);
                        localStorage.setItem('cached_starred_repos', JSON.stringify(state.starredRepos));
                        renderRepoList(state.starredRepos);

                    } catch (e) {
                        showToast(`取消关注失败: ${e.message}`, 'error');
                    }
                },
                '确认取消',
                'btn-danger'
            );
            break;

        case 'viewUserRepos':
            fetchAndDisplayUserRepos(repo.owner.login);
            break;

        case 'copyProjectSiteLink':
            const siteUrl = `https://${repo.owner.login}.github.io/${repo.name}/`;
            navigator.clipboard.writeText(siteUrl).then(() => {
                showToast('项目网站链接已复制', 'success');
            }).catch(err => {
                showToast('复制失败', 'error');
            });
            break;
        case 'copyMainSiteLink':
            const mainSiteUrl = `https://${repo.owner.login}.github.io/`;
            navigator.clipboard.writeText(mainSiteUrl).then(() => {
                showToast('主站链接已复制', 'success');
            }).catch(err => {
                showToast('复制失败', 'error');
            });
            break;
       
        case 'copyCustomDomainLink':
            if (repo.customDomain) {
                const customUrl = `https://${repo.customDomain}`;
                navigator.clipboard.writeText(customUrl).then(() => {
                    showToast(`自定义域名复制成功: ${customUrl}`);
                }).catch(err => {
                    showToast('复制失败', 'error');
                });
            }
            break;
        case 'copyRepoGitHubLink':
            navigator.clipboard.writeText(repo.html_url).then(() => showToast('仓库链接已复制'));
            break;
        case 'createBranch':
            showCreateBranchModal(repo);
            break;

        case 'downloadRepoDirect':
            downloadRepoAsZip(repo, false);
            break;
        case 'renameRepo':
            showRenameModal(repo);
            break;
        case 'deleteRepo':
            showDeleteModal(null, false, '确认删除仓库', `确定要删除仓库 "${repo.name}" 吗？此操作不可撤销！`, async () => {
                try {
                    const res = await fetch(`https://api.github.com/repos/${repo.full_name}`, {
                        method: 'DELETE',
                        headers: { 'Authorization': `token ${state.token}` }
                    });

                    if (!res.ok) {
                        if (res.status === 403) {
                             throw new Error('权限不足，请确认令牌已勾选 delete_repo 权限');
                        }
                        throw new Error((await res.json()).message || '删除失败');
                    }
                    
                    showToast(`仓库 "${repo.name}" 已成功删除`);
                    
                    await fetchRepos(true, true);

                } catch (e) {
                    showToast(`删除失败: ${e.message}`, 'error');
                }
            });
            break;
    }
}

async function batchUnpublishSites() {
    const reposToUnpublish = state.repos.filter(r => r.has_pages && r.name !== `${state.user.login}.github.io`);

    if (reposToUnpublish.length === 0) {
        showToast('没有需要取消发布的网站。', 'info');
        return;
    }

    el.batchUnpublishAllBtn.disabled = true;
    el.batchUnpublishAllBtn.classList.add('btn-processing');

    let successCount = 0;
    
    for (const [index, repo] of reposToUnpublish.entries()) {
        showToast(`正在取消发布 (${index + 1}/${reposToUnpublish.length}): ${repo.name}`);
        const result = await unpublishSite(repo);
        if (result.success) {
            const repoInState = state.repos.find(r => r.id === repo.id);
            if (repoInState) {
                repoInState.has_pages = false;
            }
            successCount++;
        }
    }

    renderPublishManagerLists();

    el.batchUnpublishAllBtn.classList.remove('btn-processing');
    showToast(`批量取消发布完成！共处理 ${successCount} 个。`, 'success');
}

async function batchPublishSites() {
    const reposToPublish = state.repos.filter(r => !r.private && r.name !== `${state.user.login}.github.io` && !r.has_pages);

    if (reposToPublish.length === 0) {
        showToast('没有可发布的仓库。', 'info');
        return;
    }

    el.batchPublishAllBtn.disabled = true;
    el.batchPublishAllBtn.classList.add('btn-processing');
    
    let successCount = 0;
    let failCount = 0;

    for (const [index, repo] of reposToPublish.entries()) {
        showToast(`正在发布 (${index + 1}/${reposToPublish.length}): ${repo.name}`);
        const result = await publishProjectSite(repo);
        if (result.success) {
            const repoInState = state.repos.find(r => r.id === repo.id);
            if (repoInState) {
                repoInState.has_pages = true;
            }
            successCount++;
        } else {
            failCount++;
        }
    }
    
    renderPublishManagerLists();
    
    el.batchPublishAllBtn.classList.remove('btn-processing');
    showToast(`批量发布完成！成功 ${successCount} 个，失败 ${failCount} 个。`, 'success');
}

function findNextAvailableBackupName() {
    let maxNum = 0;
    const prefix = 'Github----';
    state.repos.forEach(repo => {
        if (repo.name.startsWith(prefix)) {
            const numPart = repo.name.substring(prefix.length);
            if (/^\d+$/.test(numPart)) {
                const num = parseInt(numPart, 10);
                if (num > maxNum) {
                    maxNum = num;
                }
            }
        }
    });
    return `${prefix}${maxNum + 1}`;
}

let repoToSetAsSite = null;
let branchToPublish = null;

function hideSetAsSiteModal() {
    el.setAsSiteModal.classList.add('hidden');
    repoToSetAsSite = null;
    branchToPublish = null;
    const index = uiStateStack.indexOf(hideSetAsSiteModal);
    if (index > -1) uiStateStack.splice(index, 1);
}






async function disablePages(repo) {
    try {
        // 使用 PATCH 更新仓库设置，这是禁用Pages更可靠的方法
        const res = await fetch(`https://api.github.com/repos/${repo.full_name}`, {
            method: 'PATCH',
            headers: {
                'Authorization': `token ${state.token}`,
                'Content-Type': 'application/json'
            },
            // 直接在仓库设置中关闭 has_pages 开关
            body: JSON.stringify({
                has_pages: false 
            })
        });

        if (!res.ok) {
            const errorData = await res.json().catch(() => ({}));
            const errorMessage = errorData.message || `禁用 Pages 失败 (HTTP ${res.status})`;
            throw new Error(errorMessage);
        }

        // 成功禁用后，立即更新本地缓存的仓库状态
        const repoInState = state.repos.find(r => r.id === repo.id);
        if (repoInState) {
            repoInState.has_pages = false;
        }

        return { success: true };

    } catch (error) {
        console.error(`禁用仓库 ${repo.name} 的 Pages 失败:`, error);
        // 将错误向上抛出，以便主流程能捕获并提示用户
        throw error;
    }
}




async function waitForRepoRename(oldRepoFullName, timeout = 30000) {
    const startTime = Date.now();
    const pollInterval = 2000;
    const [owner, oldRepoName] = oldRepoFullName.split('/');

    while (Date.now() - startTime < timeout) {
        await fetchRepos(true, false);
        const repoStillExists = state.repos.some(r => r.name === oldRepoName && r.owner.login === owner);
        if (!repoStillExists) {
            return true;
        }
        await new Promise(resolve => setTimeout(resolve, pollInterval));
    }
    throw new Error('等待旧主站重命名确认超时');
}



async function fetchSingleRepoState(repoFullName) {
    try {
        const res = await fetch(`https://api.github.com/repos/${repoFullName}`, {
            headers: { Authorization: `token ${state.token}`, 'User-Agent': 'Mozilla/5.0' },
            cache: 'no-store'
        });
        if (!res.ok) {
            throw new Error(`无法获取仓库信息: ${res.status}`);
        }
        return await res.json();
    } catch (error) {
        console.error(`获取仓库 ${repoFullName} 状态失败:`, error);
        showToast(`更新仓库 ${repoFullName.split('/')[1]} 状态失败`, 'error');
        return null;
    }
}

function updateSingleRepoInStateAndUI(updatedRepoObject) {
    if (!updatedRepoObject) return;

    const index = state.repos.findIndex(r => r.id === updatedRepoObject.id);
    if (index > -1) {
        const existingRepo = state.repos[index];
        updatedRepoObject.customDomain = existingRepo.customDomain;
        
        state.repos[index] = updatedRepoObject;
    } else {
        state.repos.unshift(updatedRepoObject);
    }
    
    localStorage.setItem('cached_repos', JSON.stringify(state.repos));
    
    if (!el.publishManagerModal.classList.contains('hidden')) {
        renderPublishManagerLists();
    }
    if (!el.repoList.classList.contains('hidden')) {
        
    }
}





async function showPublishBranchSelectorModal(repo, publishType) {
    repoToSetAsSite = repo;
    branchToPublish = repo.default_branch;

    const modalTitle = el.setAsSiteModal.querySelector('.modal-title-text');
    modalTitle.textContent = (publishType === 'mainSite') ? '发布主网站' : '发布项目网站';

    el.setAsSiteModal.classList.remove('hidden');
    uiStateStack.push(hideSetAsSiteModal);

    const selectorWrapper = document.getElementById('setAsSiteBranchSelector');
    const triggerText = selectorWrapper.querySelector('span');
    const optionsPanel = selectorWrapper.querySelector('.custom-branch-select-options');
    const confirmBtn = el.setAsSiteConfirmBtn;

    triggerText.textContent = '加载分支中...';
    optionsPanel.innerHTML = '';
    confirmBtn.disabled = true;

    try {
        const res = await fetch(`https://api.github.com/repos/${repo.full_name}/branches`, {
            headers: { Authorization: `token ${state.token}` }
        });
        if (!res.ok) throw new Error('获取分支列表失败');
        
        const branches = (await res.json()).reverse();
        if (branches.length === 0) {
            triggerText.textContent = '无可用分支';
            return;
        }

        confirmBtn.disabled = false;
        triggerText.textContent = branchToPublish;

        branches.forEach(branch => {
            const option = document.createElement('div');
            option.className = 'custom-branch-select-option';
            if (branch.name === branchToPublish) option.classList.add('selected');
            option.textContent = branch.name;
            option.dataset.branchName = branch.name;
            option.addEventListener('click', () => {
                branchToPublish = branch.name;
                triggerText.textContent = branch.name;
                const currentSelected = optionsPanel.querySelector('.selected');
                if (currentSelected) currentSelected.classList.remove('selected');
                option.classList.add('selected');
                selectorWrapper.classList.remove('open');
            });
            optionsPanel.appendChild(option);
        });
    } catch (error) {
        triggerText.textContent = '加载失败';
        showToast(error.message);
    }

    confirmBtn.onclick = async () => {
        const repoToProcess = repoToSetAsSite;
        const branchToUse = branchToPublish;
        if (!repoToProcess || !branchToUse) return;

        hideSetAsSiteModal();

        if (publishType === 'projectSite') {
            const buttonInManager = document.querySelector(`.project-action-btn[data-repo-fullname="${repoToProcess.full_name}"]`);
            if (buttonInManager) {
                buttonInManager.textContent = '处理中...';
                buttonInManager.disabled = true;
            }
            const result = await publishProjectSite(repoToProcess, branchToUse);
            showToast(result.message, result.success ? 'success' : 'error');
            if (result.success) {
                const repoInState = state.repos.find(r => r.id === repoToProcess.id);
                if (repoInState) repoInState.has_pages = true;
            }
            renderPublishManagerLists();
        } else if (publishType === 'mainSite') {
            const mainSiteButton = document.querySelector(`.set-as-main-site-btn[data-repo-fullname="${repoToProcess.full_name}"]`);
            if (mainSiteButton) {
                mainSiteButton.textContent = '处理中...';
                mainSiteButton.disabled = true;
            }
            
            el.mainLoader.classList.remove('hidden');
            const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));

            async function enablePagesWithRetry(repo, branch, maxAttempts = 2, delayBetweenAttempts = 4000) {
                for (let attempt = 1; attempt <= maxAttempts; attempt++) {
                    showToast(`正在配置网站页面`, 'info');
                    try {
                        const pagesRes = await fetch(`https://api.github.com/repos/${repo.full_name}/pages`, {
                            method: 'POST',
                            headers: { 'Authorization': `token ${state.token}`, 'Content-Type': 'application/json' },
                            body: JSON.stringify({ source: { branch: branch, path: "/" } })
                        });

                        if (pagesRes.ok || pagesRes.status === 409) {
                            return { success: true };
                        }
                        
                        const updateRes = await fetch(`https://api.github.com/repos/${repo.full_name}/pages`, {
                            method: 'PUT',
                            headers: { 'Authorization': `token ${state.token}`, 'Content-Type': 'application/json' },
                            body: JSON.stringify({ source: { branch: branch, path: "/" } })
                        });
                        
                        if (updateRes.ok) {
                            return { success: true };
                        }

                        if (attempt < maxAttempts) {
                            await delay(delayBetweenAttempts);
                            continue;
                        }
                        
                        throw new Error(`API错误: ${updateRes.status}`);

                    } catch (error) {
                        if (attempt >= maxAttempts) {
                            throw error;
                        }
                        await delay(delayBetweenAttempts);
                    }
                }
                 throw new Error('配置网站失败');
            }

            const MAX_SETUP_ATTEMPTS = 3;
            let finalError = null;

            for (let setupAttempt = 1; setupAttempt <= MAX_SETUP_ATTEMPTS; setupAttempt++) {
                try {
                    showToast(`正在设置主站 (第 ${setupAttempt}/${MAX_SETUP_ATTEMPTS} 次)`, 'info', 7000);
                    const mainSiteName = `${state.user.login}.github.io`;
                    await fetchRepos(true, false);
                    const existingMainSite = state.repos.find(r => r.name === mainSiteName);
                    
                    if (existingMainSite && existingMainSite.id !== repoToProcess.id) {
                        if (existingMainSite.has_pages) {
                            await disablePages(existingMainSite);
                        }
                        const backupName = findNextAvailableBackupName();
                        await fetch(`https://api.github.com/repos/${existingMainSite.full_name}`, {
                            method: 'PATCH', headers: { 'Authorization': `token ${state.token}`, 'Content-Type': 'application/json' },
                            body: JSON.stringify({ name: backupName })
                        });
                    }
                    
                    if (repoToProcess.name !== mainSiteName) {
                        await fetch(`https://api.github.com/repos/${repoToProcess.full_name}`, {
                            method: 'PATCH', headers: { 'Authorization': `token ${state.token}`, 'Content-Type': 'application/json' },
                            body: JSON.stringify({ name: mainSiteName })
                        });
                    }
                    
                    await delay(6000);
                    await fetchRepos(true, false);
                    const finalRepoToPublish = state.repos.find(r => r.name === mainSiteName);

                    if (!finalRepoToPublish) {
                         throw new Error('主站信息同步失败');
                    }
                    
                    const result = await enablePagesWithRetry(finalRepoToPublish, branchToUse);

                    if (!result.success) {
                        throw new Error('配置网站失败，请稍后在GitHub官网手动开启Pages');
                    }

                    showToast('主站发布成功！', 'success');
                    await delay(2000);
                    finalError = null;
                    break;

                } catch (e) {
                    finalError = e;
                    if (setupAttempt < MAX_SETUP_ATTEMPTS) {
                        showToast(`${e.message}，自动重试中`, 'info');
                        await delay(1000);
                    }
                }
            }

            if (finalError) {
                 showToast(`操作最终失败: ${finalError.message}，请手动重试`, 'error');
                 if (mainSiteButton) {
                     mainSiteButton.textContent = '发布为主站';
                     mainSiteButton.disabled = false;
                 }
            }
            
            await fetchRepos(true, false);
            el.mainLoader.classList.add('hidden');
            renderPublishManagerLists();
        }
    };
}





function downloadRepoAsZip(repo) {
    const zipRaw = `https://github.com/${repo.full_name}/archive/refs/heads/${repo.default_branch || 'main'}.zip`;
    let zipUrl = zipRaw;
    let viaProxy = false;

    if (state.proxyGlobalEnable && state.proxies.length > 0 && state.activeProxyIndex !== -1) {
        const activeProxy = state.proxies[state.activeProxyIndex];
        if (activeProxy && activeProxy.url && activeProxy.type) {
            if (activeProxy.type === 'prefix') {
                let proxyBase = activeProxy.url;
                if (!proxyBase.endsWith('/')) {
                    proxyBase += '/';
                }
                zipUrl = proxyBase + zipRaw;
                viaProxy = true;
            } else if (activeProxy.type === 'raw_domain_replace') {
                try {
                    const proxyDomain = getDomainFromUrl(activeProxy.url);
                    if (proxyDomain) {
                        const originalUrl = new URL(zipRaw);
                        originalUrl.hostname = proxyDomain;
                        zipUrl = originalUrl.toString();
                        viaProxy = true;
                    }
                } catch (e) {
                    console.error("域名替换失败:", e);
                }
            }
        }
    }

    const a = document.createElement('a');
    a.href = zipUrl;
    a.download = `${repo.name}.zip`;
    a.classList.add('hidden');
    document.body.appendChild(a);
    a.click();
    setTimeout(() => document.body.removeChild(a), 500);
    showToast(`正在使用${viaProxy ? '代理' : '直连'}下载 ${repo.name}.zip `);

}


let uploadClickTimer = null;
let uploadClickCount = 0;

function handleUploadClick() {
    if (!state.currentRepo) {
        showToast('请先选择仓库');
        return;
    }
    showPreUploadModal();
}

function handleFilesSelected(e) {
    const files = Array.from(e.target.files || []);
    if (files.length === 0) return;

    // 统一逻辑：只添加到暂存区，不立即上传
    state.pendingUploadFiles = [...state.pendingUploadFiles, ...files];
    renderPreUploadList();
    
    // 如果面板没打开，打开它
    if (el.preUploadModal.classList.contains('hidden')) {
        showPreUploadModal();
    }
    
    e.target.value = ''; 
}


async function uploadReleaseAssets(files) {
    if (!state.currentRelease || !state.viewingReleasesForRepo) return;
    
    const releaseId = state.currentRelease.id;
    const [owner, repo] = state.viewingReleasesForRepo.split('/');
    
    showToast(`准备上传 ${files.length} 个文件到版本 ${state.currentRelease.tag_name}...`);

    for (const file of files) {
        try {
            showToast(`正在上传: ${file.name} ...`, 'info', 5000);
            
            const uploadUrl = `https://uploads.github.com/repos/${owner}/${repo}/releases/${releaseId}/assets?name=${encodeURIComponent(file.name)}`;
            
            const res = await fetch(uploadUrl, {
                method: 'POST',
                headers: {
                    'Authorization': `token ${state.token}`,
                    'Content-Type': file.type || 'application/octet-stream'
                },
                body: file
            });

            if (!res.ok) {
                if (res.status === 422) {
                    throw new Error('文件可能已存在或格式不支持');
                }
                throw new Error(`HTTP ${res.status}`);
            }

            showToast(`${file.name} 上传成功!`, 'success');
        } catch (e) {
            console.error(e);
            showToast(`上传 ${file.name} 失败: ${e.message}`, 'error');
        }
    }

    await refreshAssetsList();
}

// --- 新增：显示上传面板 ---
function showPreUploadModal() {
    // 每次打开不自动清空，保留上次未上传的？还是清空？这里设为不清空，如果为空则显示空状态
    renderPreUploadList();
    el.preUploadModal.classList.remove('hidden');
    uiStateStack.push(hidePreUploadModal);
}

function hidePreUploadModal() {
    el.preUploadModal.classList.add('hidden');
    const index = uiStateStack.indexOf(hidePreUploadModal);
    if (index > -1) uiStateStack.splice(index, 1);
    
    state.pendingUploadFiles = [];
    renderPreUploadList();
}

// --- 新增：渲染待上传列表 ---
function renderPreUploadList() {
    const container = el.preUploadList;
    container.innerHTML = '';

    if (state.pendingUploadFiles.length === 0) {
        container.innerHTML = `
            <div class="empty-state" style="padding: 20px; text-align: center; color: #9ca3af;">
                <i class="fa fa-cloud-upload" style="font-size: 2rem; margin-bottom: 10px;"></i>
                <p style="font-size: 0.8rem;">暂无待上传文件</p>
            </div>`;
        el.preUploadStartBtn.disabled = true;
        return;
    }

    el.preUploadStartBtn.disabled = false;

    state.pendingUploadFiles.forEach((file, index) => {
        const div = document.createElement('div');
        div.className = 'pre-upload-item';
        div.innerHTML = `
            <span class="pre-upload-name" title="${file.name}">${file.name}</span>
            <div style="display:flex; align-items:center;">
                <span class="pre-upload-size">${formatSize(file.size)}</span>
                <button class="btn-icon-sm danger remove-pending-btn" data-index="${index}">
                    <i class="fa fa-times"></i>
                </button>
            </div>
        `;
        container.appendChild(div);
    });

    // 绑定删除按钮事件
    container.querySelectorAll('.remove-pending-btn').forEach(btn => {
        btn.onclick = (e) => {
            const idx = parseInt(e.currentTarget.dataset.index);
            state.pendingUploadFiles.splice(idx, 1);
            renderPreUploadList();
        };
    });
}

function handleStartBatchUpload() {
    if (state.pendingUploadFiles.length === 0) return;

    const filesToUpload = [...state.pendingUploadFiles];
    
    hidePreUploadModal();
    state.pendingUploadFiles = []; // 清空暂存区

    // 打开进度面板
    el.uploadPanel.classList.remove('hidden');
    el.uploadItems.innerHTML = '';

    // 渲染进度条 UI
    filesToUpload.forEach((file, index) => {
        let displayName = file.name;
        if (displayName.length > 25) {
            displayName = displayName.slice(0, 22) + '...';
        }
        const uploadItem = document.createElement('div');
        uploadItem.className = 'upload-item';
        uploadItem.innerHTML = `
            <div class="upload-info">
                <span class="upload-name" title="${file.name}">${displayName}</span>
                <span class="upload-size">${formatSize(file.size)}</span>
            </div>
            <div class="upload-progress-container">
                <div class="upload-progress" data-index="${index}">
                    <span class="percent-text" data-index="${index}">0%</span>
                </div>
            </div>
            <div class="upload-status" data-index="${index}">等待上传...</div>
        `;
        el.uploadItems.appendChild(uploadItem);
    });

    // === 核心修复 ===
    // 强制检查当前视图。如果是 assets_list (版本详情)，走版本上传通道
    if (state.currentView === 'assets_list') {
        uploadReleaseAssetsInSequence(filesToUpload, 0);
    } else {
        // 否则走普通文件上传通道
        uploadFilesInSequence(filesToUpload, 0);
    }
}


async function uploadReleaseAssetsInSequence(files, index) {
    if (index >= files.length) {
        setTimeout(() => {
            el.uploadPanel.classList.add('hidden');
        }, 500);
        await refreshAssetsList();
        return;
    }

    const file = files[index];
    try {
        await uploadSingleReleaseAsset(file, index);
    } catch (error) {
        console.error(error);
    }
    
    await uploadReleaseAssetsInSequence(files, index + 1);
}

async function uploadSingleReleaseAsset(file, index) {
    return new Promise((resolve, reject) => {
        const progressBar = document.querySelector(`.upload-progress[data-index="${index}"]`);
        const statusElement = document.querySelector(`.upload-status[data-index="${index}"]`);
        const percentTextEl = progressBar ? progressBar.querySelector(`.percent-text[data-index="${index}"]`) : null;

        // 1. 基础校验
        if (!state.currentRelease) {
            if (statusElement) {
                statusElement.textContent = '错误：无版本信息';
                statusElement.className = 'upload-status error';
            }
            resolve();
            return;
        }

        if (file.size === 0) {
            if (statusElement) {
                statusElement.textContent = '错误：空文件';
                statusElement.className = 'upload-status error';
            }
            resolve();
            return;
        }

        if (statusElement) statusElement.textContent = '读取文件中...';

        // 2. 使用 FileReader 读取文件流 (解决跨域和文件占用问题)
        const reader = new FileReader();
        
        reader.onload = function(e) {
            // 文件读取成功，开始上传
            const arrayBuffer = e.target.result;
            
            // 3. 构建 URL (手动拼接最稳妥)
            let uploadUrl = '';
            try {
                const rawUrl = state.currentRelease.upload_url.split('{')[0];
                // 使用 encodeURIComponent 确保中文文件名不报错
                uploadUrl = `${rawUrl}?name=${encodeURIComponent(file.name)}`;
            } catch (err) {
                if (statusElement) statusElement.textContent = 'URL生成失败';
                resolve();
                return;
            }

            if (statusElement) statusElement.textContent = '开始传输...';

            const xhr = new XMLHttpRequest();
            xhr.open('POST', uploadUrl, true);

            // 4. 设置关键请求头
            xhr.setRequestHeader('Authorization', `token ${state.token}`);
            xhr.setRequestHeader('Content-Type', file.type || 'application/octet-stream');
            // 加上 Accept 头，防止 GitHub API 拒绝
            xhr.setRequestHeader('Accept', 'application/vnd.github.v3+json');

            // 5. 监听进度
            xhr.upload.onprogress = (evt) => {
                if (evt.lengthComputable) {
                    const percentComplete = Math.round((evt.loaded / evt.total) * 100);
                    if (progressBar) progressBar.style.width = `${percentComplete}%`;
                    if (percentTextEl) percentTextEl.textContent = `${percentComplete}%`;
                    
                    if (statusElement) {
                        statusElement.textContent = percentComplete < 100 ? `上传中 ${percentComplete}%` : '服务器处理中...';
                    }
                }
            };

            // 6. 请求完成处理
            xhr.onload = () => {
                if (xhr.status >= 200 && xhr.status < 300) {
                    if (progressBar) progressBar.style.width = '100%';
                    if (percentTextEl) percentTextEl.textContent = '100%';
                    if (statusElement) {
                        statusElement.textContent = '上传成功';
                        statusElement.className = 'upload-status success';
                    }
                    // 成功后延迟移除 UI
                    setTimeout(() => {
                        const itemContainer = statusElement ? statusElement.closest('.upload-item') : null;
                        if (itemContainer) {
                            itemContainer.style.transition = 'opacity 0.5s ease';
                            itemContainer.style.opacity = '0';
                            setTimeout(() => itemContainer.remove(), 500);
                        }
                    }, 1000);
                    resolve();
                } else {
                    // 解析错误信息
                    let errorMsg = `HTTP ${xhr.status}`;
                    try {
                        const json = JSON.parse(xhr.responseText);
                        if (json.errors && json.errors[0]?.code === 'already_exists') {
                            errorMsg = '文件已存在';
                        } else if (json.message) {
                            errorMsg = json.message;
                        }
                    } catch (ignore) {
                        if (xhr.responseText && xhr.responseText.length < 100) errorMsg = xhr.responseText;
                    }
                    
                    if (statusElement) {
                        statusElement.textContent = errorMsg;
                        statusElement.className = 'upload-status error';
                        statusElement.title = errorMsg;
                        if (progressBar) progressBar.style.backgroundColor = '#ef4444';
                    }
                    resolve();
                }
            };

            // 7. 网络错误处理
            xhr.onerror = () => {
                if (statusElement) {
                    statusElement.textContent = '网络中断';
                    statusElement.className = 'upload-status error';
                    statusElement.title = '无法连接到 GitHub 上传服务器，请检查网络或 VPN';
                    if (progressBar) progressBar.style.backgroundColor = '#ef4444';
                }
                resolve();
            };

            // 发送 ArrayBuffer 二进制数据
            xhr.send(arrayBuffer);
        };

        reader.onerror = function() {
            if (statusElement) {
                statusElement.textContent = '读取文件失败';
                statusElement.className = 'upload-status error';
            }
            resolve();
        };

        // 开始读取文件
        reader.readAsArrayBuffer(file);
    });
}
async function uploadSingleFile(file, index) {
    const MAX_FILE_SIZE_BYTES = 100 * 1024 * 1024;
    return new Promise(async (resolve, reject) => {
        const progressBar = document.querySelector(`.upload-progress[data-index="${index}"]`);
        const statusElement = document.querySelector(`.upload-status[data-index="${index}"]`);
        const percentTextEl = progressBar ? progressBar.querySelector(`.percent-text[data-index="${index}"]`) : null;
        if (file.size > MAX_FILE_SIZE_BYTES) {
            if (statusElement) {
                statusElement.textContent = `文件过大 (限制100MB)`;
                statusElement.className = 'upload-status error';
            }
            showToast(`文件 "${file.name}" 超过100MB官方限制`);
            reject(new Error('文件过大'));
            return;
        }
        if (statusElement) statusElement.textContent = '正在上传...';
        const reader = new FileReader();
        reader.readAsArrayBuffer(file);
        reader.onload = async (e) => {
            let progress = 0;
            let progressInterval = null;
            const [owner, repo] = state.currentRepo.split('/');
            const fileName = file.name;
            const filePath = state.currentPath ? `${state.currentPath}${fileName}` : fileName;
            const verifyUpload = async () => {
                if (statusElement) statusElement.textContent = '上传超时，正在验证...';
                try {
                    await new Promise(res => setTimeout(res, 2000));
                    const verifyUrl = `https://api.github.com/repos/${owner}/${repo}/contents/${filePath}?ref=${state.currentBranch}&t=${Date.now()}`;
                    const verifyRes = await fetch(verifyUrl, {
                        headers: { 'Authorization': `token ${state.token}`, 'User-Agent': 'Mozilla/5.0' }
                    });
                    if (verifyRes.ok) {
                        return true;
                    }
                    return false;
                } catch (verifyError) {
                    return false;
                }
            };
            try {
                progressInterval = setInterval(() => {
                    if (progress < 95) {
                        progress += 1;
                        if (progressBar) progressBar.style.width = `${progress}%`;
                        if (percentTextEl) percentTextEl.textContent = `${progress}%`;
                    }
                }, 100);
                const base64String = arrayBufferToBase64(e.target.result);
                if (!state || !state.currentRepo) throw new Error('未选择仓库');
                let existingFileSha = null;
                try {
                    const checkUrl = `https://api.github.com/repos/${owner}/${repo}/contents/${filePath}?ref=${state.currentBranch}`;
                    const checkRes = await fetch(checkUrl, { headers: { 'Authorization': `token ${state.token}`, 'User-Agent': 'Mozilla/5.0' } });
                    if (checkRes.ok) existingFileSha = (await checkRes.json()).sha;
                } catch (e) { console.warn(`无法获取文件SHA: ${e.message}`); }
                const requestBody = {
                    message: `Upload ${fileName}`,
                    content: base64String,
                    branch: state.currentBranch
                };
                if (existingFileSha) requestBody.sha = existingFileSha;
                const response = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${filePath}`, {
                    method: 'PUT',
                    headers: { 'Authorization': `token ${state.token}`, 'Content-Type': 'application/json', 'User-Agent': 'Mozilla/5.0' },
                    body: JSON.stringify(requestBody),
                    signal: AbortSignal.timeout(300000)
                });
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.message || `上传失败: HTTP ${response.status}`);
                }
                clearInterval(progressInterval);
                progress = 100;
                if (progressBar) progressBar.style.width = '100%';
                if (percentTextEl) percentTextEl.textContent = '100%';
                if (statusElement) {
                    statusElement.textContent = '上传成功';
                    statusElement.className = 'upload-status success';
                }
                resolve();
            } catch (error) {
                let isVerifiedSuccess = false;
                if (error.name === 'AbortError' || error.message.includes('Failed to fetch')) {
                    isVerifiedSuccess = await verifyUpload();
                }
                if (isVerifiedSuccess) {
                    if (statusElement) {
                        statusElement.textContent = '上传成功 (已验证)';
                        statusElement.className = 'upload-status success';
                    }
                    resolve();
                } else {
                    if (statusElement) {
                        statusElement.textContent = '上传失败';
                        statusElement.className = 'upload-status error';
                    }
                    reject(new Error(`上传失败: ${error.message}`));
                }
            } finally {
                if (progressInterval) clearInterval(progressInterval);
                const itemContainer = statusElement ? statusElement.closest('.upload-item') : null;
                if (itemContainer && statusElement.classList.contains('success')) {
                    setTimeout(() => {
                        itemContainer.style.transition = 'opacity 0.5s, height 0.5s, margin 0.5s, padding 0.5s';
                        itemContainer.style.opacity = '0';
                        itemContainer.style.height = '0';
                        itemContainer.style.margin = '0';
                        itemContainer.style.padding = '0';
                        itemContainer.style.overflow = 'hidden';
                        setTimeout(() => itemContainer.remove(), 500);
                    }, 1500);
                }
            }
        };
        reader.onerror = () => {
            if (statusElement) {
                statusElement.textContent = '文件读取失败';
                statusElement.className = 'upload-status error';
            }
            reject(new Error('文件读取失败'));
        };
    });
}

function arrayBufferToBase64(buffer) {
    let binary = '';
    const bytes = new Uint8Array(buffer);
    const len = bytes.byteLength;
    for (let i = 0; i < len; i++) {
        binary += String.fromCharCode(bytes[i]);
    }
    return btoa(binary);
}

async function renameWithGitDataAPI(item, newName) {
    const [owner, repo] = state.currentRepo.split('/');
    const oldPath = item.path;
    const newPath = oldPath.substring(0, oldPath.lastIndexOf('/') + 1) + newName;
    const refResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/git/refs/heads/${state.currentBranch}`, {
        headers: { 'Authorization': `token ${state.token}` }
    });
    if (!refResponse.ok) throw new Error('无法获取分支信息');
    const refData = await refResponse.json();
    const latestCommitSha = refData.object.sha;
    const commitResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/git/commits/${latestCommitSha}`, {
        headers: { 'Authorization': `token ${state.token}` }
    });
    if (!commitResponse.ok) throw new Error('无法获取提交信息');
    const commitData = await commitResponse.json();
    const baseTreeSha = commitData.tree.sha;
    const createTreeResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/git/trees`, {
        method: 'POST',
        headers: { 'Authorization': `token ${state.token}`, 'Content-Type': 'application/json' },
        body: JSON.stringify({
            base_tree: baseTreeSha,
            tree: [
                { path: newPath, mode: '100644', type: 'blob', sha: item.sha },
                { path: oldPath, mode: '100644', type: 'blob', sha: null }
            ]
        })
    });
    if (!createTreeResponse.ok) throw new Error('创建新目录树失败');
    const treeData = await createTreeResponse.json();
    const newTreeSha = treeData.sha;
    const createCommitResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/git/commits`, {
        method: 'POST',
        headers: { 'Authorization': `token ${state.token}`, 'Content-Type': 'application/json' },
        body: JSON.stringify({
            message: `Rename ${item.name} to ${newName}`,
            tree: newTreeSha,
            parents: [latestCommitSha]
        })
    });
    if (!createCommitResponse.ok) throw new Error('创建新提交失败');
    const newCommitData = await createCommitResponse.json();
    const newCommitSha = newCommitData.sha;
    const updateRefResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/git/refs/heads/${state.currentBranch}`, {
        method: 'PATCH',
        headers: { 'Authorization': `token ${state.token}`, 'Content-Type': 'application/json' },
        body: JSON.stringify({ sha: newCommitSha })
    });
    if (!updateRefResponse.ok) throw new Error('更新分支引用失败');
}

async function renameFolderWithGitDataAPI(item, newName) {
    const [owner, repo] = state.currentRepo.split('/');
    const oldPath = item.path;
    const newPath = oldPath.substring(0, oldPath.lastIndexOf('/') + 1) + newName;
    const refResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/git/refs/heads/${state.currentBranch}`, {
        headers: { 'Authorization': `token ${state.token}` }
    });
    if (!refResponse.ok) throw new Error('无法获取分支信息');
    const refData = await refResponse.json();
    const latestCommitSha = refData.object.sha;
    const commitResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/git/commits/${latestCommitSha}`, {
        headers: { 'Authorization': `token ${state.token}` }
    });
    if (!commitResponse.ok) throw new Error('无法获取提交信息');
    const commitData = await commitResponse.json();
    const baseTreeSha = commitData.tree.sha;
    const createTreeResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/git/trees`, {
        method: 'POST',
        headers: { 'Authorization': `token ${state.token}`, 'Content-Type': 'application/json' },
        body: JSON.stringify({
            base_tree: baseTreeSha,
            tree: [
                { path: newPath, mode: '040000', type: 'tree', sha: item.sha },
                { path: oldPath, mode: '040000', type: 'tree', sha: null }
            ]
        })
    });
    if (!createTreeResponse.ok) throw new Error('创建新目录树失败');
    const treeData = await createTreeResponse.json();
    const newTreeSha = treeData.sha;
    const createCommitResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/git/commits`, {
        method: 'POST',
        headers: { 'Authorization': `token ${state.token}`, 'Content-Type': 'application/json' },
        body: JSON.stringify({
            message: `Rename ${item.name} to ${newName}`,
            tree: newTreeSha,
            parents: [latestCommitSha]
        })
    });
    if (!createCommitResponse.ok) throw new Error('创建新提交失败');
    const newCommitData = await createCommitResponse.json();
    const newCommitSha = newCommitData.sha;
    const updateRefResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/git/refs/heads/${state.currentBranch}`, {
        method: 'PATCH',
        headers: { 'Authorization': `token ${state.token}`, 'Content-Type': 'application/json' },
        body: JSON.stringify({ sha: newCommitSha })
    });
    if (!updateRefResponse.ok) throw new Error('更新分支引用失败');
}









function showUnpublishMainSiteModal(repo) {
    const extraSettingsContainer = document.getElementById('renameModalExtraSettings');
    extraSettingsContainer.innerHTML = ''; 

    el.renameTitle.querySelector('.modal-title-text').textContent = '取消发布主网站';

    el.renameWarn.innerHTML = '此操作会先禁用网站的静态页面配置，然后将仓库重命名，从而安全地下线。您的所有文件都会被保留。';
    el.renameWarn.classList.remove('text-red-400');
    el.renameWarn.style.color = '';
    el.renameWarn.style.fontSize = '0.7rem';
    el.renameWarn.style.marginBottom = '0.6rem';
    el.renameWarn.style.display = 'block';

    el.renameInput.value = '';
    el.renameInput.placeholder = '请输入新的仓库名';
    
    el.renameConfirm.disabled = true;
    el.renameModal.classList.remove('hidden');

    el.renameInput.oninput = function() {
        const newName = el.renameInput.value.trim();
        el.renameConfirm.disabled = !newName || newName === repo.name;
    };

    el.renameConfirm.onclick = async function() {
        const newName = el.renameInput.value.trim();
        if (!newName) return;

        this.disabled = true;
        this.classList.add('btn-processing');
        this.innerHTML = '处理中 <i class="fa fa-spinner fa-spin"></i>';

        try {
            showToast('步骤1/2: 正在禁用静态页面配置...');
            await disablePages(repo);
            
            showToast('步骤2/2: 正在重命名仓库以完成下线...');
            const res = await fetch(`https://api.github.com/repos/${repo.full_name}`, {
                method: 'PATCH',
                headers: { 'Authorization': `token ${state.token}`, 'Content-Type': 'application/json' },
                body: JSON.stringify({ name: newName })
            });
            if (!res.ok) throw new Error((await res.json()).message || '重命名失败');
            
            showToast('主网站已成功下线');
            hideRenameModal();
            await fetchRepos(true, false);
            renderPublishManagerLists();

        } catch (e) {
            showToast(`操作失败: ${e.message}`, 'error');
        } finally {
            this.disabled = false;
            this.classList.remove('btn-processing');
            this.innerHTML = '确认';
        }
    };

    uiStateStack.push(hideRenameModal);
}


function showRenameModal(item) {
    const isRepo = typeof item.full_name === 'string';
    const extraSettingsContainer = document.getElementById('renameModalExtraSettings');
    extraSettingsContainer.innerHTML = ''; 

    if (isRepo) {
        el.renameTitle.querySelector('.modal-title-text').textContent = `修改仓库`;
        
        const repo = item; 
        const mainSiteName = state.user ? `${state.user.login}.github.io` : null;
        const settingsHTML = `
            <textarea id="newRepoDesc" placeholder="仓库描述（可选）" style="margin-top: 0.6rem;">${repo.description || ''}</textarea>
            <div class="checkbox-container" style="margin: 0.6rem 0;">
                <input type="checkbox" id="newRepoPrivate">
                <label for="newRepoPrivate">公开仓库</label>
            </div>
        `;
        extraSettingsContainer.innerHTML = settingsHTML;

        const descTextarea = document.getElementById('newRepoDesc');
        const privateCheckbox = document.getElementById('newRepoPrivate');
        el.renameInput.value = repo.name;
        privateCheckbox.checked = !repo.private;
        
        function autoGrow(element) {
            element.style.height = 'auto';
            element.style.height = (element.scrollHeight) + 'px';
        }
        descTextarea.addEventListener('input', () => autoGrow(descTextarea));
        autoGrow(descTextarea);
        
        const updateButtonState = () => {
            const newName = el.renameInput.value.trim();
            const newDesc = descTextarea.value.trim();
            el.renameWarn.style.display = 'none';
            el.renameWarn.classList.remove('text-red-400', 'text-orange-400');
            if (mainSiteName) {
                if (repo.name === mainSiteName && newName !== mainSiteName) {
                    el.renameWarn.textContent = '提示：重命名主站仓库将导致您的主网站下线。';
                    el.renameWarn.classList.add('text-orange-400');
                    el.renameWarn.style.display = 'block';
                } else if (repo.name !== mainSiteName && newName === mainSiteName) {
                    el.renameWarn.textContent = '提示：手动命名为主站仓库不会自动发布网站。推荐使用“设为主站”功能。';
                    el.renameWarn.classList.add('text-orange-400');
                    el.renameWarn.style.display = 'block';
                }
            }
            const nameChanged = newName !== repo.name;
            const descChanged = newDesc !== (repo.description || '');
            const visibilityChanged = privateCheckbox.checked === repo.private;
            const isModified = nameChanged || descChanged || visibilityChanged;
            el.renameConfirm.disabled = !isModified || !newName;
        };

        el.renameInput.oninput = updateButtonState;
        descTextarea.oninput = updateButtonState;
        privateCheckbox.onchange = updateButtonState;
        updateButtonState();

        el.renameConfirm.onclick = async function() {
            const newName = el.renameInput.value.trim();
            const newDesc = descTextarea.value.trim();
            const isPrivate = !privateCheckbox.checked;
            const requestBody = { name: newName, description: newDesc, private: isPrivate };
            this.disabled = true;
            this.classList.add('btn-processing');
            this.innerHTML = '处理中 <i class="fa fa-spinner fa-spin"></i>';
            try {
                const res = await fetch(`https://api.github.com/repos/${repo.full_name}`, {
                    method: 'PATCH',
                    headers: { 'Authorization': `token ${state.token}`, 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });
                if (!res.ok) throw new Error((await res.json()).message || '修改失败');
                state.shouldAnimateList = true;
                showToast(`保存成功`);
                hideRenameModal();
                await fetchRepos(true, true);
            } catch (e) {
                showToast(`修改失败: ${e.message}`, 'error');
            } finally {
                this.disabled = false;
                this.classList.remove('btn-processing');
                this.innerHTML = '确认';
            }
        };

    } else {
        let itemTypeText = '文件';
        if (item.type === 'dir') { itemTypeText = '文件夹'; } 
        else if (item.type === 'branch') { itemTypeText = '分支'; }
        el.renameTitle.querySelector('.modal-title-text').textContent = `重命名${itemTypeText}`;
        el.renameInput.value = item.name;
        el.renameWarn.style.display = 'none';
        el.renameWarn.textContent = '';
        el.renameConfirm.disabled = true;

        el.renameInput.oninput = function() {
            const newName = el.renameInput.value.trim();
            el.renameConfirm.disabled = !newName || newName === item.name;
        };
        
        el.renameInput.dispatchEvent(new Event('input'));

        el.renameConfirm.onclick = async function() {
        const v = el.renameInput.value.trim();
        if (!v || v === item.name) return;
        
        this.disabled = true;
        this.classList.add('btn-processing');
        this.innerHTML = '处理中 <i class="fa fa-spinner fa-spin"></i>';
        
        try {
            if (item.type === 'branch') {
                // === 分支重命名 (保持原有逻辑) ===
                const repo = item.repo;
                const oldBranchName = item.name;
                const newBranchName = v;
                const res = await fetch(`https://api.github.com/repos/${repo.full_name}/branches/${oldBranchName}/rename`, { 
                    method: 'POST', 
                    headers: { 'Authorization': `token ${state.token}`, 'Content-Type': 'application/json' }, 
                    body: JSON.stringify({ new_name: newBranchName }) 
                });
                
                if (!res.ok) { 
                    const errorData = await res.json(); 
                    throw new Error(errorData.message || '重命名分支失败'); 
                }
                
                showToast(`分支已重命名为: ${v}`);
                hideRenameModal(); // 立即关闭弹窗
                hideCreateBranchModal();
                fetchRepos(true); // 分支需要刷新仓库信息
                
            } else {
                // === 文件/文件夹 重命名【深度修复版】 ===
                const isDir = item.type === 'dir';
                const ONE_MB = 1024 * 1024;
                const [owner, repo] = state.currentRepo.split('/');
                const oldPath = item.path;
                // 计算新路径：截取父路径 + 新名字
                // 例如 A/B/oldFolder -> A/B/ + newFolder
                const lastSlashIndex = oldPath.lastIndexOf(item.name);
                const parentPath = lastSlashIndex > -1 ? oldPath.substring(0, lastSlashIndex) : '';
                const newPath = parentPath + v;

                // 1. 执行 GitHub API 操作
                if (isDir) {
                    await renameFolderWithGitDataAPI(item, v);
                } else {
                    if (item.size > ONE_MB) {
                        await renameWithGitDataAPI(item, v);
                    } else {
                        // 小文件：复制 + 删除
                        const d = await (await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${oldPath}?ref=${state.currentBranch}`, { 
                            headers: { Authorization: `token ${state.token}` } 
                        })).json();
                        
                        await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${newPath}`, { 
                            method: 'PUT', 
                            headers: { Authorization: `token ${state.token}`, 'Content-Type': 'application/json' }, 
                            body: JSON.stringify({ message: `Rename to ${v}`, content: d.content, sha: d.sha, branch: state.currentBranch }) 
                        });
                        
                        await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${oldPath}`, { 
                            method: 'DELETE', 
                            headers: { Authorization: `token ${state.token}`, 'Content-Type': 'application/json' }, 
                            body: JSON.stringify({ message: `Delete old file`, sha: d.sha, branch: state.currentBranch }) 
                        });
                    }
                }

                // 2. 深度乐观更新：修补当前列表视图 (state.files)
                const fileIndex = state.files.findIndex(f => f.path === item.path);
                if (fileIndex !== -1) {
                    state.files[fileIndex].name = v;
                    state.files[fileIndex].path = newPath;
                    // 同时修正 html_url，防止右键菜单链接失效
                    if (state.files[fileIndex].html_url) {
                        state.files[fileIndex].html_url = state.files[fileIndex].html_url.replace(encodeURIComponent(item.name), encodeURIComponent(v));
                    }
                }

                // 3. 【关键】修补全量目录树缓存 (state.repoTreeCache)
                // 这步至关重要：它防止了进入文件夹或返回时，应用从缓存中读取到旧的路径
                if (state.repoTreeCache) {
                    const oldPrefix = oldPath + '/';
                    const newPrefix = newPath + '/';
                    
                    state.repoTreeCache.forEach(node => {
                        // 情况A: 就是该文件/文件夹本身
                        if (node.path === oldPath) {
                            node.path = newPath;
                        } 
                        // 情况B: 是该文件夹下的子内容 (重命名文件夹的情况)
                        else if (node.path.startsWith(oldPrefix)) {
                            // 替换路径前缀： A/Old/File.txt -> A/New/File.txt
                            node.path = newPrefix + node.path.substring(oldPrefix.length);
                        }
                    });
                }

                // 4. 【关键】迁移子文件夹缓存 (state.fileCache)
                // 将旧文件夹下的缓存数据搬家到新路径，防止进入新文件夹时重新请求网络(导致404)
                if (isDir) {
                    const cacheKeyPrefix = `${state.currentRepo}:${state.currentBranch}:`;
                    const oldKeyStart = cacheKeyPrefix + oldPath + '/';
                    const newKeyStart = cacheKeyPrefix + newPath + '/';
                    
                    // 找出所有属于旧文件夹的缓存Key
                    const keysToMigrate = [];
                    for (const key of state.fileCache.keys()) {
                        if (key.startsWith(oldKeyStart)) {
                            keysToMigrate.push(key);
                        }
                    }
                    
                    // 执行迁移
                    keysToMigrate.forEach(oldKey => {
                        const data = state.fileCache.get(oldKey);
                        const suffix = oldKey.substring(oldKeyStart.length);
                        const newKey = newKeyStart + suffix;
                        
                        // 同时也需要更新缓存数据内部的 path 属性
                        const updatedData = data.map(f => {
                            const fOldPrefix = oldPath + '/';
                            const fNewPrefix = newPath + '/';
                            if (f.path.startsWith(fOldPrefix)) {
                                return { 
                                    ...f, 
                                    path: fNewPrefix + f.path.substring(fOldPrefix.length) 
                                };
                            }
                            return f;
                        });
                        
                        state.fileCache.set(newKey, updatedData);
                        state.fileCache.delete(oldKey); // 删除旧缓存
                    });
                }

                // 5. 更新当前目录的缓存
                // 确保按下“返回”再进来时，看到的是新名字
                const currentDirKey = `${state.currentRepo}:${state.currentBranch}:${state.currentPath}`;
                state.fileCache.set(currentDirKey, [...state.files]);

                // 6. UI清理与重绘
                hideRenameModal(); // 先关闭弹窗，避免占用返回栈
                applyFiltersAndSort();
                renderFileList();
                
                showToast(`重命名成功: ${v}`);
                
                // 强制修正返回栈问题：确保弹窗逻辑完全结束后再允许交互
                // 我们不再调用 fetchFiles(true)，完全信任本地修补的数据
            }
        } catch (e) {
            showToast(`失败: ${e.message}`, 'error');
        } finally {
            // 恢复按钮状态
            if (document.body.contains(this)) {
                this.disabled = false;
                this.classList.remove('btn-processing');
                this.innerHTML = '确认';
            }
        }
    };
    }
    
    el.renameModal.classList.remove('hidden');
    uiStateStack.push(hideRenameModal);
}

function hideCreateFolderModal() {
    el.createFolderModal.classList.add('hidden');
    const index = uiStateStack.indexOf(hideCreateFolderModal);
    if (index > -1) uiStateStack.splice(index, 1);
}

function showCreateFolderModal() {
    el.createFolderInput.value = '';
    el.createFolderModal.classList.remove('hidden');
    el.createFolderConfirm.disabled = true;
    el.createFolderConfirm.onclick = async function() {
        const name = el.createFolderInput.value.trim();
        if (!name || el.createFolderConfirm.classList.contains('btn-processing')) return;
        el.createFolderConfirm.classList.add('btn-processing');
        el.createFolderConfirm.innerHTML = '创建中 <i class="fa fa-spinner fa-spin"></i>';
        try {
            const [owner, repo] = state.currentRepo.split('/');
            const path = state.currentPath ? `${state.currentPath}${name}` : name;
            await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${path}/.gitkeep`, {
                method: 'PUT',
                headers: { Authorization: `token ${state.token}`, 'Content-Type': 'application/json', 'User-Agent': 'Mozilla/5.0' },
                body: JSON.stringify({ message: `create folder ${name}`, content: '', branch: state.currentBranch })
            });
            showToast(`已创建文件夹: ${name}`);
            hideCreateFolderModal();
            state.shouldAnimateList = true;
            fetchFiles(true);
        } catch (e) {
            showToast(`失败: ${e.message}`);
        } finally {
            el.createFolderConfirm.classList.remove('btn-processing');
            el.createFolderConfirm.innerHTML = '确认';
            el.createFolderConfirm.disabled = !el.createFolderInput.value.trim();
        }
    };
    uiStateStack.push(hideCreateFolderModal);
}

function hideCreateFileModal() {
    el.createFileModal.classList.add('hidden');
    const index = uiStateStack.indexOf(hideCreateFileModal);
    if (index > -1) uiStateStack.splice(index, 1);
}

function showCreateFileModal() {
    if (!state.currentRepo) {
        showToast('请先选择仓库');
        return;
    }
    el.createFileNameInput.value = '';
    el.createFileContentInput.value = '';
    el.createFileModal.classList.remove('hidden');
    el.createFileConfirm.disabled = true;
    el.createFileConfirm.onclick = async function() {
        const name = el.createFileNameInput.value.trim();
        const content = el.createFileContentInput.value;
        if (!name) return;
        el.createFileConfirm.disabled = true;
        el.createFileConfirm.classList.add('btn-processing');
        el.createFileConfirm.innerHTML = '创建中 <i class="fa fa-spinner fa-spin"></i>';
        try {
            const [owner, repo] = state.currentRepo.split('/');
            const path = state.currentPath ? `${state.currentPath}${name}` : name;
            const encodedContent = btoa(unescape(encodeURIComponent(content)));
            const res = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${path}`, {
                method: 'PUT',
                headers: { Authorization: `token ${state.token}`, 'Content-Type': 'application/json' },
                body: JSON.stringify({ message: `create file ${name}`, content: encodedContent, branch: state.currentBranch })
            });
            if (!res.ok) throw new Error('创建失败');
            showToast(`已创建文件: ${name}`);
            hideCreateFileModal();
            state.shouldAnimateList = true;
            fetchFiles(true);
        } catch (e) {
            showToast(`失败: ${e.message}`);
        } finally {
            el.createFileConfirm.disabled = false;
            el.createFileConfirm.classList.remove('btn-processing');
            el.createFileConfirm.innerHTML = '确认';
        }
    };
    uiStateStack.push(hideCreateFileModal);
}

function hideCreateBranchModal() {
    el.createBranchModal.classList.add('hidden');
    const index = uiStateStack.indexOf(hideCreateBranchModal);
    if (index > -1) uiStateStack.splice(index, 1);
}

async function showCreateBranchModal(repo) {
    el.createBranchNameInput.value = '';
    el.createBranchConfirm.disabled = true;
    el.createBranchModal.classList.remove('hidden');
    el.createBranchNameInput.oninput = () => {
        el.createBranchConfirm.disabled = !el.createBranchNameInput.value.trim();
    };
    const sourceSelector = {
        wrapper: document.getElementById('sourceBranchSelector'),
        trigger: document.getElementById('sourceBranchSelector').querySelector('.custom-branch-select-trigger'),
        optionsPanel: document.getElementById('sourceBranchSelector').querySelector('.custom-branch-select-options'),
        triggerText: document.getElementById('sourceBranchSelector').querySelector('span'),
        currentSelection: { name: null, sha: null }
    };
    sourceSelector.triggerText.textContent = '加载中...';
    sourceSelector.optionsPanel.innerHTML = '';

    const updateBranchActionButtonsState = () => {
        const selectedBranchName = sourceSelector.currentSelection.name;
        if (!selectedBranchName) {
            el.renameBranchBtn.disabled = true;
            el.deleteBranchBtn.disabled = true;
            el.renameBranchBtn.title = '重命名所选分支';
            el.deleteBranchBtn.title = '删除所选分支';
            return;
        };
        const isDefaultBranch = selectedBranchName === repo.default_branch;
        el.renameBranchBtn.disabled = false;
        el.renameBranchBtn.title = isDefaultBranch ? '不能重命名默认分支' : `重命名分支: ${selectedBranchName}`;
        el.deleteBranchBtn.disabled = false;
        el.deleteBranchBtn.title = isDefaultBranch ? '不能删除默认分支' : `删除分支: ${selectedBranchName}`;
    };

    try {
        await fetchBranches(repo);
        const populateBranchOptions = () => {
            sourceSelector.optionsPanel.innerHTML = '';
            if (!state.branches || state.branches.length === 0) {
                sourceSelector.triggerText.textContent = '无可用分支';
                sourceSelector.currentSelection = { name: null, sha: null };
                el.createBranchConfirm.disabled = true;
                return;
            }
            state.branches.forEach(branch => {
                const option = document.createElement('div');
                option.className = 'custom-branch-select-option';
                option.textContent = branch.name;
                option.dataset.branchName = branch.name;
                option.dataset.branchSha = branch.commit.sha;
                option.addEventListener('click', () => {
                    sourceSelector.currentSelection = { name: branch.name, sha: branch.commit.sha };
                    const previouslySelected = sourceSelector.optionsPanel.querySelector('.selected');
                    if (previouslySelected) previouslySelected.classList.remove('selected');
                    option.classList.add('selected');
                    sourceSelector.triggerText.textContent = branch.name;
                    sourceSelector.wrapper.classList.remove('open');
                    updateBranchActionButtonsState();
                });
                sourceSelector.optionsPanel.appendChild(option);
            });
            const defaultBranch = state.branches.find(b => b.name === repo.default_branch) || state.branches[0];
            if (defaultBranch) {
                sourceSelector.currentSelection = { name: defaultBranch.name, sha: defaultBranch.commit.sha };
                sourceSelector.triggerText.textContent = defaultBranch.name;
                const defaultOption = sourceSelector.optionsPanel.querySelector(`[data-branch-name="${defaultBranch.name}"]`);
                if (defaultOption) defaultOption.classList.add('selected');
            }
        };
        populateBranchOptions();
    } catch (error) {
        console.error("加载分支失败:", error);
        sourceSelector.triggerText.textContent = '加载分支失败';
        showToast('加载分支列表失败');
        sourceSelector.currentSelection = { name: null, sha: null };
        el.createBranchConfirm.disabled = true;
    }

    updateBranchActionButtonsState();

    sourceSelector.trigger.onclick = (e) => {
        if (!state.branches || state.branches.length === 0) return;
        e.stopPropagation();
        sourceSelector.wrapper.classList.toggle('open');
    };

    document.addEventListener('click', (e) => {
        if (!sourceSelector.wrapper.contains(e.target)) {
            sourceSelector.wrapper.classList.remove('open');
        }
    });

    el.renameBranchBtn.onclick = function() {
        const branchToRename = sourceSelector.currentSelection.name;
        if (!branchToRename) return;
        if (branchToRename === repo.default_branch) {
            showToast('禁止重命名默认分支');
            return;
        }
        showRenameModal({ name: branchToRename, type: 'branch', repo: repo });
    };

    el.deleteBranchBtn.onclick = function() {
    const branchToDelete = sourceSelector.currentSelection.name;
    if (!branchToDelete) return;
    if (branchToDelete === repo.default_branch) {
        showToast('禁止删除默认分支');
        return;
    }
    
    const restoreInteractivity = () => {
        el.createBranchModal.style.pointerEvents = 'auto';
    };

    el.createBranchModal.style.pointerEvents = 'none';

    showDeleteModal(
        null,
        false,
        '确认删除分支',
        `确定要删除分支 "${branchToDelete}" 吗？此操作不可撤销`,
        async () => {
            try {
                const res = await fetch(`https://api.github.com/repos/${repo.full_name}/git/refs/heads/${branchToDelete}`, {
                    method: 'DELETE',
                    headers: { 'Authorization': `token ${state.token}` }
                });
                if (!res.ok) throw new Error((await res.json()).message || '删除分支失败');
                showToast(`分支 &nbsp;${branchToDelete}已成功删除,请等待服务器刷新`);
                if (state.currentRepo === repo.full_name) {
                    await fetchBranches(repo);
                }
            } catch (e) {
                showToast(`删除失败: ${e.message}`);
            } finally {
                restoreInteractivity();
            }
        },
        '确认删除',
        'btn-danger',
        restoreInteractivity
    );
};

    el.createBranchConfirm.onclick = async function() {
        const newBranchName = el.createBranchNameInput.value.trim();
        const sourceBranchSha = sourceSelector.currentSelection.sha;
        if (!newBranchName || !sourceBranchSha) return;
        this.disabled = true;
        this.classList.add('btn-processing');
        this.innerHTML = '创建中 <i class="fa fa-spinner fa-spin"></i>';
        try {
            const res = await fetch(`https://api.github.com/repos/${repo.full_name}/git/refs`, {
                method: 'POST',
                headers: { 'Authorization': `token ${state.token}`, 'Content-Type': 'application/json' },
                body: JSON.stringify({ ref: `refs/heads/${newBranchName}`, sha: sourceBranchSha })
            });
            if (!res.ok) throw new Error((await res.json()).message || '创建分支失败');
            showToast(`分支 &nbsp;${newBranchName}创建成功,请等待服务器刷新`);
            hideCreateBranchModal();
            await fetchRepos(true);
            if (state.currentRepo === repo.full_name) {
                await fetchBranches(repo);
                renderBranchSwitcher();
            }
        } catch (e) {
            showToast(`创建失败: ${e.message}`);
        } finally {
            this.disabled = false;
            this.classList.remove('btn-processing');
            this.innerHTML = '创建分支';
        }
    };
    uiStateStack.push(hideCreateBranchModal);
}

function showRenameRepoModal(repo) {
    const mainSiteName = state.user ? `${state.user.login}.github.io` : null;
    
    const extraSettingsContainer = document.getElementById('renameModalExtraSettings');
    extraSettingsContainer.innerHTML = '';
    el.renameWarn.textContent = '';
    el.renameWarn.style.display = 'none';

    const settingsHTML = `
        <textarea id="newRepoDesc" placeholder="仓库描述（可选）" style="margin-top: 0.6rem;">${repo.description || ''}</textarea>
        <div class="checkbox-container" style="margin: 0.6rem 0;">
            <input type="checkbox" id="newRepoPrivate">
            <label for="newRepoPrivate">公开仓库</label>
        </div>
    `;
    extraSettingsContainer.innerHTML = settingsHTML;

    el.renameTitle.querySelector('.modal-title-text').textContent = `重命名`;
    const descTextarea = document.getElementById('newRepoDesc');
    const privateCheckbox = document.getElementById('newRepoPrivate');
    el.renameInput.value = repo.name;
    privateCheckbox.checked = !repo.private;
    el.renameConfirm.disabled = true;

    descTextarea.addEventListener('input', function() {
        autoGrow(this);
    });
    autoGrow(descTextarea);

    const updateButtonState = () => {
        const newName = el.renameInput.value.trim();
        const newDesc = descTextarea.value.trim();
        
        el.renameWarn.style.display = 'none';
        el.renameWarn.classList.remove('text-red-400', 'text-orange-400');
        
        if (mainSiteName) {
            if (repo.name === mainSiteName && newName !== mainSiteName) {
                el.renameWarn.textContent = '提示：重命名主站仓库将导致您的主网站下线。';
                el.renameWarn.classList.add('text-orange-400');
                el.renameWarn.style.display = 'block';
            } else if (repo.name !== mainSiteName && newName === mainSiteName) {
                el.renameWarn.textContent = '提示：手动命名为主站仓库不会自动发布网站。推荐使用“设为主站”功能。';
                el.renameWarn.classList.add('text-orange-400');
                el.renameWarn.style.display = 'block';
            }
        }
        
        const nameChanged = newName !== repo.name;
        const descChanged = newDesc !== (repo.description || '');
        const visibilityChanged = privateCheckbox.checked === repo.private;
        const isModified = nameChanged || descChanged || visibilityChanged;
        
        el.renameConfirm.disabled = !isModified || !newName;
    };

    el.renameInput.oninput = updateButtonState;
    descTextarea.oninput = updateButtonState;
    privateCheckbox.onchange = updateButtonState;

    el.renameConfirm.onclick = async function() {
        const newName = el.renameInput.value.trim();
        const newDesc = descTextarea.value.trim();
        const isPrivate = !privateCheckbox.checked;

        const requestBody = { name: newName, description: newDesc, private: isPrivate };
        
        this.disabled = true;
        this.classList.add('btn-processing');
        this.innerHTML = '处理中 <i class="fa fa-spinner fa-spin"></i>';
        try {
            const res = await fetch(`https://api.github.com/repos/${repo.full_name}`, {
                method: 'PATCH',
                headers: { 'Authorization': `token ${state.token}`, 'Content-Type': 'application/json' },
                body: JSON.stringify(requestBody)
            });
            if (!res.ok) throw new Error((await res.json()).message || '修改失败');
            state.shouldAnimateList = true;
            showToast(`保存成功`);
            
            hideRenameModal();
            await fetchRepos(true, true);
        } catch (e) {
            showToast(`修改失败: ${e.message}`, 'error');
        } finally {
            this.disabled = false;
            this.classList.remove('btn-processing');
            this.innerHTML = '确认';
        }
    };

    el.renameModal.classList.remove('hidden');
    uiStateStack.push(hideRenameModal);
}

function hideRenameModal() {
    el.renameModal.classList.add('hidden');

    // 核心修改：恢复布局和样式，避免影响其他功能
    el.renameInput.after(el.renameWarn); // 把提示框移回输入框下面
    el.renameWarn.style.color = '';
    el.renameWarn.style.fontSize = '';
    el.renameWarn.style.marginBottom = '';
    el.renameWarn.classList.add('text-red-400'); // 把默认的红色加回来
    
    const index = uiStateStack.indexOf(hideRenameModal);
    if (index > -1) uiStateStack.splice(index, 1);
}


function hideDeleteModal() {
    el.deleteModal.classList.add('hidden');
    const index = uiStateStack.indexOf(hideDeleteModal);
    if (index > -1) uiStateStack.splice(index, 1);
}


function showDeleteModal(item, isDir = false, title, description, onConfirm, confirmButtonText = '确认删除', confirmButtonClass = 'btn-danger', onCancel) {
    el.deleteTitle.querySelector('.modal-title-text').textContent = title || '确认操作';
    if (item) {
        isDir = item.type === 'dir';
        el.deleteDesc.textContent = description || (isDir ? `确定要删除文件夹 "${item.name}" 吗？
        注意：如果文件夹内文件过多，可能需要较长时间并消耗大量API额度，可在仪表盘查看额度使用情况。` : `确定要删除文件 "${item.name}" 吗？`);
    } else {
        el.deleteDesc.innerHTML = description;
    }

    el.deleteConfirm.textContent = confirmButtonText;
    el.deleteConfirm.className = `btn ${confirmButtonClass}`; 

    el.deleteModal.classList.remove('hidden');
    
    el.deleteConfirm.onclick = async function() {
        const confirmBtn = this;
        confirmBtn.disabled = true;
        confirmBtn.classList.add('btn-processing');
        confirmBtn.innerHTML = '处理中 <i class="fa fa-spinner fa-spin"></i>';
        try {
            if (onConfirm) {
                await onConfirm();
            } else if (item) {
                await deleteSingleItem(item);
                showToast(`"${escapeHtml(item.name)}" 已删除`);
                state.shouldAnimateList = true;
                fetchFiles(true);
            }
        } catch (error) {
            showToast(`操作失败: ${error.message}`);
        } finally {
            hideDeleteModal();
            confirmBtn.disabled = false;
            confirmBtn.classList.remove('btn-processing');
            confirmBtn.innerHTML = confirmButtonText; 
        }
    };

    el.deleteCancel.onclick = function() {
        if (typeof onCancel === 'function') {
            onCancel();
        }
        hideDeleteModal();
    };

    uiStateStack.push(hideDeleteModal);
}

function goUp() {
    history.back();
}

function closeProxySettingsModal() {
    el.proxySettingsModal.classList.add('hidden');
    const index = uiStateStack.indexOf(closeProxySettingsModal);
    if (index > -1) uiStateStack.splice(index, 1);
}

function openProxySettingsModal() {
    updateProxySettingsUI();
    renderProxyList();
    el.proxySettingsModal.classList.remove('hidden');
    uiStateStack.push(closeProxySettingsModal);
}

function updateProxySettingsUI() {
    updateProxyUI();
    const isAutoSelectEnabled = !!state.autoSelectProxy;
    el.proxyAutoSelectToggle.classList.toggle('active', isAutoSelectEnabled);
    el.proxyAutoSelectToggle.title = isAutoSelectEnabled ? '自动优选代理已开启' : '自动优选代理已关闭';
}

async function testProxyEnhanced(proxyUrl) {

//修改单个代理的测试轮数
    const REPEAT_COUNT = 4;
    const TIMEOUT_MS = 5000;

    const _singleTest = async (url, type) => {
        let proxiedTestUrl = '';
        const proxyInputUrl = (url || '').trim();
        const proxyDomain = getDomainFromUrl(proxyInputUrl);

        if (!proxyInputUrl) return { ok: false, ms: null, err: 'URL为空', type };

        if (type === 'prefix') {
            let base = proxyInputUrl;
            if (!base.endsWith('/')) base += '/';
            proxiedTestUrl = base + PROXY_TEST_URL;
        } else if (type === 'raw_domain_replace') {
            proxiedTestUrl = PROXY_TEST_URL.replace(/^(https?:\/\/raw\.)githubusercontent\.com(\/.*)$/i, `$1${proxyDomain}$2`);
            if (!proxiedTestUrl.startsWith('http')) proxiedTestUrl = 'https://' + proxiedTestUrl;
        } else {
            return { ok: false, ms: null, err: '未知类型', type };
        }

        const start = performance.now();
        try {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), TIMEOUT_MS);
            const r = await fetch(proxiedTestUrl, { method: 'GET', cache: 'no-store', signal: controller.signal });
            clearTimeout(timeoutId);
            if (!r.ok) return { ok: false, ms: null, err: `HTTP ${r.status}`, type };
            await r.text();
            return { ok: true, ms: Math.round(performance.now() - start), err: null, type };
        } catch (e) {
            let errorMsg = '连接失败';
            if (e.name === 'AbortError') errorMsg = '连接超时';
            return { ok: false, ms: null, err: errorMsg, type };
        }
    };

    let bestType = null;
    let finalError = '所有模式均测试失败';

    const replaceResult = await _singleTest(proxyUrl, 'raw_domain_replace');
    if (replaceResult.ok) {
        bestType = 'raw_domain_replace';
    } else {
        finalError = replaceResult.err;
        const prefixResult = await _singleTest(proxyUrl, 'prefix');
        if (prefixResult.ok) {
            bestType = 'prefix';
        } else {
            finalError = prefixResult.err;
        }
    }

    if (!bestType) {
        return { ok: false, ms: null, type: null, err: finalError };
    }

    const latencies = [];
    for (let i = 0; i < REPEAT_COUNT; i++) {
        const result = await _singleTest(proxyUrl, bestType);
        if (result.ok) {
            latencies.push(result.ms);
        }
    }

    if (latencies.length > 0) {
        const bestLatency = Math.min(...latencies);
        return { ok: true, ms: bestLatency, type: bestType, err: null };
    } else {
        return { ok: false, ms: null, type: bestType, err: '连接不稳定' };
    }
}

function renderProxyList() {
    const container = el.proxyListContainer;
    container.innerHTML = '';
    if (state.proxies.length === 0) {
        el.proxyListEmpty.classList.remove('hidden');
        el.proxyTestAllBtn.disabled = true;
        el.proxyClearAllBtn.disabled = true;
        el.proxyAutoSelectToggle.disabled = true;
    } else {
        el.proxyListEmpty.classList.add('hidden');
        el.proxyTestAllBtn.disabled = false;
        el.proxyClearAllBtn.disabled = false;
        el.proxyAutoSelectToggle.disabled = false;
    }

    const sortedProxies = [...state.proxies].sort((a, b) => {
        const getPriority = (proxy) => {
            if (proxy.status === 'ok') return 1;
            if (proxy.status === 'fail') return 3;
            return 2;
        };

        const priorityA = getPriority(a);
        const priorityB = getPriority(b);

        if (priorityA !== priorityB) {
            return priorityA - priorityB;
        }

        if (priorityA === 1) {
            return (a.latency ?? Infinity) - (b.latency ?? Infinity);
        }

        return 0;
    });

    sortedProxies.forEach((proxy) => {
        const index = state.proxies.indexOf(proxy);
        const proxyItem = document.createElement('div');
        proxyItem.className = 'proxy-item';
        if (index === state.activeProxyIndex) proxyItem.classList.add('active');
        
        let statusClass = 'gray', latencyText = '未测试', typeText = '';
        if (proxy.type === 'raw_domain_replace') {
            typeText = '类型：替换域名';
        } else if (proxy.type === 'prefix') {
            typeText = '类型：添加前缀';
        }

        if (proxy.status === 'testing') {
            latencyText = `<span class="spinner-small"></span>`;
        } else if (proxy.status === 'ok') {
            latencyText = `${proxy.latency} ms`;
            if (proxy.latency <= 500) statusClass = 'green';
            else if (proxy.latency <= 2000) statusClass = 'yellow';
            else statusClass = 'red';
        } else if (proxy.status === 'fail') {
            statusClass = 'red';
            latencyText = '失败';
        }
        
        proxyItem.innerHTML = `
            <div class="proxy-identity">
                <span class="status-dot ${statusClass}"></span>
                <div class="proxy-url-details">
                    <span class="proxy-url" title="${proxy.url || ''}">${getDomainFromUrl(proxy.url) || '无效URL'}</span>
                    ${typeText ? `<span class="proxy-type-label">${typeText}</span>` : ''}
                </div>
            </div>
            <div class="proxy-status-actions">
                <span class="latency-text ${statusClass}">${latencyText}</span>
                <div class="proxy-actions">
                    <button class="btn-icon-sm edit-proxy-btn" data-index="${index}" title="编辑"><i class="fa fa-pencil"></i></button>
                    <button class="btn-icon-sm delete-proxy-btn danger" data-index="${index}" title="删除"><i class="fa-regular fa-trash-can"></i></button>
                </div>
            </div>
        `;
        proxyItem.addEventListener('click', (e) => {
            if (e.target.closest('.edit-proxy-btn, .delete-proxy-btn')) return;
            if (index === state.activeProxyIndex) return;
            setActiveProxy(index);
        });
        container.appendChild(proxyItem);
    });

    container.querySelectorAll('.edit-proxy-btn').forEach(button => {
        button.onclick = (e) => { e.stopPropagation(); openAddEditProxyModal(parseInt(e.currentTarget.dataset.index)); };
    });
    container.querySelectorAll('.delete-proxy-btn').forEach(button => {
        button.onclick = (e) => { e.stopPropagation(); showConfirmDeleteProxyModal(parseInt(e.currentTarget.dataset.index)); };
    });
    saveProxyConfig();
}

function saveProxyConfig() {
    localStorage.setItem('proxies', JSON.stringify(state.proxies));
    localStorage.setItem('active_proxy_index', JSON.stringify(state.activeProxyIndex));
    localStorage.setItem('proxy_global_enable', JSON.stringify(state.proxyGlobalEnable));
    updateProxyUI();
}

function openAddEditProxyModal(index = null) {
    state.editingProxyIndex = index;
    const modal = el.addEditProxyModal;
    const titleTextSpan = el.addEditProxyTitle.querySelector('.modal-title-text');
    const urlInput = el.addEditProxyUrlInput;
    const saveBtn = el.addEditProxySaveBtn;
    const cancelBtn = document.getElementById('addEditProxyCancelBtn');
    urlInput.value = '';
    el.addEditProxyError.style.display = 'none';
    if (index !== null && state.proxies[index]) {
        const proxy = state.proxies[index];
        titleTextSpan.textContent = '编辑代理';
        urlInput.value = proxy.url;
        urlInput.placeholder = '修改代理地址';
    } else {
        titleTextSpan.textContent = '添加新代理';
        urlInput.placeholder = '例如：https://ghproxy.net/';
    }
    cancelBtn.onclick = closeAddEditProxyModal;
    saveBtn.onclick = null; 
    modal.classList.remove('hidden');
    validateAddEditProxyInput();
    uiStateStack.push(closeAddEditProxyModal);
}

function closeAddEditProxyModal() {
    el.addEditProxyModal.classList.add('hidden');
    state.editingProxyIndex = null;
    el.addEditProxySaveBtn.disabled = false;
    el.addEditProxySaveBtn.classList.remove('btn-processing');
    el.addEditProxySaveBtn.innerHTML = '保存';
    const index = uiStateStack.indexOf(closeAddEditProxyModal);
    if (index > -1) uiStateStack.splice(index, 1);
}

function validateAddEditProxyInput() {
    const url = el.addEditProxyUrlInput.value.trim();
    const saveBtn = el.addEditProxySaveBtn;
    let fullUrl = url;
    if (url && !/^https?:\/\//i.test(fullUrl)) fullUrl = 'https://' + fullUrl;
    const isDuplicate = state.proxies.some((proxy, index) => {
        if (state.editingProxyIndex !== null && index === state.editingProxyIndex) return false;
        let existingUrl = proxy.url;
        if (!/^https?:\/\//i.test(existingUrl)) existingUrl = 'https://' + existingUrl;
        return existingUrl === fullUrl;
    });
    if (!url) {
        saveBtn.disabled = true;
        saveBtn.onclick = null;
    } else if (isDuplicate) {
        saveBtn.disabled = true;
        saveBtn.onclick = () => { showToast('该代理已存在'); };
    } else {
        saveBtn.disabled = false;
        saveBtn.onclick = handleSaveProxy;
    }
    return !isDuplicate && !!url;
}

async function handleSaveProxy() {
    let url = el.addEditProxyUrlInput.value.trim();
    if (url && !/^https?:\/\//i.test(url)) url = 'https://' + url;
    const isEditing = state.editingProxyIndex !== null;
    let indexToTest;
    if (isEditing) {
        indexToTest = state.editingProxyIndex;
        const proxyToEdit = state.proxies[indexToTest];
        proxyToEdit.url = url;
        proxyToEdit.status = 'testing';
        proxyToEdit.latency = null;
        proxyToEdit.err = null;
        proxyToEdit.type = null;
        showToast('代理已更新，正在重新测试...');
    } else {
        const newProxy = { url: url, status: 'testing', latency: null, err: null, type: null };
        state.proxies.unshift(newProxy); 
        indexToTest = 0;
        showToast('代理已添加，正在后台测试...');
    }
    closeAddEditProxyModal();
    renderProxyList();
    const proxyToTest = state.proxies[indexToTest];
    if (!proxyToTest) return;
    const result = await testProxyEnhanced(proxyToTest.url);
    proxyToTest.latency = result.ms;
    proxyToTest.status = result.ok ? 'ok' : 'fail';
    proxyToTest.err = result.err;
    proxyToTest.type = result.type;
    renderProxyList();
}

function showConfirmDeleteProxyModal(index) {
    const proxy = state.proxies[index];
    el.confirmDeleteProxyTitle.querySelector('.modal-title-text').textContent = '确认删除代理';
    el.confirmDeleteProxyMessage.innerHTML = `确定要删除代理 <strong>"${escapeHtml(proxy.url)}"</strong> 吗？此操作不可撤销。`;
    el.confirmDeleteProxyModal.classList.remove('hidden');
    el.confirmDeleteProxyConfirmBtn.onclick = null;
    el.confirmDeleteProxyCancelBtn.onclick = null;
    el.confirmDeleteProxyConfirmBtn.onclick = async () => {
        el.confirmDeleteProxyConfirmBtn.disabled = true;
        el.confirmDeleteProxyConfirmBtn.classList.add('btn-processing');
        el.confirmDeleteProxyConfirmBtn.innerHTML = `删除中 <span class="spinner-small"></span>`;
        try {
            await deleteProxy(index);
            hideConfirmDeleteProxyModal();
        } finally {
            el.confirmDeleteProxyConfirmBtn.disabled = false;
            el.confirmDeleteProxyConfirmBtn.classList.remove('btn-processing');
            el.confirmDeleteProxyConfirmBtn.innerHTML = '确认删除';
        }
    };
    el.confirmDeleteProxyCancelBtn.onclick = hideConfirmDeleteProxyModal;
    uiStateStack.push(hideConfirmDeleteProxyModal);
}

function hideConfirmDeleteProxyModal() {
    el.confirmDeleteProxyModal.classList.add('hidden');
    const index = uiStateStack.indexOf(hideConfirmDeleteProxyModal);
    if (index > -1) uiStateStack.splice(index, 1);
}

function showConfirmClearAllProxiesModal() {
    el.confirmClearAllProxiesModal.classList.remove('hidden');
    el.clearAllProxiesConfirmBtn.disabled = false;
    el.clearAllProxiesConfirmBtn.innerHTML = '确认清空';
    uiStateStack.push(hideConfirmClearAllProxiesModal);
}

function hideConfirmClearAllProxiesModal() {
    el.confirmClearAllProxiesModal.classList.add('hidden');
    const index = uiStateStack.indexOf(hideConfirmClearAllProxiesModal);
    if (index > -1) uiStateStack.splice(index, 1);
}

async function clearAllProxiesConfirmed() {
    el.clearAllProxiesConfirmBtn.disabled = true;
    el.clearAllProxiesConfirmBtn.classList.add('btn-processing');
    el.clearAllProxiesConfirmBtn.innerHTML = `清空中 <span class="spinner-small"></span>`;
    state.proxies = [];
    state.activeProxyIndex = -1;
    showToast('所有代理已清空');
    hideConfirmClearAllProxiesModal();
    renderProxyList();
    el.clearAllProxiesConfirmBtn.disabled = false;
    el.clearAllProxiesConfirmBtn.classList.remove('btn-processing');
    el.clearAllProxiesConfirmBtn.innerHTML = '确认清空';
}

async function deleteProxy(index) {
    state.proxies.splice(index, 1);
    if (state.activeProxyIndex === index) {
        state.activeProxyIndex = state.proxies.length > 0 ? 0 : -1;
    } else if (state.activeProxyIndex > index) {
        state.activeProxyIndex--;
    }
    showToast('代理已删除');
    renderProxyList();
}





async function testAllProxies(showInitialToast = true) {
    if (state.proxies.length === 0) {
        if (showInitialToast) showToast('没有代理可供测试', 'info');
        return;
    }
    el.proxyTestAllBtn.disabled = true;
    el.proxyTestAllSpinner.classList.remove('hidden');
    el.proxyTestAllBoltIcon.classList.add('hidden');

    if (showInitialToast) {
        showToast(`开始测试 ${state.proxies.length} 个代理...`);
    }

    state.proxies.forEach(proxy => {
        proxy.status = 'testing';
        proxy.latency = null;
        proxy.err = null;
        proxy.type = null;
    });
    renderProxyList();


//修改同时测试的代理数量
    const BATCH_SIZE = 30;
    for (let i = 0; i < state.proxies.length; i += BATCH_SIZE) {
        const batch = state.proxies.slice(i, i + BATCH_SIZE);
        const testPromises = batch.map(async (proxy) => {
            try {
                const result = await testProxyEnhanced(proxy.url);
                proxy.latency = result.ms;
                proxy.status = result.ok ? 'ok' : 'fail';
                proxy.err = result.err;
                proxy.type = result.type;
            } catch (error) {
                proxy.status = 'fail';
                proxy.err = '测试异常';
            }
        });
        await Promise.all(testPromises);
        renderProxyList();
    }

    showToast('所有代理测试完成！');
    el.proxyTestAllBtn.disabled = false;
    el.proxyTestAllBoltIcon.classList.remove('hidden');
    el.proxyTestAllSpinner.classList.add('hidden');
}





async function importProxiesFromUrl() {
    const importButton = el.importBtn;
    const importIcon = importButton.querySelector('.fa-cloud-download');
    const importSpinner = el.importSpinner;

    importButton.disabled = true;
    if (importIcon) importIcon.classList.add('hidden');
    if (importSpinner) importSpinner.classList.remove('hidden');
    showToast('正在通过默认节点导入...', 'info');

    try {
        const PROXY_PREFIXES = [
            'https://gh.ptoe.cc/',
            'https://ghproxy.net/',
            'https://ghfast.top/',
            'https://tvv.tw/'
        ];
        
        const timestamp = `?t=${Date.now()}`;
        const urlsToTry = [
            ...PROXY_PREFIXES.map(prefix => prefix + PROXY_TEST_URL + timestamp),
            PROXY_TEST_URL + timestamp 
        ];

        let responseText = null;
        let success = false;

        for (const url of urlsToTry) {
            try {
                const response = await fetch(url, { cache: 'no-store' });
                if (response.ok) {
                    responseText = await response.text();
                    success = true;
                    break; 
                }
            } catch (error) {
                continue;
            }
        }

        if (!success) {
            throw new Error('所有备用节点和直连均无法获取代理列表');
        }
        
        const urls = responseText.split('\n').map(url => url.trim()).filter(url => url && url.length > 5);
        
        if (urls.length > 0) {
            const newUrls = urls.filter(u => !state.proxies.some(p => p.url && p.url.replace(/\/$/, '') === u.replace(/\/$/, '')));
            if (newUrls.length > 0) {
                const newProxies = newUrls.map(url => ({ url, status: null, latency: null, type: null }));
                state.proxies.push(...newProxies);
                saveProxyConfig();
                renderProxyList();
            }
        }

        await testAllProxies(false);

        let bestLatency = Infinity;
        let bestIndex = -1;
        state.proxies.forEach((proxy, index) => {
            if (proxy.status === 'ok' && proxy.latency < bestLatency) {
                bestLatency = proxy.latency;
                bestIndex = index;
            }
        });

        if (bestIndex !== -1) {
            setActiveProxy(bestIndex, false);
            showToast(`操作完成，已切换至最低延迟节点: ${getDomainFromUrl(state.proxies[bestIndex].url)}`, 'success');
        } else {
            showToast('所有代理均测试失败', 'error');
        }

    } catch (error) {
        showToast(`操作失败: ${error.message}`, 'error');
        console.error("导入或测试时发生错误:", error);
    } finally {
        importButton.disabled = false;
        if (importIcon) importIcon.classList.remove('hidden');
        if (importSpinner) importSpinner.classList.add('hidden');
    }
}




async function findAndSetBestProxy(manual = false) {
    const autoSelectButton = el.proxyAutoSelectToggle;
    if (manual) {
        autoSelectButton.disabled = true;
        showToast('智能优选已启动，正在分析当前中', 'info', 2000);
        showToast('往后每次进入将会在后台自动执行智能优选代理.', 'info', 3000);
    }

    if (state.proxies.length === 0) {
        if (!manual) showToast('首次启动，自动配置代理...', 'info');
        
        try {
            const response = await fetch(PROXY_TEST_URL + '?t=' + Date.now(), { cache: 'no-store' });
            if (!response.ok) throw new Error(`获取代理列表失败`);
            const text = await response.text();
            const urls = text.split('\n').map(url => url.trim()).filter(url => url && url.length > 5);
            if (urls.length > 0) {
                state.proxies.push(...urls.map(url => ({ url, status: null, latency: null, type: null })));
                saveProxyConfig();
                renderProxyList();
            } else {
                 throw new Error("订阅链接为空");
            }
        } catch (error) {
            showToast(`自动导入代理失败: ${error.message}`, 'error');
            if (manual) autoSelectButton.disabled = false;
            return;
        }
    }
    
    const BATCH_SIZE = 3;
    const allProxies = [...state.proxies];
    const detailedResults = [];

    for (let i = 0; i < allProxies.length; i += BATCH_SIZE) {
        const batch = allProxies.slice(i, i + BATCH_SIZE);
        const batchPromises = batch.map(async (proxy) => {
            const typeResult = await determineBestProxyTypeAndTest(proxy.url);
            if (!typeResult.ok) {
                return { ...proxy, testResult: { averageLatency: Infinity, jitter: Infinity, successRate: 0 } };
            }
            proxy.type = typeResult.type;
            const testResult = await testProxyConnectivity(proxy, 4);
            return { ...proxy, testResult };
        });
        const batchResults = await Promise.all(batchPromises);
        detailedResults.push(...batchResults);
    }

    const usableProxies = detailedResults.filter(p => p.testResult.successRate > 0.5);

    if (usableProxies.length === 0) {
        showToast('所有代理均不可用或超时', 'error');
    } else {
        usableProxies.forEach(p => {
            p.score = p.testResult.averageLatency + (p.testResult.jitter * 2);
            if (p.testResult.successRate < 1) p.score += 500;
        });

        usableProxies.sort((a, b) => a.score - b.score);
        const bestProxy = usableProxies[0];
        const bestProxyIndex = state.proxies.findIndex(p => p.url === bestProxy.url);
        
        detailedResults.forEach((result) => {
            const originalProxyIndex = state.proxies.findIndex(p => p.url === result.url);
            if (originalProxyIndex !== -1) {
                state.proxies[originalProxyIndex].status = result.testResult.successRate > 0.5 ? 'ok' : 'fail';
                state.proxies[originalProxyIndex].latency = result.testResult.averageLatency;
                state.proxies[originalProxyIndex].type = result.type;
            }
        });

        renderProxyList();
        setActiveProxy(bestProxyIndex, false);
       // showToast(`代理优选完成: ${getDomainFromUrl(bestProxy.url)} (${bestProxy.testResult.averageLatency}ms)`, 'success');
    }
    
    if (manual) autoSelectButton.disabled = false;
}







async function handleRefreshApiStatus() {
    const refreshBtn = el.refreshApiStatusBtn;
    const icon = refreshBtn.querySelector('i');
    refreshBtn.disabled = true;
    icon.classList.add('fa-spin-custom');
    try {
        await fetchAndRenderApiStatus();
    } catch (error) {
        console.error("手动刷新API状态时出错:", error);
    } finally {
        refreshBtn.disabled = false;
        icon.classList.remove('fa-spin-custom');
    }
}

const closeMultiSelect = () => toggleMultiSelectMode(false);

function toggleMultiSelectMode(enable) {
    state.isMultiSelectMode = enable;
    const fileListEl = el.fileList;
    const toggleBtn = el.multiSelectToggleBtn;
    if (enable) {
        fileListEl.classList.add('multi-select-mode');
        el.multiSelectBar.classList.add('active');
        toggleBtn.classList.add('active');
        toggleBtn.title = '取消多选';
        uiStateStack.push(closeMultiSelect);
    } else {
        fileListEl.classList.remove('multi-select-mode');
        el.multiSelectBar.classList.remove('active');
        toggleBtn.classList.remove('active');
        toggleBtn.title = '多项选择';
        fileListEl.querySelectorAll('.file-item.selected').forEach(item => {
            item.classList.remove('selected');
        });
        state.selectedItems.clear();
        const index = uiStateStack.indexOf(closeMultiSelect);
        if (index > -1) uiStateStack.splice(index, 1);
    }
    updateActionBar();
}

function updateActionBar() {
    const count = state.selectedItems.size;
    const total = state.displayFiles.length;
    el.selectedCountSpan.textContent = count > 0 ? `已选 ${count} / ${total} 项` : '未选择';
    el.downloadBtn.disabled = count === 0;
    el.deleteBtn.disabled = count === 0;
    el.invertSelectBtn.disabled = count === 0;
    const selectAllIcon = el.selectAllBtn.querySelector('i');
    if (total > 0 && count === total) {
        selectAllIcon.className = 'fa-regular fa-square-minus';
        el.selectAllBtn.title = '取消全选';
    } else {
        selectAllIcon.className = 'fa-regular fa-square-check';
        el.selectAllBtn.title = '全选';
    }
}



async function downloadFilesConcurrently(files, zipFolder, onProgress) {
    const CONCURRENCY_LIMIT = 5;
    let completedCount = 0;
    let activeCount = 0;
    let currentIndex = 0;
    const total = files.length;

    return new Promise((resolve, reject) => {
        if (total === 0) resolve();

        const next = () => {
            if (completedCount === total) {
                resolve();
                return;
            }

            while (activeCount < CONCURRENCY_LIMIT && currentIndex < total) {
                const file = files[currentIndex++];
                activeCount++;

                const fetchAndZip = async () => {
                    try {
                        const rawUrl = file.download_url || 
                                     `https://raw.githubusercontent.com/${state.currentRepo}/${state.currentBranch}/${file.path.split('/').map(encodeURIComponent).join('/')}`;
                        
                        const url = getProxiedUrl(rawUrl);

                        const res = await fetch(url);
                        
                        if (!res.ok) throw new Error(`HTTP ${res.status}`);
                        
                        const blob = await res.blob();
                        
                        zipFolder.file(file.zipPath, blob);
                        
                    } catch (e) {
                        console.error(e);
                        zipFolder.file(file.zipPath + ".error.txt", "Download failed: " + e.message);
                    } finally {
                        activeCount--;
                        completedCount++;
                        if (onProgress) onProgress(completedCount, total);
                        next();
                    }
                };

                fetchAndZip();
            }
        };

        next();
    });
}

async function gatherAllFiles(path, zipPathPrefix = "") {
    const [owner, repo] = state.currentRepo.split('/');
    let collectedFiles = [];
    
    try {
        const url = `https://api.github.com/repos/${owner}/${repo}/contents/${path}?ref=${state.currentBranch}`;
        const res = await fetch(url, { headers: { 'Authorization': `token ${state.token}` } });
        if (!res.ok) throw new Error('Failed');
        
        const items = await res.json();
        const promises = items.map(async (item) => {
            const itemZipPath = zipPathPrefix ? `${zipPathPrefix}/${item.name}` : item.name;
            if (item.type === 'file') {
                return [{
                    path: item.path,
                    zipPath: itemZipPath,
                    size: item.size
                }];
            } else if (item.type === 'dir') {
                return await gatherAllFiles(item.path, itemZipPath);
            }
            return [];
        });

        const results = await Promise.all(promises);
        collectedFiles = results.flat();
    } catch (e) {
        console.error(e);
    }
    return collectedFiles;
}

async function downloadSelectedItemsAsZip() {
    if (state.selectedItems.size === 0) return;
    
    const updateProgressToast = (current, total, phase) => {
        const toastEl = document.getElementById('toast');
        const msgEl = document.getElementById('toastMessage');
        toastEl.className = 'toast-info show';
        if (phase === 'scanning') {
            msgEl.textContent = `正在扫描文件列表...`;
        } else {
            const percent = Math.round((current / total) * 100);
            msgEl.textContent = `正在下载: ${current}/${total} (${percent}%)`;
        }
    };

    updateProgressToast(0, 0, 'scanning');
    const zip = new JSZip();
    let allFilesToDownload = [];

    try {
        const rootItems = state.files.filter(file => state.selectedItems.has(file.path));
        
        const scanPromises = rootItems.map(async (item) => {
            if (item.type === 'file') {
                return [{ path: item.path, zipPath: item.name }];
            } else if (item.type === 'dir') {
                return await gatherAllFiles(item.path, item.name);
            }
            return [];
        });

        const results = await Promise.all(scanPromises);
        allFilesToDownload = results.flat();

        if (allFilesToDownload.length === 0) {
            showToast('没有可下载的文件');
            return;
        }

        await downloadFilesConcurrently(allFilesToDownload, zip, (curr, total) => {
            updateProgressToast(curr, total, 'downloading');
        });

        document.getElementById('toastMessage').textContent = "正在打包压缩...";
        
        const content = await zip.generateAsync({ type: "blob" });
        const objectUrl = URL.createObjectURL(content);
        const a = document.createElement('a');
        a.href = objectUrl;
        a.download = `${state.currentRepo.split('/')[1]}-selected.zip`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(objectUrl);
        
        showToast('下载完成！', 'success');

    } catch (e) {
        showToast(`操作失败: ${e.message}`, 'error');
    }
}

async function downloadFolderAsZip(folderItem) {
    if (folderItem.type !== 'dir') return;

    const updateProgressToast = (current, total, phase) => {
        const toastEl = document.getElementById('toast');
        const msgEl = document.getElementById('toastMessage');
        toastEl.className = 'toast-info show';
        if (phase === 'scanning') {
            msgEl.textContent = `正在扫描文件夹: ${folderItem.name}...`;
        } else {
            const percent = Math.round((current / total) * 100);
            msgEl.textContent = `下载中: ${current}/${total} (${percent}%)`;
        }
    };

    updateProgressToast(0, 0, 'scanning');
    const zip = new JSZip();

    try {
        const allFiles = await gatherAllFiles(folderItem.path, folderItem.name);
        
        if (allFiles.length === 0) {
            showToast('文件夹为空');
            return;
        }

        await downloadFilesConcurrently(allFiles, zip, (curr, total) => {
            updateProgressToast(curr, total, 'downloading');
        });

        document.getElementById('toastMessage').textContent = "正在打包压缩...";
        const content = await zip.generateAsync({ type: "blob" });
        const objectUrl = URL.createObjectURL(content);
        const a = document.createElement('a');
        a.href = objectUrl;
        a.download = `${folderItem.name}.zip`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(objectUrl);

        showToast('文件夹下载完成！', 'success');

    } catch (e) {
        showToast(`下载失败: ${e.message}`, 'error');
    }
}


function saveContextMenuSettings() {
    localStorage.setItem('context_menu_visibility', JSON.stringify(state.contextMenuVisibility));
}

function loadContextMenuSettings() {
    const savedSettings = JSON.parse(localStorage.getItem('context_menu_visibility'));
    state.contextMenuVisibility = JSON.parse(JSON.stringify(DEFAULT_MENU_VISIBILITY));
    if (savedSettings) {
        for (const category in state.contextMenuVisibility) {
            if (savedSettings[category]) {
                for (const action in state.contextMenuVisibility[category]) {
                    if (savedSettings[category][action] !== undefined) {
                        state.contextMenuVisibility[category][action] = savedSettings[category][action];
                    }
                }
            }
        }
    }
}

function renderContextMenuSettings(category) {
    const content = el.contextMenuSettingsContent;
    content.innerHTML = '';
    const settings = state.contextMenuVisibility[category];
    const definitions = CONTEXT_MENU_DEFINITIONS[category];
    definitions.forEach(item => {
        if (category === 'repo' && (item.action === 'copyMainSiteLink')) return;
        let labelText = item.text;
        if (category === 'repo' && item.action === 'setAsMainSite') {
            labelText = '主站链接';
        }
        const isVisible = settings[item.action];
        const settingItem = document.createElement('div');
        settingItem.className = 'setting-item';
        settingItem.innerHTML = `
            <label for="toggle-${category}-${item.action}">${labelText}</label>
            <label class="switch">
                <input type="checkbox" id="toggle-${category}-${item.action}" data-category="${category}" data-action="${item.action}" ${isVisible ? 'checked' : ''}>
                <span class="slider round"></span>
            </label>
        `;
        content.appendChild(settingItem);
    });
}

function hideContextMenuSettingsModal() {
    el.contextMenuSettingsModal.classList.add('hidden');
    const index = uiStateStack.indexOf(hideContextMenuSettingsModal);
    if (index > -1) uiStateStack.splice(index, 1);
}

function openContextMenuSettingsModal() {
    el.contextMenuSettingsModal.classList.remove('hidden');
    const activeTab = el.contextMenuSettingsModal.querySelector('.context-menu-settings-tabs .tab-btn.active');
    if (activeTab) {
        const activeCategory = activeTab.dataset.tab;
        renderContextMenuSettings(activeCategory);
    } else {
        renderContextMenuSettings('file');
    }
    uiStateStack.push(hideContextMenuSettingsModal);
}

async function loadLocalAvatar() {
    try {
        const avatarBlob = await getAvatarFromDB('user_avatar');
        if (avatarBlob) {
            state.localAvatar = URL.createObjectURL(avatarBlob);
        } else {
            state.localAvatar = null;
        }
    } catch (e) {
        state.localAvatar = null;
    }
}

function handleAvatarChange(event) {
    const file = event.target.files[0];
    if (!file) return;
    if (!file.type.startsWith('image/')) {
        showToast('请选择一个图片文件');
        return;
    }
    if (file.size > 2 * 1024 * 1024) {
        showToast('图片文件不能超过 2MB');
        return;
    }
    
    saveAvatarToDB('user_avatar', file).then(() => {
        if (state.localAvatar) {
            URL.revokeObjectURL(state.localAvatar);
        }
        state.localAvatar = URL.createObjectURL(file);
        updateUserUI();
        showToast('本地头像更新成功');
    }).catch(err => {
        showToast('保存头像失败');
        console.error(err);
    });
}



function hideMediaPreview() {
    const preview = document.getElementById('mediaPreview');
    if (!preview.classList.contains('hidden')) {
        preview.classList.add('hidden');
        document.getElementById('mediaPreviewImg').src = '';
        const video = document.getElementById('mediaPreviewVideo');
        video.src = '';
        video.pause();
        const index = uiStateStack.indexOf(hideMediaPreview);
        if (index > -1) uiStateStack.splice(index, 1);
    }
}

function initMediaPreview() {
    const preview = document.getElementById('mediaPreview');
    const img = document.getElementById('mediaPreviewImg');
    const video = document.getElementById('mediaPreviewVideo');
    const audioExts = ['mp3', 'wav', 'ogg', 'flac', 'm4a'];
    let audioManager = {
        audio: null,
        currentUrl: '',
        currentName: '',
        isPlaying: false,
        init() {
            if (!this.audio) {
                this.audio = new Audio();
                this.audio.preload = 'none';
                this.audio.crossOrigin = 'anonymous';
                this.audio.addEventListener('play', () => { this.isPlaying = true; });
                this.audio.addEventListener('pause', () => { this.isPlaying = false; });
                this.audio.addEventListener('ended', () => { this.isPlaying = false; showToast(`播放完成: ${this.currentName}`); });
                this.audio.addEventListener('error', (e) => { this.isPlaying = false; showToast('播放出错'); console.error('Audio error:', e); });
                document.addEventListener('visibilitychange', () => {
                    if (!document.hidden && this.isPlaying && this.audio.paused) {
                        this.audio.play().catch(() => {});
                    }
                });
            }
        },
        play(url, name) {
            this.init();
            showToast(`正在播放: ${name}`);
            if (this.currentUrl === url) {
                if (this.audio.paused) { this.audio.play().catch(() => { showToast('播放失败'); }); }
                else { this.audio.pause(); showToast(`已暂停: ${name}`); }
                return;
            }
            this.currentUrl = url;
            this.currentName = name;
            this.audio.src = url;
            const playPromise = this.audio.play();
            if (playPromise !== undefined) {
                playPromise.catch((error) => { console.log('Autoplay prevented:', error); });
            }
        }
    };
    preview.onclick = function(e) {
        if (e) {
            e.stopPropagation();
            e.preventDefault();
        }
        hideMediaPreview();
    };
    document.getElementById('fileList').addEventListener('click', function(e) {
        if (state.isMultiSelectMode) return;
        if (e.target.classList.contains('multi-select-checkbox')) return;
        if (e.target.closest('.flex.gap-1,button')) return;
        const item = e.target.closest('.file-item');
        if (!item) return;
        const name = item.querySelector('.file-name') ? item.querySelector('.file-name').textContent : '';
        const ext = name.split('.').pop()?.toLowerCase();
        const file = state.files.find(f => f.name === name);
        if (!file || file.type !== 'file') return;
        const raw = file.download_url ? file.download_url : file.html_url.replace('github.com', 'raw.githubusercontent.com').replace('/blob/', '/');
        const url = getProxiedUrl(raw);
        if (audioExts.includes(ext)) {
            const nameWithoutExt = name.substring(0, name.lastIndexOf('.'));
            audioManager.play(url, nameWithoutExt);
            e.preventDefault();
            e.stopPropagation();
            return;
        }
        const openPreview = () => {
            preview.classList.remove('hidden');
            uiStateStack.push(hideMediaPreview);
            e.preventDefault();
            e.stopPropagation();
        };
        if (['png', 'jpg', 'jpeg', 'gif', 'webp', 'ico', 'bmp', 'svg'].includes(ext)) {
            img.src = url;
            img.style.display = '';
            video.style.display = 'none';
            openPreview();
            return;
        }
        if (['mp4', 'webm', 'ogg', 'mov', 'avi', 'mkv'].includes(ext)) {
            video.src = url;
            video.style.display = '';
            img.style.display = 'none';
            openPreview();
            video.load();
            return;
        }
    }, true);
}

function hideCreateRepoModal() {
    el.createRepoModal.classList.add('hidden');
    const index = uiStateStack.indexOf(hideCreateRepoModal);
    if (index > -1) uiStateStack.splice(index, 1);
}

function showCreateRepoModal() {
    el.createRepoNameInput.value = '';
    el.createRepoDescInput.value = '';
    el.createRepoPrivate.checked = true;
    el.repoNameError.style.display = 'none';
    el.createRepoModal.classList.remove('hidden');
    el.createRepoConfirm.disabled = true;
    function validateRepoName(name) {
        if (/[\u4e00-\u9fa5]/.test(name)) return '仓库名称不能包含中文字符';
        if (name.length > 100) return '仓库名称不能超过100个字符';
        if (name.startsWith('.') || name.endsWith('.')) return '仓库名称不能以点号开头或结尾';
        return null;
    }
    el.createRepoNameInput.oninput = function() {
        this.value = this.value.replace(/[\u4e00-\u9fa5]/g, '');
        const name = el.createRepoNameInput.value.trim();
        const error = validateRepoName(name);
        if (error) {
            el.repoNameError.textContent = error;
            el.repoNameError.style.display = 'block';
            el.createRepoConfirm.disabled = true;
        } else {
            el.repoNameError.style.display = 'none';
            el.createRepoConfirm.disabled = !name;
        }
    };
    el.createRepoConfirm.onclick = async function() {
        const name = el.createRepoNameInput.value.trim();
        const description = el.createRepoDescInput.value.trim();
        const isPrivate = !el.createRepoPrivate.checked;
        const error = validateRepoName(name);
        
        if (error || !name) return;

        this.disabled = true;
        this.classList.add('btn-processing');
        this.innerHTML = '创建中 <i class="fa fa-spinner fa-spin"></i>';
        
        try {
            const res = await fetch('https://api.github.com/user/repos', {
                method: 'POST',
                headers: { 
                    'Authorization': `token ${state.token}`, 
                    'Content-Type': 'application/json', 
                    'User-Agent': 'Mozilla/5.0' 
                },
                body: JSON.stringify({ 
                    name: name, 
                    description: description || undefined, 
                    private: isPrivate, 
                    auto_init: true 
                })
            });

            if (!res.ok) {
                const errData = await res.json().catch(() => ({}));
                throw new Error(errData.message || '创建仓库失败');
            }
            
            showToast(`仓库 "${name}" 创建成功`, 'success');
            hideCreateRepoModal();
            await fetchRepos(true, true);

        } catch (e) {
            showToast(`创建失败: ${e.message}`, 'error');
        } finally {
            if (el.createRepoModal.classList.contains('hidden')) {
                this.innerHTML = '创建仓库';
                this.classList.remove('btn-processing');
                this.disabled = false;
            } else {
                this.disabled = false;
                this.classList.remove('btn-processing');
                this.innerHTML = '创建仓库';
            }
        }
    };
    uiStateStack.push(hideCreateRepoModal);
}

function hideApiStatusPanel() {
    el.apiStatusOverlay.classList.remove('open');
    el.apiStatusPanel.classList.remove('open');
    setTimeout(() => {
        el.apiStatusOverlay.classList.add('hidden');
    }, 300);
    const index = uiStateStack.indexOf(hideApiStatusPanel);
    if (index > -1) uiStateStack.splice(index, 1);
}

function showApiStatusPanel() {
    el.apiStatusOverlay.classList.remove('hidden');
    setTimeout(() => {
        el.apiStatusOverlay.classList.add('open');
        el.apiStatusPanel.classList.add('open');
    }, 10);
    fetchAndRenderApiStatus();
    uiStateStack.push(hideApiStatusPanel);
}

async function fetchAndRenderApiStatus() {
    el.apiStatusContent.innerHTML = `<div class="loading-spinner" style="height: auto; padding: 2rem 0;"><div class="spinner"></div></div>`;
    try {
        const res = await fetch('https://api.github.com/rate_limit', {
            headers: { Authorization: `token ${state.token}`, 'User-Agent': 'Mozilla/5.0' }
        });
        if (!res.ok) throw new Error(`请求失败: ${res.status}`);
        
        const classicScopes = res.headers.get('x-oauth-scopes');
        let tokenScopesHTML;
        let tokenCardTitle;

        if (classicScopes) {
            tokenCardTitle = '当前：经典令牌';
            tokenScopesHTML = classicScopes.split(', ').map(scope => `<span class="token-scope">${scope}</span>`).join('');
        } else {
            tokenCardTitle = '当前：精细化令牌';
            tokenScopesHTML = `
                <p style="font-size: 0.7rem; color: #9ca3af; margin-top: 0.1rem; line-height: 1.5;">
                    此类型令牌权限或已生效，但应用无法直接列出。由于官方限制，请前往GitHub官网检查其设置。
                </p>
            `;
        }
        
        const data = await res.json();
        let contentHTML = '';

        const tokenScopesCardHTML = `
        <div class="api-status-card">
            <h4><i class="fa fa-key"></i>${tokenCardTitle}</h4>
            <div class="token-scopes">
                ${tokenScopesHTML}
            </div>
        </div>`;

        const resources = [
            { key: 'core',   name: '核心', icon: 'fa-cogs' },
            { key: 'search', name: '搜索', icon: 'fa-search' }
        ];

        resources.forEach(({ key, name, icon }) => {
            const resource = data.resources[key];
            if (!resource) return;
            const used = resource.used;
            const limit = resource.limit;
            const remaining = resource.remaining;
            const percentage = limit > 0 ? (used / limit) * 100 : 0;
            let progressClass = 'progress-green';
            if (percentage > 95) progressClass = 'progress-red';
            else if (percentage > 75) progressClass = 'progress-yellow';
            const resetTime = new Date(resource.reset * 1000).toLocaleTimeString();
            
            let refreshIntervalText = '';
            if (key === 'core') {
                refreshIntervalText = '刷新间隔: <span>1小时</span>';
            } else if (key === 'search') {
                refreshIntervalText = '刷新间隔: <span>1分钟</span>';
            }

            let usageNote = '若核心额度耗尽，本工具将无法正常使用';
            if (key === 'search') {
                usageNote = '若搜索额度耗尽，搜索功能将无法使用';
            }

            contentHTML += `
            <div class="api-status-card">
                <h4><i class="fa ${icon}"></i>${name} API</h4>
                <div class="rate-limit-progress-bar">
                    <div class="${progressClass}" style="width: ${percentage}%;"></div>
                </div>
                <div class="rate-limit-details">
                    <p>已用: <span>${used}</span> / ${limit}</p>
                    <p>剩余: <span>${remaining}</span></p>
                    ${refreshIntervalText ? `<p>${refreshIntervalText}</p>` : ''}
                    <p>重置时间: <span>${resetTime}</span></p>
                    <p>${usageNote}</p>
                </div>
            </div>`;
        });
        
        contentHTML += `
        <div class="api-status-card">
            <h4><i class="fa fa-info-circle"></i>联系与反馈</h4>
            <div class="app-status-details" style="user-select: text; cursor: text;">
            <p>作者：牡丹君</p>
                <p >作者QQ：1473460411</p>
                <p>QQ反馈群：719050780</p>
                <p>当前版本：v${CURRENT_VERSION}</p>
            </div>
        </div>
        `;
        contentHTML += tokenScopesCardHTML;
        el.apiStatusContent.innerHTML = contentHTML;
    } catch (error) {
        el.apiStatusContent.innerHTML = `<div class="api-status-card"><p style="color: #f87171;">加载失败: ${error.message}</p></div>`;
    }
}

function toggleEditorSearch(show) {
    const { editorSearchPanel, editorSearchInput } = el;
    if (show) {
        editorSearchPanel.classList.remove('hidden');
        editorSearchInput.focus();
        editorSearchInput.select();
        performEditorSearch();
    } else {
        editorSearchPanel.classList.add('hidden');
        const textarea = el.fileContent;
        const currentScroll = textarea.scrollTop;
        textarea.scrollTop = currentScroll;
        state.editorSearchState = { query: '', matches: [], currentIndex: -1 };
        el.editorSearchInput.value = '';
        updateSearchUI();
    }
}
function performEditorSearch() {
    const query = el.editorSearchInput.value;
    const content = el.fileContent.value;
    state.editorSearchState.query = query;

    if (!query) {
        state.editorSearchState.matches = [];
        state.editorSearchState.currentIndex = -1;
    } else {
        const queryLower = query.toLowerCase();
        const contentLower = content.toLowerCase();
        const matches = [];
        let startIndex = 0;
        let index;
        while ((index = contentLower.indexOf(queryLower, startIndex)) > -1) {
            matches.push(index);
            startIndex = index + queryLower.length;
        }
        state.editorSearchState.matches = matches;
        state.editorSearchState.currentIndex = matches.length > 0 ? 0 : -1;
    }
    
    updateSearchUI();
    if (state.editorSearchState.currentIndex !== -1) {
        highlightCurrentMatch(false);
    }
}

function updateSearchUI() {
    const { matches, currentIndex } = state.editorSearchState;
    const total = matches.length;
    
    if (total > 0) {
        el.editorSearchMatchCount.textContent = `${currentIndex + 1} / ${total}`;
    } else {
        el.editorSearchMatchCount.textContent = '0 / 0';
    }

    el.editorSearchPrevBtn.disabled = total <= 1;
    el.editorSearchNextBtn.disabled = total <= 1;
}

function highlightCurrentMatch(shouldGrabFocus = false) {
    const { matches, currentIndex, query } = state.editorSearchState;
    if (currentIndex === -1) return;

    const textarea = el.fileContent;
    const startPos = matches[currentIndex];
    const endPos = startPos + query.length;

    if (shouldGrabFocus) {
        textarea.focus();
    }
    
    textarea.setSelectionRange(startPos, endPos);
    
    const textBefore = textarea.value.substring(0, startPos);
    const lineNum = textBefore.split("\n").length;
    const lineHeight = parseFloat(getComputedStyle(textarea).lineHeight);
    const targetScrollTop = (lineNum * lineHeight);
    const textareaHeight = textarea.clientHeight;

    textarea.scrollTop = targetScrollTop - (textareaHeight / 2);
}

function navigateSearchMatches(direction) {
    const { matches } = state.editorSearchState;
    const total = matches.length;
    if (total <= 1) return;

    let newIndex = state.editorSearchState.currentIndex + direction;

    if (newIndex < 0) {
        newIndex = total - 1;
    } else if (newIndex >= total) {
        newIndex = 0;
    }

    state.editorSearchState.currentIndex = newIndex;
    updateSearchUI();
highlightCurrentMatch(true);
}


async function handleRefresh() {
    // 根据当前的视图状态，决定调用哪个刷新函数
    const view = state.currentView;
    const targetListEl = !el.repoList.classList.contains('hidden') ? el.repoList : el.fileList;

    if (targetListEl === el.fileList) {
        await fetchFiles(true, false);
        return;
    }

    switch (view) {
        case 'own_repos':
            await fetchRepos(true, false);
            break;
        case 'starred_repos':
            await fetchStarredRepos(true, false, false);
            break;
        case 'other_user_repos':
            if (state.viewingOwner) {
                await _renderAndFetchUserRepos(state.viewingOwner, false);
            }
            break;
        case 'public_search_results':
            const query = el.currentRepo.textContent.replace('公共仓库搜索: "', '').slice(0, -1);
            await searchPublicRepositories(query, state.publicSearchPage, false, false);
            break;
        case 'releases_list':
            if (state.viewingReleasesForRepo) {
                await fetchAndDisplayReleases(state.viewingReleasesForRepo, false);
            }
            break;
        case 'assets_list':
            await refreshAssetsList();
            break;
        default:
            // 作为一个备用选项，刷新默认的仓库列表
            await fetchRepos(true, false);
            break;
    }
}

function initPullToRefresh() {
    const mainEl = document.querySelector('main');
    const ptrIndicator = document.getElementById('pull-to-refresh');

    if (!mainEl || !ptrIndicator) return;

    let targetListEl = null;

    const resetPullState = () => {
        ptrIndicator.classList.remove('visible', 'ready', 'refreshing');
        ptrIndicator.style.transition = 'transform 0.3s ease';
        if (targetListEl) {
            targetListEl.style.transition = 'transform 0.3s ease';
            targetListEl.style.transform = 'translateY(0px)';
        }
        state.pullToRefresh.active = false;
        state.pullToRefresh.pullDistance = 0;
    };

    mainEl.addEventListener('touchstart', (e) => {
        if (mainEl.scrollTop === 0) {
            state.pullToRefresh.startY = e.touches[0].clientY;
            state.pullToRefresh.active = true;
            targetListEl = !el.repoList.classList.contains('hidden') ? el.repoList : 
                           !el.fileList.classList.contains('hidden') ? el.fileList : null;
            if(targetListEl) {
                ptrIndicator.style.transition = 'none';
                targetListEl.style.transition = 'none';
            }
        }
    }, { passive: true });

    mainEl.addEventListener('touchmove', (e) => {
        if (!state.pullToRefresh.active || !targetListEl) return;

        const currentY = e.touches[0].clientY;
        let pullDistance = currentY - state.pullToRefresh.startY;

        if (pullDistance < 0) pullDistance = 0;
        if (pullDistance > 0 && mainEl.scrollTop === 0) e.preventDefault();
        
        state.pullToRefresh.pullDistance = pullDistance;

        if (pullDistance > 10) {
            ptrIndicator.classList.add('visible');
            const dampedDistance = pullDistance * 0.4;
            ptrIndicator.style.transform = `translateY(${dampedDistance - 50}px)`;
            targetListEl.style.transform = `translateY(${dampedDistance}px)`;
            
            if (dampedDistance > state.pullToRefresh.threshold) {
                ptrIndicator.classList.add('ready');
            } else {
                ptrIndicator.classList.remove('ready');
            }
        }
    }, { passive: false });

            mainEl.addEventListener('touchend', async () => {
    if (!state.pullToRefresh.active || !targetListEl) return;

    // 检查是否正在刷新，如果是，则立即返回，防止重复触发
    if (state.isRefreshing) {
        resetPullState();
        return;
    }

    const dampedDistance = state.pullToRefresh.pullDistance * 0.4;

    if (dampedDistance > state.pullToRefresh.threshold) {
        ptrIndicator.classList.add('refreshing');
        ptrIndicator.classList.remove('ready');
        ptrIndicator.style.transform = `translateY(${state.pullToRefresh.threshold - 50}px)`;
        targetListEl.style.transform = `translateY(${state.pullToRefresh.threshold}px)`;
        
        // --- 核心优化 ---
        state.isRefreshing = true; // 上锁
        try {
            // 调用统一的刷新处理器
            await handleRefresh(); 
        } catch (error) {
            showToast('刷新失败', 'error');
        } finally {
            // 确保无论成功还是失败，都会重置状态并解锁
            resetPullState();
            state.isRefreshing = false; // 解锁
        }
        // --- 优化结束 ---

    } else {
        resetPullState();
    }
    state.pullToRefresh.active = false;
});
}




async function publishProjectSite(repo, branchName) {
    try {
        const pagesRes = await fetch(`https://api.github.com/repos/${repo.full_name}/pages`, {
            method: 'POST',
            headers: { 'Authorization': `token ${state.token}`, 'Content-Type': 'application/json' },
            body: JSON.stringify({ source: { branch: branchName, path: "/" } })
        });

        if (pagesRes.status === 409) {
            return { success: true, message: '网站已存在或正在构建中。' };
        }
        
        if (!pagesRes.ok) {
            let errorMessage;
            if (pagesRes.status === 422) errorMessage = '仓库为空或分支无效。';
            else if (pagesRes.status === 403) errorMessage = '权限不足。';
            else errorMessage = `发生未知网络错误 (HTTP ${pagesRes.status})。`;
            throw new Error(errorMessage);
        }

        return { success: true, message: '发布成功！' };
    } catch (error) {
        console.error(`发布仓库 ${repo.name} 失败:`, error);
        return { success: false, message: error.message };
    }
}




async function unpublishSite(repo) {
    try {
        const res = await fetch(`https://api.github.com/repos/${repo.full_name}/pages`, {
            method: 'DELETE',
            headers: { 'Authorization': `token ${state.token}` }
        });
        if (!res.ok && res.status !== 404) {
            let errorMessage;
            if (res.status === 403) errorMessage = '权限不足。';
            else errorMessage = `发生未知网络错误 (HTTP ${res.status})。`;
            throw new Error(errorMessage);
        }
        
        const updatedRepo = await fetchSingleRepoState(repo.full_name);
        updateSingleRepoInStateAndUI(updatedRepo);
        
        return { success: true, message: '取消发布成功！' };
    } catch (error) {
        console.error(`取消发布仓库 ${repo.name} 失败:`, error);
        return { success: false, message: error.message };
    }
}









function renderPublishManagerLists() {
    if (state.publishManagerActiveTab === 'official') {
        el.officialConfigTabBtn.classList.add('active');
        el.customDomainTabBtn.classList.remove('active');
    } else {
        el.officialConfigTabBtn.classList.remove('active');
        el.customDomainTabBtn.classList.add('active');
    }

    const listEl = el.publishManageList;
    listEl.innerHTML = '';

    let mainSiteRepo = null;
    if (state.user && state.user.login) {
        const mainSiteName = `${state.user.login}.github.io`;
        mainSiteRepo = state.repos.find(r => r.name === mainSiteName);
    }
    
    // 关键改动：判断主站点仓库是否已存在
    const mainSiteExists = !!mainSiteRepo;

    let reposToRender;
    const isActiveTabOfficial = state.publishManagerActiveTab === 'official';

    if (isActiveTabOfficial) {
        const otherPublicRepos = state.repos.filter(r => !r.private && (!mainSiteRepo || r.id !== mainSiteRepo.id));
        const publishedRepos = otherPublicRepos.filter(r => r.has_pages);
        const unpublishedRepos = otherPublicRepos.filter(r => !r.has_pages);
        publishedRepos.sort((a, b) => a.name.localeCompare(b.name));
        unpublishedRepos.sort((a, b) => a.name.localeCompare(b.name));
        const sortedOtherRepos = [...publishedRepos, ...unpublishedRepos];
        reposToRender = mainSiteRepo ? [mainSiteRepo, ...sortedOtherRepos] : sortedOtherRepos;
    } else {
        let publishedRepos = state.repos.filter(r => r.has_pages);
        mainSiteRepo = publishedRepos.find(r => r.name === `${state.user.login}.github.io`);
        let otherPublishedRepos = publishedRepos.filter(r => !mainSiteRepo || r.id !== mainSiteRepo.id);
        
        otherPublishedRepos.sort((a, b) => {
            const aHasDomain = !!a.customDomain;
            const bHasDomain = !!b.customDomain;
            if (aHasDomain && !bHasDomain) return -1;
            if (!aHasDomain && bHasDomain) return 1;
            return a.name.localeCompare(b.name);
        });
        
        reposToRender = mainSiteRepo ? [mainSiteRepo, ...otherPublishedRepos] : otherPublishedRepos;
    }

    if (reposToRender.length === 0) {
        const emptyMessage = isActiveTabOfficial
            ? '没有可管理的公开项目'
            : '没有已发布的项目网站';
        listEl.innerHTML = `<p class="publish-list-empty">${emptyMessage}</p>`;
    } else {
        const mainSiteHasCustomDomain = mainSiteRepo && mainSiteRepo.customDomain;
        const projectSiteHasDomain = state.repos.some(r => r.has_pages && r.customDomain && (!mainSiteRepo || r.id !== mainSiteRepo.id));

        reposToRender.forEach(repo => {
            const item = document.createElement('div');
            item.className = 'publish-item';
            
            if (repo.has_pages) {
                item.classList.add('is-published');
                item.title = '点击复制网站链接';
            }

            if (isActiveTabOfficial) {
                const isPublished = repo.has_pages;
                const isMainSite = mainSiteRepo && repo.id === mainSiteRepo.id;

                let actionButtonHTML = '';
                if (isMainSite) {
                    if (isPublished && !repo.customDomain) {
                        actionButtonHTML = `<button class="btn btn-unpublish btn-sm main-site-action-btn">取消主站</button>`;
                    }
                } else {
                    if (isPublished) {
                        if (!repo.customDomain) {
                            actionButtonHTML = `<button class="btn btn-unpublish btn-sm project-action-btn">取消项目</button>`;
                        }
                    } else {
                        actionButtonHTML = `<button class="btn btn-primary btn-sm project-action-btn">发布项目</button>`;
                    }
                }

                // 关键改动：更新显示逻辑，仅在主站不存在时才显示按钮
                const showSetAsMainSiteButton = !isMainSite && !repo.customDomain && !mainSiteExists;

                item.innerHTML = `
                    <span class="repo-name" title="${repo.name}">${repo.name}</span>
                    <div class="publish-item-actions">
                        ${showSetAsMainSiteButton ? `<button class="btn btn-secondary btn-sm set-as-main-site-btn" data-repo-fullname="${escapeHtml(repo.full_name)}">发布为主站</button>` : ''}
                        ${actionButtonHTML}
                    </div>
                `;
                
                if (isMainSite) {
                    const mainSiteButton = item.querySelector('.main-site-action-btn');
                    if (mainSiteButton) {
                        mainSiteButton.onclick = () => {
                            showUnpublishMainSiteModal(repo);
                        };
                    }
                } else {
                    const projectButton = item.querySelector('.project-action-btn');
                    if (projectButton) {
                        if (isPublished) {
    projectButton.onclick = () => {
        showDeleteModal(
            null,
            false,
            '确认取消发布',
            `确定要取消发布项目网站 "${escapeHtml(repo.name)}" 吗？`,
            async () => {
                projectButton.textContent = '处理中...';
                projectButton.disabled = true;
                const result = await unpublishSite(repo);
                showToast(result.message, result.success ? 'success' : 'error');
                if (result.success) {
                    const repoInState = state.repos.find(r => r.id === repo.id);
                    if(repoInState) repoInState.has_pages = false;
                    renderPublishManagerLists();
                }
            },
            '确认取消',
            'btn-danger'
        );
    };
} else {
                            projectButton.dataset.repoFullname = repo.full_name;
                            projectButton.onclick = () => {
                                showPublishBranchSelectorModal(repo, 'projectSite');
                            };
                        }
                    }
                }

            } else {
                const isMainSite = mainSiteRepo && repo.id === mainSiteRepo.id;
                let showConfigureButton = false;
                if(isMainSite) {
                    showConfigureButton = !projectSiteHasDomain;
                } else {
                    showConfigureButton = !mainSiteHasCustomDomain;
                }

                let actionButtonsHTML = '';
                if (repo.customDomain) {
                    actionButtonsHTML += `<button class="btn btn-unpublish btn-sm remove-domain-btn" data-repo-fullname="${escapeHtml(repo.full_name)}">取消绑定</button>`;
                }
                if (showConfigureButton) {
                    actionButtonsHTML += `<button class="btn btn-primary btn-sm configure-domain-btn" data-repo-fullname="${escapeHtml(repo.full_name)}">配置域名</button>`;
                }
                
                item.innerHTML = `
                    <div class="repo-info-wrapper">
                        <span class="repo-name" title="${repo.name}">${repo.name}</span>
                        ${repo.customDomain ? `<p class="repo-domain-display"> ${repo.customDomain}</p>` : ''}
                    </div>
                    <div class="publish-item-actions">
                        ${actionButtonsHTML}
                    </div>
                `;
            }
            
            item.addEventListener('click', (e) => {
                if (e.target.closest('button')) return;

                const isMainSiteRepo = state.user && repo.name === `${state.user.login}.github.io`;

                if (state.publishManagerActiveTab === 'official') {
                    if (!repo.has_pages) {
                        showToast(isMainSiteRepo ? '主站未发布静态网页' : '项目未发布静态网页');
                        return;
                    }

                    const siteUrl = isMainSiteRepo
                        ? `https://${repo.owner.login}.github.io/`
                        : `https://${repo.owner.login}.github.io/${repo.name}/`;
                    
                    navigator.clipboard.writeText(siteUrl).then(() => {
                        showToast(isMainSiteRepo ? '主站链接已复制' : '项目链接已复制');
                    }).catch(() => {
                        showToast(isMainSiteRepo ? '主站链接复制失败' : '项目链接复制失败');
                    });
                } 
                else {
                    if (repo.customDomain) {
                        const siteUrl = `https://${repo.customDomain}`;
                        navigator.clipboard.writeText(siteUrl).then(() => {
                            showToast('自定义域名已复制');
                        }).catch(() => {
                            showToast('复制域名失败');
                        });
                    } else {
                        showToast('未配置域名');
                    }
                }
            });
            
            listEl.appendChild(item);
        });
    }
}



function showPublishHelpModal() {
    el.publishHelpModal.classList.remove('hidden');
    uiStateStack.push(hidePublishHelpModal);
}

function hidePublishHelpModal() {
    el.publishHelpModal.classList.add('hidden');
    const index = uiStateStack.indexOf(hidePublishHelpModal);
    if (index > -1) uiStateStack.splice(index, 1);
}


function showUsageGuideModal() {
    hideMainMenuPopup();
    el.usageGuideModal.classList.remove('hidden');
    uiStateStack.push(hideUsageGuideModal);
}

function hideUsageGuideModal() {
    el.usageGuideModal.classList.add('hidden');
    const index = uiStateStack.indexOf(hideUsageGuideModal);
    if (index > -1) uiStateStack.splice(index, 1);
}

async function showPublishManagerModal() {
    hideMainMenuPopup();
    state.publishManagerActiveTab = 'official';
    el.publishManagerModal.classList.remove('hidden');
    uiStateStack.push(hidePublishManagerModal);

    const hasCachedRepos = state.repos && state.repos.length > 0;

    if (hasCachedRepos) {
        renderPublishManagerLists();
        prefetchCustomDomains(); 
    } else {
        el.publishManageList.innerHTML = '<div class="loading-spinner"><i class="fa fa-spinner fa-spin"></i></div>';
    }

    const silentUpdate = async () => {
        try {
            await fetchRepos(true, false);
            const cachedDomains = JSON.parse(localStorage.getItem('custom_domains_cache') || '{}');
            state.repos.forEach(repo => {
                if (repo.has_pages && cachedDomains[repo.full_name]) {
                    repo.customDomain = cachedDomains[repo.full_name];
                }
            });
            renderPublishManagerLists();
            if (!hasCachedRepos) {
                prefetchCustomDomains();
            }
        } catch (error) {
            if (!hasCachedRepos) {
                el.publishManageList.innerHTML = '<p class="publish-list-empty">加载仓库列表失败</p>';
            }
            showToast('后台更新仓库列表失败', 'error');
        }
    };
    
    silentUpdate();
}

function prefetchCustomDomains() {
    const cachedDomains = JSON.parse(localStorage.getItem('custom_domains_cache') || '{}');
    const reposToFetch = state.repos.filter(r => r.has_pages && r.customDomain === undefined);

    if (reposToFetch.length === 0) {
        return;
    }

    const fetchPromises = reposToFetch.map(repo => (async () => {
        try {
            const url = `https://api.github.com/repos/${repo.full_name}/contents/CNAME?t=${Date.now()}`;
            const response = await fetch(url, { headers: { 'Authorization': `token ${state.token}` } });
            
            let domain = null;
            if (response.ok) {
                const data = await response.json();
                domain = atob(data.content).trim();
            }
            
            repo.customDomain = domain;
            cachedDomains[repo.full_name] = domain;

        } catch (error) {
            repo.customDomain = null;
            cachedDomains[repo.full_name] = null;
        }
    })());
    
    Promise.all(fetchPromises).then(() => {
        localStorage.setItem('custom_domains_cache', JSON.stringify(cachedDomains));
        if (!el.publishManagerModal.classList.contains('hidden')) {
            renderPublishManagerLists();
        }
    });
}
function hidePublishManagerModal() {
    el.publishManagerModal.classList.add('hidden');
    const index = uiStateStack.indexOf(hidePublishManagerModal);
    if (index > -1) uiStateStack.splice(index, 1);

    if (!el.repoList.classList.contains('hidden')) {
        state.shouldAnimateList = false;
        renderRepoList();
    }
}


function parseGithubUrl(url) {
    const patterns = [
        /(?:https?:\/\/)?(?:www\.)?github\.com\/([a-zA-Z0-9_-]+)\/?$/,
        /(?:https?:\/\/)?(?:www\.)?github\.com\/([a-zA-Z0-9_-]+)\/([a-zA-Z0-9_.-]+)(?:\/tree\/[^\/]+\/(.*))?/,
        /(?:https?:\/\/)?(?:www\.)?github\.com\/([a-zA-Z0-9_-]+)\/([a-zA-Z0-9_.-]+)\/?$/
    ];

    for (const pattern of patterns) {
        const match = url.match(pattern);
        if (match) {
            return {
                owner: match[1],
                repo: match[2] || null,
                path: match[3] || ''
            };
        }
    }
    return null;
}






async function searchPublicRepositories(query, page = 1, updateHistory = true, showMainLoader = true) {
    if (!query) return;
    state.publicSearchQuery = query;
    state.publicSearchPage = page;
    
    // 核心修复：先强制设置当前视图状态，确保后续UI渲染逻辑正确
    state.currentView = 'public_search_results';

    const cacheKey = `${query}_${page}`;
    
    // 尝试读取缓存
    if (state.publicSearchCache.has(cacheKey)) {
        const cachedResults = state.publicSearchCache.get(cacheKey);
        
        // 核心修复：从缓存中恢复总数，这对分页按钮至关重要
        state.publicSearchTotalResults = cachedResults.total_count;
        
        if (showMainLoader) {
            toggleView(true);
            el.currentRepo.textContent = `公共仓库搜索: "${query}"`;
            renderRepoList(cachedResults.items);
            
            setTimeout(() => { el.main.scrollTop = state.repoListScrollPosition; }, 0);
        } else {
            // 如果是静默更新（如popstate），也要确保列表渲染
            renderRepoList(cachedResults.items);
        }
        
        updateHomeStarredButtonState();
        updateGlobalSearchVisibility();
        updatePaginationUI();
        return; 
    }

    // 无缓存，走网络请求
    if (showMainLoader) {
        el.repoList.innerHTML = '<div class="loading-spinner"><div class="spinner"></div></div>';
        toggleView(true);
        el.currentRepo.textContent = `公共仓库搜索: "${query}"`;
    }

    if (updateHistory) {
        history.pushState({ view: 'public_search_results', query: query, page: page }, '', window.location.pathname);
    }

    updateHomeStarredButtonState();
    updateGlobalSearchVisibility();

    try {
        const url = `https://api.github.com/search/repositories?q=${encodeURIComponent(query)}&page=${page}&per_page=${state.publicSearchPerPage}`;
        const res = await fetch(url, { headers: { Authorization: `token ${state.token}` } });
        
        if (!res.ok) {
            if (res.status === 403) {
                 throw new Error('API请求频率超限，请稍后再试。');
            }
            throw new Error('搜索失败，请检查网络或API配额');
        }

        const data = await res.json();
        
        // 核心修复：更新总数
        state.publicSearchTotalResults = data.total_count;
        
        state.publicSearchCache.set(cacheKey, { items: data.items, total_count: data.total_count });
        
        renderRepoList(data.items);

    } catch (error) {
        showToast(error.message, 'error');
        el.repoList.innerHTML = `<div class="empty-state"><p>${error.message}</p></div>`;
    } finally {
        updatePaginationUI(); 
    }
}






function updatePaginationUI() {
    const backBtn = el.backBtn;
    const newFolderBtn = el.newFolderBtn;
    const newFileBtn = el.newFileBtn;
    const uploadBtn = el.uploadBtn;
    const newReleaseBtn = el.newReleaseBtn;
    const footer = document.querySelector('footer');

    // 1. 全局重置：先隐藏所有，清空内容，移除事件
    [backBtn, newFolderBtn, newFileBtn, uploadBtn, newReleaseBtn].forEach(btn => {
        btn.classList.add('hidden');
        btn.classList.remove('disabled');
        btn.onclick = null;
        btn.innerHTML = '';
        btn.title = '';
    });
    footer.style.display = '';

    switch (state.currentView) {
        
        // === 场景 A: 公共仓库搜索结果 ===
        // 必须显示：返回按钮 + 分页按钮(如果有)
        case 'public_search_results':
            backBtn.classList.remove('hidden');
            backBtn.innerHTML = '<i class="fa-solid fa-arrow-up"></i>';
            backBtn.title = '返回';
            backBtn.onclick = goUp;
            
            // 确保总页数有效
            const totalSearchPages = (state.publicSearchTotalResults && state.publicSearchPerPage) 
                ? Math.ceil(state.publicSearchTotalResults / state.publicSearchPerPage) 
                : 1;
            const currentSearchPage = state.publicSearchPage || 1;

            if (totalSearchPages > 1) {
                // 上一页
                newFolderBtn.classList.remove('hidden');
                newFolderBtn.innerHTML = '<i class="fa-solid fa-arrow-left"></i>';
                newFolderBtn.title = '上一页';
                newFolderBtn.onclick = handlePrevPage;
                newFolderBtn.classList.toggle('disabled', currentSearchPage <= 1);

                // 下一页
                newFileBtn.classList.remove('hidden');
                newFileBtn.innerHTML = '<i class="fa-solid fa-arrow-right"></i>';
                newFileBtn.title = '下一页';
                newFileBtn.onclick = handleNextPage;
                newFileBtn.classList.toggle('disabled', currentSearchPage >= totalSearchPages);
            }
            break;

        // === 场景 B: 仓库文件列表 (核心逻辑) ===
        case 'file_list':
            backBtn.classList.remove('hidden');
            backBtn.innerHTML = '<i class="fa-solid fa-arrow-up"></i>';
            backBtn.title = '返回上级';
            backBtn.onclick = goUp;

            const isOwner = state.user && state.viewingOwner === state.user.login;
            
            if (isOwner) {
                // 是自己的仓库：显示新建/上传按钮
                newFolderBtn.innerHTML = '<i class="fa-regular fa-folder"></i>';
                newFolderBtn.title = '新建文件夹';
                newFolderBtn.onclick = showCreateFolderModal;
                newFolderBtn.classList.remove('hidden');

                newFileBtn.innerHTML = '<i class="fa-regular fa-file"></i>';
                newFileBtn.title = '新建文件';
                newFileBtn.onclick = showCreateFileModal;
                newFileBtn.classList.remove('hidden');

                uploadBtn.innerHTML = '<i class="fa-solid fa-arrow-up-from-bracket"></i>';
                uploadBtn.title = '上传文件';
                uploadBtn.onclick = handleUploadClick;
                uploadBtn.classList.remove('hidden');
            } else {
                // 是别人的仓库：什么都不做 = 按钮保持隐藏
                // 仅显示滚动按钮(如果有内容)
                uploadBtn.innerHTML = '<i class="fa-solid fa-arrows-up-down"></i>';
                uploadBtn.title = '滚动';
                uploadBtn.onclick = handleScrollToggle;
                if (el.main.scrollHeight > el.main.clientHeight) {
                    uploadBtn.classList.remove('hidden');
                }
            }
            break;

        // === 场景 C: 版本/发布页面 ===
        case 'releases_list':
        case 'assets_list':
            backBtn.classList.remove('hidden');
            backBtn.innerHTML = '<i class="fa-solid fa-arrow-up"></i>';
            backBtn.title = '返回';
            backBtn.onclick = goUp;

            if (state.viewingReleasesForRepo) {
                const [owner] = state.viewingReleasesForRepo.split('/');
                if (state.user && owner === state.user.login) {
                    if (state.currentView === 'releases_list') {
                        newReleaseBtn.classList.remove('hidden');
                        newReleaseBtn.innerHTML = '<i class="fa-regular fa-folder-open"></i>';
                        newReleaseBtn.title = '发布新版本';
                        newReleaseBtn.onclick = () => {
                            const repo = state.repos.find(r => r.full_name === state.viewingReleasesForRepo) || 
                                         { full_name: state.viewingReleasesForRepo, owner: { login: owner }, default_branch: 'main' };
                            showReleaseManagerModal(repo, true); 
                        };
                    } else {
                        newReleaseBtn.classList.remove('hidden');
                        newReleaseBtn.innerHTML = '<i class="fa-solid fa-arrow-up-from-bracket"></i>';
                        newReleaseBtn.title = '打开上传面板';
                        newReleaseBtn.onclick = () => showPreUploadModal();
                    }
                }
            }
            break;

        // === 场景 D: 搜索结果 (内容搜索) ===
        case 'search_results':
             backBtn.classList.remove('hidden');
             backBtn.innerHTML = '<i class="fa-solid fa-arrow-up"></i>';
             backBtn.title = '返回上级';
             backBtn.onclick = goUp;
             break;

        // === 场景 E: 其他列表视图 (默认) ===
        case 'starred_repos':
        case 'other_user_repos':
        case 'own_repos':
        default:
            const isOwnRepos = state.currentView === 'own_repos' || !state.currentView;
            
            if (isOwnRepos) {
                newFolderBtn.classList.remove('hidden');
                newFolderBtn.innerHTML = '<i class="fa-regular fa-folder-open"></i>';
                newFolderBtn.title = '新建仓库';
                newFolderBtn.onclick = showCreateRepoModal;
            } else {
                backBtn.classList.remove('hidden');
                backBtn.innerHTML = '<i class="fa-solid fa-arrow-up"></i>';
                backBtn.onclick = goUp;
            }

            let repoSource = state.repos;
            let currentRepoPage = state.myReposPage;
            
            if (state.currentView === 'starred_repos') {
                repoSource = state.starredRepos;
                currentRepoPage = state.starredReposPage;
            } else if (state.currentView === 'other_user_repos') {
                repoSource = state.currentRepoList;
                currentRepoPage = state.userReposPage;
            }

            const totalRepoPages = Math.ceil((repoSource || []).length / state.REPOS_PER_PAGE) || 1;

            if (totalRepoPages > 1) {
                if (!isOwnRepos) {
                    newFolderBtn.classList.remove('hidden');
                    newFolderBtn.innerHTML = '<i class="fa-solid fa-arrow-left"></i>';
                    newFolderBtn.title = '上一页';
                    newFolderBtn.onclick = handlePrevRepoPage;
                    newFolderBtn.classList.toggle('disabled', currentRepoPage <= 1);
                } else if (currentRepoPage > 1) {
                     // 首页如果有上一页，放在返回键位置
                     backBtn.classList.remove('hidden');
                     backBtn.innerHTML = '<i class="fa-solid fa-arrow-left"></i>';
                     backBtn.title = '上一页';
                     backBtn.onclick = handlePrevRepoPage;
                }

                newFileBtn.classList.remove('hidden');
                newFileBtn.innerHTML = '<i class="fa-solid fa-arrow-right"></i>';
                newFileBtn.title = '下一页';
                newFileBtn.onclick = handleNextRepoPage;
                newFileBtn.classList.toggle('disabled', currentRepoPage >= totalRepoPages);
            }
            break;
    }
}






function handlePrevPage() {
    if (state.publicSearchPage > 1) {
        const newPage = state.publicSearchPage - 1;
        const query = state.publicSearchQuery;
        if (!query) {
            showToast('搜索词丢失，请重新搜索', 'error');
            return;
        }
        history.replaceState({ view: 'public_search_results', query: query, page: newPage }, '', window.location.pathname);
        searchPublicRepositories(query, newPage, false);
    } else {
        showToast('已经是第一页了');
    }
}

function handleNextPage() {
    const totalPages = Math.ceil(state.publicSearchTotalResults / state.publicSearchPerPage);
    if (state.publicSearchPage < totalPages) {
        const newPage = state.publicSearchPage + 1;
        const query = state.publicSearchQuery;
        if (!query) {
            showToast('搜索词丢失，请重新搜索', 'error');
            return;
        }
        history.replaceState({ view: 'public_search_results', query: query, page: newPage }, '', window.location.pathname);
        searchPublicRepositories(query, newPage, false);
    } else {
        showToast('已经是最后一页了');
    }
}

function handleScrollToggle() {
    const mainEl = el.main;
    // 判断是否已滚动到底部（留出1像素的误差）
    const atBottom = mainEl.scrollHeight - mainEl.scrollTop - mainEl.clientHeight < 1;

    if (atBottom) {
        mainEl.scrollTo({ top: 0, behavior: 'smooth' });
    } else {
        mainEl.scrollTo({ top: mainEl.scrollHeight, behavior: 'smooth' });
    }
}



async function handleGlobalSearch(query) {
    document.getElementById('globalSearchHistoryContainer').classList.add('hidden');
    addSearchToHistory(query);
    state.publicSearchCache.clear();
    state.repoListScrollPosition = 0;

    const rawMatch = query.match(/^https?:\/\/raw\.githubusercontent\.com\/([^\/]+)\/([^\/]+)\/([^\/]+)\/(.+)$/);
    const urlData = parseGithubUrl(query);
    const atUserMatch = query.match(/^@([a-zA-Z0-9_-]+)$/);
    const fileSearchMatch = query.match(/^#(.+)$/);

    try {
        if (rawMatch) {
            const owner = rawMatch[1];
            const repo = rawMatch[2];
            const branch = rawMatch[3];
            const filePath = rawMatch[4];
            
            const lastSlash = filePath.lastIndexOf('/');
            const dirPath = lastSlash !== -1 ? filePath.substring(0, lastSlash + 1) : '';
            const repoFullName = `${owner}/${repo}`;

            const res = await fetch(`https://api.github.com/repos/${repoFullName}`, { headers: { Authorization: `token ${state.token}` } });
            if (!res.ok) throw new Error('仓库不存在或无法访问');
            const repoData = await res.json();

            state.viewingOwner = repoData.owner.login;
            state.currentView = 'other_user_repos';
            
            navigateToRepo(repoData, branch, dirPath);

        } else if (urlData) {
            if (urlData.repo) {
                const repoFullName = `${urlData.owner}/${urlData.repo}`;
                const res = await fetch(`https://api.github.com/repos/${repoFullName}`, { headers: { Authorization: `token ${state.token}` } });
                if (!res.ok) throw new Error('仓库不存在或为私有');
                const repoData = await res.json();
                
                state.viewingOwner = repoData.owner.login;
                state.currentView = 'other_user_repos';
                
                let targetPath = urlData.path;
                let targetBranch = repoData.default_branch;

                const branchMatch = query.match(/\/(?:blob|tree)\/([^\/]+)(?:\/(.*))?$/);
                if (branchMatch) {
                    targetBranch = branchMatch[1];
                    targetPath = branchMatch[2] || '';
                } else {
                    targetBranch = localStorage.getItem(`last_branch_${repoFullName}`) || repoData.default_branch;
                }

                if (query.includes('/blob/')) {
                    const lastSlash = targetPath.lastIndexOf('/');
                    targetPath = lastSlash !== -1 ? targetPath.substring(0, lastSlash + 1) : '';
                } else if (targetPath && !targetPath.endsWith('/')) {
                    targetPath += '/';
                }

                navigateToRepo(repoData, targetBranch, targetPath);
            } else {
                await fetchAndDisplayUserRepos(urlData.owner);
            }
        } else if (atUserMatch) {
            await fetchAndDisplayUserRepos(atUserMatch[1]);
        } else if (fileSearchMatch) {
            const fileName = fileSearchMatch[1];
            await searchGlobalFiles(fileName);
        } else {
            await searchPublicRepositories(query);
        }
    } catch (error) {
        showToast(error.message, 'error');
    } finally {
        el.globalSearchInput.value = '';
        el.globalSearchContainer.classList.add('hidden');
        el.globalSearchToggleBtn.classList.remove('active');
    }
}



async function fetchUserRepos(username) {
    try {
        const res = await fetch(`https://api.github.com/users/${username}/repos`, {
            headers: {
                Authorization: `token ${state.token}`,
                'User-Agent': 'Mozilla/5.0'
            },
            cache: 'no-store'
        });

        if (!res.ok) {
            let errorMsg = `获取 ${username} 的仓库失败 (HTTP ${res.status})`;
            if (res.status === 404) {
                errorMsg = `用户 ${username} 不存在。`;
            }
            throw new Error(errorMsg);
        }

        const repos = await res.json();
        return repos;
    } catch (err) {
        showToast(err.message, 'error');
        el.repoList.innerHTML = `<div class="empty-state"><i class="fa fa-exclamation-circle"></i><p>${err.message}</p></div>`;
        return [];
    }
}


async function _renderAndFetchUserRepos(username, showMainLoader = true) {
    // --- 核心修改：只有在需要时才显示主加载动画 ---
    if (showMainLoader) {
        el.repoList.innerHTML = '<div class="loading-spinner"><div class="spinner"></div></div>';
    }
    
    state.viewingOwner = username;
    state.currentView = 'other_user_repos';
    updateGlobalSearchVisibility();
    showRepoListView();
    
    const repos = await fetchUserRepos(username);
     
    renderRepoList(repos);
    
}

async function fetchAndDisplayUserRepos(username) {
    history.pushState({ view: 'other_user_repos', owner: username }, '', window.location.pathname);
    await _renderAndFetchUserRepos(username);
}
async function searchGlobalFiles(query) {
    if (!query) return;

    toggleView(false);
    el.searchToggleBtn.classList.add('hidden');
    el.multiSelectToggleBtn.classList.add('hidden');
    el.sortToggleBtn.classList.add('hidden');
    state.currentView = 'search_results';
    updateHomeStarredButtonState();
    updateGlobalSearchVisibility();
    updatePaginationUI();

    el.fileList.innerHTML = '<div class="loading-spinner"><div class="spinner"></div></div>';
    el.currentRepo.textContent = `搜索: "${query}"`;
    history.pushState({ view: 'search_results', query: query }, '', window.location.pathname);
    state.currentPath = '';
    renderPathNav();
    el.branchSwitcherContainer.classList.add('hidden');

    try {
        
        
        await fetchRepos(true, false);
        const reposToSearch = [...state.repos];
        const totalRepos = reposToSearch.length;
        const allResults = [];

        for (let i = 0; i < totalRepos; i++) {
            const repo = reposToSearch[i];
            el.currentRepo.textContent = `搜索中 (${i + 1}/${totalRepos}): ${repo.name}`;
            
            try {
                const url = `https://api.github.com/repos/${repo.full_name}/git/trees/${repo.default_branch}?recursive=1`;
                const res = await fetch(url, { headers: { Authorization: `token ${state.token}` } });

                if (res.ok) {
                    const data = await res.json();
                    const queryLower = query.toLowerCase();
                    
                    data.tree.forEach(item => {
                        if (item.type === 'blob' && item.path.toLowerCase().includes(queryLower)) {
                            allResults.push({
                                name: item.path.split('/').pop(),
                                path: item.path,
                                sha: item.sha,
                                html_url: `https://github.com/${repo.full_name}/blob/${repo.default_branch}/${item.path}`,
                                repository: repo
                            });
                        }
                    });
                } else {
                    console.warn(`无法搜索仓库 ${repo.name}: ${res.statusText}`);
                }
            } catch (e) {
                console.error(`搜索仓库 ${repo.name} 时出错:`, e);
            }
        }

        el.currentRepo.textContent = `搜索: "${query}"`;
        state.isSearchResultsView = true;
        state.lastSearchResults = allResults;
        renderGlobalSearchResults(allResults);

    } catch (error) {
        showToast(error.message, 'error');
        el.fileList.innerHTML = `<div class="empty-state"><p>${error.message}</p></div>`;
    }
}

function renderGlobalSearchResults(items) {
    const listEl = el.fileList;
    listEl.innerHTML = '';

    if (items.length === 0) {
        listEl.innerHTML = '<div class="empty-state"><p>未在您的仓库中找到匹配的文件</p></div>';
        return;
    }

    items.sort((a, b) => {
        const repoCompare = a.repository.full_name.localeCompare(b.repository.full_name);
        if (repoCompare !== 0) return repoCompare;
        return a.path.localeCompare(b.path);
    });

    items.forEach(item => {
        const itemEl = document.createElement('div');
        itemEl.className = 'file-item';
        const repoName = item.repository.name;
        const filePath = item.path;
        
        const fileExtension = item.name.split('.').pop()?.toLowerCase();
        const rawUrl = `https://raw.githubusercontent.com/${item.repository.full_name}/${item.repository.default_branch}/${item.path}`;
        const imageUrl = getProxiedUrl(rawUrl);

        if (state.viewMode === 'grid' && IMAGE_EXTS.includes(fileExtension)) {
            itemEl.classList.add('is-image-grid');
            itemEl.innerHTML = `
                <div class="file-thumbnail-container loading" data-image-url="${escapeHtml(imageUrl)}" data-image-name="${escapeHtml(item.name)}">
                     <i class="fa fa-spinner fa-spin thumbnail-loader-icon"></i>
                     <div class="thumbnail-error retry-trigger" title="点击重试"><i class="fa fa-repeat"></i></div>
                </div>
                <div class="file-info">
                    <p class="file-name">${escapeHtml(item.name)}</p>
                    <p class="file-meta">${escapeHtml(repoName)}</p>
                </div>
            `;
        } else {
            itemEl.classList.add('search-result-item');
            const icon = getFileIcon(item.name);
            itemEl.innerHTML = `
                <div class="file-icon"><i class="fa ${icon}"></i></div>
                <div class="file-info">
                    <p class="file-name">${escapeHtml(item.name)}</p>
                    <p class="file-meta search-result-path-list">${escapeHtml(repoName)}/${escapeHtml(filePath)}</p>
                </div>
            `;
        }

        const fileObjectForActions = {
            name: item.name,
            path: item.path,
            sha: item.sha,
            html_url: item.html_url,
            download_url: rawUrl,
            type: 'file',
            repository: item.repository
        };

        itemEl.addEventListener('click', async () => {
            const url = getProxiedUrl(fileObjectForActions.download_url);
            
            if (IMAGE_EXTS.includes(fileExtension) || VIDEO_EXTS.includes(fileExtension)) {
                const preview = document.getElementById('mediaPreview');
                const img = document.getElementById('mediaPreviewImg');
                const video = document.getElementById('mediaPreviewVideo');
                if (IMAGE_EXTS.includes(fileExtension)) {
                    img.src = url;
                    img.style.display = '';
                    video.style.display = 'none';
                } else {
                    video.src = url;
                    video.style.display = '';
                    img.style.display = 'none';
                    video.load();
                }
                preview.classList.remove('hidden');
                uiStateStack.push(hideMediaPreview);
                return;
            }

            if (AUDIO_EXTS.includes(fileExtension)) {
                const nameWithoutExt = fileObjectForActions.name.substring(0, fileObjectForActions.name.lastIndexOf('.'));
                audioManager.play(url, nameWithoutExt);
                return;
            }

            if (NON_EDITABLE_EXTS.includes(fileExtension)) {
                downloadFile(fileObjectForActions);
                return;
            }

            state.editingFile = fileObjectForActions;
            el.editFileName.textContent = `${fileObjectForActions.name}`;
            el.fileContent.value = '';
            showEditStatus('', '');
            showEditModal();
            el.saveEdit.classList.add('hidden');
            try {
                const repoRes = await fetch(`https://api.github.com/repos/${item.repository.full_name}`, { headers: { Authorization: `token ${state.token}` } });
                if (!repoRes.ok) throw new Error('无法获取仓库详情');
                const fullRepoData = await repoRes.json();
                const branch = fullRepoData.default_branch;
                const contentRes = await fetch(`https://api.github.com/repos/${item.repository.full_name}/contents/${item.path}?ref=${branch}`, { headers: { Authorization: `token ${state.token}` } });
                if (!contentRes.ok) throw new Error((await contentRes.json()).message || '加载文件内容失败');
                const contentData = await contentRes.json();
                const content = decodeURIComponent(escape(atob(contentData.content)));
                el.fileContent.value = content;
                state.originalContent = content;
                state.fileSha = contentData.sha;
                state.currentRepo = item.repository.full_name;
                state.currentBranch = branch;
                state.viewingOwner = item.repository.owner.login;
                el.editorOverlay.classList.remove('show');
                el.fileContent.oninput = checkContentChanges;
                checkContentChanges();
                const isOwner = state.user && state.viewingOwner === state.user.login;
                el.saveEdit.classList.toggle('hidden', !isOwner);
                el.revertEditBtn.classList.toggle('hidden', !isOwner);
                el.fileContent.readOnly = !isOwner;
            } catch (error) {
                showToast(`打开文件失败: ${error.message}`, 'error');
                showEditStatus(`错误：${error.message}`, 'error');
                el.editorOverlay.classList.remove('show');
            }
        });

        itemEl.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            const repoData = item.repository;
            state.currentRepo = repoData.full_name;
            state.viewingOwner = repoData.owner.login;

            const fileForMenu = {
                name: item.name,
                path: item.path,
                sha: item.sha,
                html_url: item.html_url,
                download_url: `https://raw.githubusercontent.com/${repoData.full_name}/${repoData.default_branch}/${item.path}`,
                type: 'file',
                repository: item.repository
            };
            
            showContextMenu(e, fileForMenu);

            fetch(`https://api.github.com/repos/${state.currentRepo}`, { headers: { Authorization: `token ${state.token}` } })
                .then(res => {
                    if (!res.ok) throw new Error('无法获取仓库详情');
                    return res.json();
                })
                .then(fullRepoData => {
                    const existingRepoIndex = state.repos.findIndex(r => r.id === fullRepoData.id);
                    if (existingRepoIndex > -1) {
                        state.repos[existingRepoIndex] = fullRepoData;
                    } else {
                        state.repos.push(fullRepoData);
                    }
                })
                .catch(error => {
                    console.warn(`后台获取仓库详情失败: ${error.message}`);
                });
        });
        listEl.appendChild(itemEl);
    });
    
    processImagePlaceholders();
}






function updateGlobalSearchVisibility() {
    const globalSearchToggleBtn = document.getElementById('globalSearchToggleBtn');
    if (!globalSearchToggleBtn) return;

    const shouldHide = state.currentRepo !== null && state.currentView === 'own_repos';
    
    globalSearchToggleBtn.classList.toggle('hidden', shouldHide);
}


function updateHomeStarredButtonState() {
    const viewStarredBtn = document.getElementById('viewStarredBtn');
    if (!viewStarredBtn) return;
    const icon = viewStarredBtn.querySelector('i');
    
    const isAtMyRepoRoot = state.currentRepo === null && state.currentView === 'own_repos';

    if (isAtMyRepoRoot) {
        icon.className = 'fa-regular fa-star';
        viewStarredBtn.title = '查看星标仓库';
    } else {
        icon.className = 'fa-regular fa-house';
        viewStarredBtn.title = '返回我的仓库';
    }
}






async function starRepository(repoFullName) {
    const response = await fetch(`https://api.github.com/user/starred/${repoFullName}`, {
        method: 'PUT',
        headers: { 'Authorization': `token ${state.token}`, 'Content-Length': 0 }
    });
    if (response.status !== 204) throw new Error('关注失败');
}

async function unstarRepository(repoFullName) {
    const response = await fetch(`https://api.github.com/user/starred/${repoFullName}`, {
        method: 'DELETE',
        headers: { 'Authorization': `token ${state.token}` }
    });
    if (response.status !== 204) throw new Error('取消关注失败');
}



let repoToFork = null;

function showForkRepoModal(repo) {
    repoToFork = repo;
    const modal = document.getElementById('forkRepoModal');
    const originInfo = document.getElementById('forkOriginInfo');
    const nameInput = document.getElementById('forkRepoNameInput');
    const confirmBtn = document.getElementById('forkRepoConfirmBtn');
    const errorDiv = document.getElementById('forkRepoError');

    originInfo.textContent = `复刻 ${repo.full_name} 仓库到自己名下`;
    nameInput.value = repo.name;
    confirmBtn.disabled = true;
    errorDiv.style.display = 'none';

    modal.classList.remove('hidden');

    const validateInput = () => {
        const newName = nameInput.value.trim();
        
        errorDiv.style.display = 'none';

        if (!newName) {
            confirmBtn.disabled = true;
            return;
        }

        const nameExists = state.myRepos.some(repo => repo.name.toLowerCase() === newName.toLowerCase());

        if (nameExists) {
            errorDiv.textContent = '该仓库名已存在';
            errorDiv.style.display = 'block';
            confirmBtn.disabled = true;
        } else {
            confirmBtn.disabled = false;
        }
    };

    validateInput();

    nameInput.addEventListener('input', validateInput);

    document.getElementById('forkRepoConfirmBtn').onclick = async () => {
        const newName = nameInput.value.trim();
        if (newName) {
            await forkRepository(repo, newName, confirmBtn);
        }
    };

    document.getElementById('closeForkRepoModalBtn').onclick = hideForkRepoModal;
    document.getElementById('forkRepoCancelBtn').onclick = hideForkRepoModal;
}

function hideForkRepoModal() {
    repoToFork = null;
    const modal = document.getElementById('forkRepoModal');
    modal.classList.add('hidden');
}


async function forkRepository(originalRepo, newName, button) {
    button.disabled = true;
    button.innerHTML = '<span>复刻中</span><i class="fa fa-spinner fa-spin"></i>';
    showToast(`正在复刻仓库 ${originalRepo.full_name}...`);

    try {
        const res = await fetch(`https://api.github.com/repos/${originalRepo.full_name}/forks`, {
            method: 'POST',
            headers: { 
                'Authorization': `token ${state.token}`,
                'Accept': 'application/vnd.github.v3+json',
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ name: newName })
        });

        if (res.status === 202) {
            hideForkRepoModal();
            showToast('复刻请求已发送！仓库正在后台创建，请稍后刷新您的仓库列表。', 'success', 3000);
            setTimeout(() => {
                fetchRepos(true); 
            }, 5000);
        } else {
            const errorData = await res.json();
            throw new Error(errorData.message || `复刻失败 (HTTP ${res.status})`);
        }
    } catch (error) {
        showToast(`复刻失败: ${error.message}`, 'error');
    } finally {
        button.disabled = false;
        button.innerHTML = '确认复刻';
    }
}







function getFileMimeType(filename) {
    const extension = filename.split('.').pop().toLowerCase();
    const mimeMap = {
        'apk': 'application/vnd.android.package-archive',
        'ipa': 'application/octet-stream', // iOS应用包也经常被识别为通用二进制
        'txt': 'text/plain',
        'html': 'text/html',
        'css': 'text/css',
        'js': 'application/javascript',
        'json': 'application/json',
        'xml': 'application/xml',
        'jpg': 'image/jpeg',
        'jpeg': 'image/jpeg',
        'png': 'image/png',
        'gif': 'image/gif',
        'svg': 'image/svg+xml',
        'mp4': 'video/mp4',
        'mp3': 'audio/mpeg',
        'zip': 'application/zip',
        'pdf': 'application/pdf'
    };
    return mimeMap[extension] || 'application/octet-stream';
}



function estimateLocalStorageUsage() {
    try {
        const data = Object.keys(localStorage).map(key => localStorage[key]);
        return new Blob(data).size;
    } catch (e) {
        let total = 0;
        for (let x in localStorage) {
            if (!localStorage.hasOwnProperty(x)) continue;
            total += (localStorage[x].length + x.length) * 2;
        }
        return total;
    }
}

async function autoClearCacheIfNeeded() {
    const USAGE_THRESHOLD = 5 * 1024 * 1024; // 4MB
    
    if (estimateLocalStorageUsage() < USAGE_THRESHOLD) {
        return;
    }

   // showToast('存储空间紧张，正在后台清理缓存...', 'info', 2000);

    let keysToRemove = [];
    for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key.startsWith('edit_cache_')) {
            keysToRemove.push(key);
        }
    }
    keysToRemove.forEach(key => localStorage.removeItem(key));

    if (estimateLocalStorageUsage() < USAGE_THRESHOLD) return;

    localStorage.removeItem('cached_repos');
    localStorage.removeItem('repos_cache_time');
    localStorage.removeItem('cached_starred_repos');
    localStorage.removeItem('starred_repos_cache_time');

    if (estimateLocalStorageUsage() < USAGE_THRESHOLD) return;

    try {
        const db = await initDB();
        await new Promise((resolve, reject) => {
            const transaction = db.transaction(['avatars'], 'readwrite');
            const store = transaction.objectStore('avatars');
            const getAllKeysRequest = store.getAllKeys();
            transaction.oncomplete = () => resolve();
            transaction.onerror = (event) => reject(event.target.error);
            getAllKeysRequest.onsuccess = () => {
                const keys = getAllKeysRequest.result;
                keys.forEach(key => {
                    if (key !== 'user_avatar') {
                        store.delete(key);
                    }
                });
            };
        });
    } catch (e) {
        console.error("自动清理头像缓存失败:", e);
    }
}

let db;
async function initDB() {
    return new Promise((resolve, reject) => {
        if (db) return resolve(db);
        const request = indexedDB.open('ImageCacheDB', 1);
        request.onerror = (event) => reject('数据库打开报错');
        request.onsuccess = (event) => {
            db = event.target.result;
            resolve(db);
        };
        request.onupgradeneeded = (event) => {
            const db = event.target.result;
            if (!db.objectStoreNames.contains('avatars')) {
                db.createObjectStore('avatars', { keyPath: 'key' });
            }
        };
    });
}

async function saveAvatarToDB(key, blob) {
    const db = await initDB();
    return new Promise((resolve, reject) => {
        const transaction = db.transaction(['avatars'], 'readwrite');
        const store = transaction.objectStore('avatars');
        const request = store.put({ key: key, value: blob, timestamp: Date.now() });
        request.onsuccess = () => resolve();
        request.onerror = (event) => reject('数据写入失败: ' + event.target.error);
    });
}

async function getAvatarFromDB(key, ownerLogin) {
    const db = await initDB();
    return new Promise((resolve, reject) => {
        const transaction = db.transaction(['avatars'], 'readwrite');
        const store = transaction.objectStore('avatars');
        const request = store.get(key);
        request.onerror = (event) => reject('数据读取失败: ' + event.target.error);
        request.onsuccess = () => {
            if (request.result) {
                const isOwnAvatar = state.user && ownerLogin === state.user.login;
                const CACHE_DURATION_OWN = 48 * 60 * 60 * 1000;
                const CACHE_DURATION_OTHER = 5 * 60 * 1000;
                const CACHE_DURATION = isOwnAvatar ? CACHE_DURATION_OWN : CACHE_DURATION_OTHER;

                if (Date.now() - request.result.timestamp < CACHE_DURATION) {
                    resolve(request.result.value);
                } else {
                    store.delete(key);
                    resolve(null);
                }
            } else {
                resolve(null);
            }
        };
    });
}









function setupEventListeners() {

function autoGrow(element) {

    
    
        element.style.height = 'auto';
        element.style.height = (element.scrollHeight) + 'px';
    }

    if (el.createRepoDescInput) {
        el.createRepoDescInput.addEventListener('input', function() {
            autoGrow(this);
        });
    }

    if (el.createFileContentInput) {
        el.createFileContentInput.addEventListener('input', function() {
            autoGrow(this);
        });
    }
    
    
    
    
el.currentRepo.addEventListener('click', () => {
    if (state.currentRepo && state.currentPath !== '') {
        navigateToPath('');
    }
});

el.ybp.onclick = () => {
    closeSideNav();
    showApiStatusPanel();
};
if (el.menuThemeToggle) {
    el.menuThemeToggle.onclick = () => {
        themeManager.toggle();
    };
    
    el.showPublishHelpBtn.onclick = showPublishHelpModal;
    el.closePublishHelpBtn.onclick = hidePublishHelpModal;
    el.publishHelpModal.onclick = (e) => {
        if (e.target === el.publishHelpModal) {
            hidePublishHelpModal();
        }
    };
    
    el.searchInFileBtn.addEventListener('click', () => toggleEditorSearch(true));
el.editorSearchCloseBtn.addEventListener('click', () => toggleEditorSearch(false));

el.editorSearchInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
        e.preventDefault();
        if (e.shiftKey) {
             navigateSearchMatches(-1);
        } else {
             navigateSearchMatches(1);
        }
    }
});
    el.fileList.addEventListener('click', (e) => {
        const item = e.target.closest('.file-item');
        if (!item) return;

        const filePath = item.dataset.filePath;
        const file = state.displayFiles.find(f => f.path === filePath);
        if (!file) return;

        const retryTrigger = e.target.closest('.retry-trigger');
        if (retryTrigger) {
            e.stopPropagation();
            const allFailedContainers = document.querySelectorAll('#fileList .file-thumbnail-container.error');
            if (allFailedContainers.length > 0) {
                showToast(`正在重试 ${allFailedContainers.length} 个失败的图片...`);
                allFailedContainers.forEach(container => {
                    container.classList.remove('error');
                    container.classList.add('loading');
                    loadThumbnailImage(container);
                });
            }
            return;
        }

        if (state.isMultiSelectMode) {
            item.classList.toggle('selected');
            if (state.selectedItems.has(file.path)) {
                state.selectedItems.delete(file.path);
            } else {
                state.selectedItems.add(file.path);
            }
            updateActionBar();
        } else {
            if (file.type === 'dir') {
                navigateToDir(file.name);
            } else {
                const fileExtension = file.name.split('.').pop()?.toLowerCase();
                const isMedia = IMAGE_EXTS.includes(fileExtension) || VIDEO_EXTS.includes(fileExtension) || AUDIO_EXTS.includes(fileExtension);
                if (!isMedia) {
                   editFile(file);
                }
            }
        }
    });

    el.fileList.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        const item = e.target.closest('.file-item');
        if (!item) return;
        const filePath = item.dataset.filePath;
        const file = state.displayFiles.find(f => f.path === filePath);
        if (!file) return;
        showContextMenu(e, file);
    });
el.editorSearchInput.addEventListener('input', performEditorSearch);
el.editorSearchPrevBtn.addEventListener('click', () => navigateSearchMatches(-1));
el.editorSearchNextBtn.addEventListener('click', () => navigateSearchMatches(1));
}
el.setAsSiteCloseBtn.onclick = hideSetAsSiteModal;
el.setAsSiteCancelBtn.onclick = hideSetAsSiteModal;

const setAsSiteSelector = document.getElementById('setAsSiteBranchSelector');
setAsSiteSelector.querySelector('.custom-branch-select-trigger').addEventListener('click', (e) => {
    e.stopPropagation();
    setAsSiteSelector.classList.toggle('open');
});

document.addEventListener('click', (e) => {
    if (!setAsSiteSelector.contains(e.target)) {
        setAsSiteSelector.classList.remove('open');
    }
});


el.manageAccountsBtn.addEventListener('click', showAccountManagerModal);
el.menuSwitchAccount.addEventListener('click', () => {
    closeSideNav();
    showAccountManagerModal();
});
el.closeAccountManagerModalBtn.addEventListener('click', closeAccountManagerModal);
el.showAddAccountModalBtn.addEventListener('click', () => showAddEditAccountModal());


el.closeAddEditAccountModalBtn.addEventListener('click', closeAddEditAccountModal);
el.addEditAccountCancelBtn.addEventListener('click', closeAddEditAccountModal);
el.addEditAccountSaveBtn.addEventListener('click', handleSaveAccount);

document.getElementById('repoDetailsCloseBtn').onclick = hideRepoDetailsModal;
el.repoDetailsModal.onclick = (e) => {
    if (e.target === el.repoDetailsModal) {
        hideRepoDetailsModal();
    }
};







let configuringDomainRepoFullName = null;

async function showCustomDomainModal(repoFullName) {
    state.configuringDomainRepoFullName = repoFullName;
    const repoName = repoFullName.split('/')[1];
    const repoToUpdate = state.repos.find(r => r.full_name === repoFullName);

    el.customDomainRepoName.textContent = `为仓库 "${repoName}" 设置域名`;
    el.customDomainInput.value = '';
    el.customDomainSaveBtn.disabled = true;
    el.customDomainError.style.display = 'none';
    el.customDomainModal.classList.remove('hidden');
    uiStateStack.push(hideCustomDomainModal);

    el.customDomainInput.disabled = true;

    try {
        const url = `https://api.github.com/repos/${repoFullName}/contents/CNAME`;
        const response = await fetch(url, {
            headers: { 'Authorization': `token ${state.token}` }
        });

        if (response.ok) {
            const data = await response.json();
            const currentDomain = atob(data.content);
            el.customDomainInput.value = currentDomain;
            if (repoToUpdate) repoToUpdate.customDomain = currentDomain;
        } else {
            
            if (repoToUpdate) repoToUpdate.customDomain = null;
        }

    } catch (error) {
        console.error('获取CNAME文件失败:', error);
        el.customDomainInput.placeholder = '加载域名失败，请重试';
    } finally {
        el.customDomainInput.disabled = false;
        el.customDomainInput.dispatchEvent(new Event('input'));
    }
}

function hideCustomDomainModal() {
    el.customDomainModal.classList.add('hidden');
    state.configuringDomainRepoFullName = null;
    const index = uiStateStack.indexOf(hideCustomDomainModal);
    if (index > -1) uiStateStack.splice(index, 1);
}

async function handleSaveCustomDomain() {
    const domain = el.customDomainInput.value.trim();
    if (!domain || !state.configuringDomainRepoFullName) return;

    const saveBtn = el.customDomainSaveBtn;
    const spinner = saveBtn.querySelector('i');
    saveBtn.disabled = true;
    spinner.classList.remove('hidden');
    el.customDomainError.style.display = 'none';

    try {
        const [owner, repoName] = state.configuringDomainRepoFullName.split('/');
        const filePath = 'CNAME';
        const url = `https://api.github.com/repos/${owner}/${repoName}/contents/${filePath}`;
        
        let existingFileSha = null;
        try {
            const checkRes = await fetch(url, { headers: { 'Authorization': `token ${state.token}` } });
            if (checkRes.ok) {
                existingFileSha = (await checkRes.json()).sha;
            }
        } catch (e) {}

        const encodedContent = btoa(unescape(encodeURIComponent(domain)));
        const requestBody = {
            message: `feat: Set custom domain to ${domain}`,
            content: encodedContent,
            branch: state.repos.find(r => r.full_name === state.configuringDomainRepoFullName)?.default_branch || 'main'
        };

        if (existingFileSha) {
            requestBody.sha = existingFileSha;
        }

        const res = await fetch(url, {
            method: 'PUT',
            headers: { 'Authorization': `token ${state.token}`, 'Content-Type': 'application/json' },
            body: JSON.stringify(requestBody)
        });

        if (!res.ok) {
            const errorData = await res.json();
            throw new Error(errorData.message || '配置域名失败');
        }

        const repoToUpdate = state.repos.find(r => r.full_name === state.configuringDomainRepoFullName);
        if (repoToUpdate) {
            repoToUpdate.customDomain = domain;
            const cachedDomains = JSON.parse(localStorage.getItem('custom_domains_cache') || '{}');
            cachedDomains[repoToUpdate.full_name] = domain;
            localStorage.setItem('custom_domains_cache', JSON.stringify(cachedDomains));
        }

        showToast(`仓库 ${repoName} 的域名已配置为 ${domain}`);
        hideCustomDomainModal();
        renderPublishManagerLists();

    } catch (error) {
        el.customDomainError.textContent = `错误: ${error.message}`;
        el.customDomainError.style.display = 'block';
    } finally {
        saveBtn.disabled = false;
        spinner.classList.add('hidden');
    }
}




function showRemoveCustomDomainConfirmation(repo) {
    showDeleteModal(
        null,
        false,
        '确认取消域名绑定',
        `确定要为仓库 "${repo.name}" 取消自定义域名绑定吗？<br><br>此操作将从您的仓库中删除 CNAME 文件。`,
        async () => {
            await handleRemoveCustomDomain(repo);
        },
        '确认取消',
        'btn-danger'
    );
}

async function handleRemoveCustomDomain(repo) {
    showToast('正在取消域名绑定...');
    try {
        const [owner, repoName] = repo.full_name.split('/');
        const url = `https://api.github.com/repos/${owner}/${repoName}/contents/CNAME`;

        const checkRes = await fetch(url + `?ref=${repo.default_branch}`, {
            headers: { 'Authorization': `token ${state.token}` }
        });

        if (!checkRes.ok) {
            if (checkRes.status === 404) {
                showToast('域名配置已不存在', 'info');
                repo.customDomain = null;
                const cachedDomains = JSON.parse(localStorage.getItem('custom_domains_cache') || '{}');
                delete cachedDomains[repo.full_name];
                localStorage.setItem('custom_domains_cache', JSON.stringify(cachedDomains));
                renderPublishManagerLists();
                return;
            }
            throw new Error('无法获取当前的域名配置');
        }

        const fileData = await checkRes.json();
        const existingFileSha = fileData.sha;

        const res = await fetch(url, {
            method: 'DELETE',
            headers: { 'Authorization': `token ${state.token}`, 'Content-Type': 'application/json' },
            body: JSON.stringify({
                message: `build: Remove custom domain`,
                sha: existingFileSha,
                branch: repo.default_branch
            })
        });

        if (!res.ok) {
            const errorData = await res.json();
            throw new Error(errorData.message || '取消绑定失败');
        }

        repo.customDomain = null;
        const cachedDomains = JSON.parse(localStorage.getItem('custom_domains_cache') || '{}');
        delete cachedDomains[repo.full_name];
        localStorage.setItem('custom_domains_cache', JSON.stringify(cachedDomains));
        
        showToast(`仓库 "${repo.name}" 的自定义域名已成功取消绑定`);
        renderPublishManagerLists();

    } catch (error) {
        showToast(`操作失败: ${error.message}`, 'error');
        console.error(error);
    }
}










function validateAccountForm() {
    const name = el.accountNameInput.value.trim();
    const token = el.accountTokenInput.value.trim();

    if (editingAccountId) {
        el.addEditAccountSaveBtn.disabled = !name;
    } else {
        el.addEditAccountSaveBtn.disabled = !token;
    }
}
el.accountNameInput.addEventListener('input', validateAccountForm);
el.accountTokenInput.addEventListener('input', validateAccountForm);

    el.menuUsageGuide.onclick = () => {
    closeSideNav();
    showUsageGuideModal();
};
    el.closeUsageGuideBtn.onclick = hideUsageGuideModal;
    el.usageGuideModal.onclick = (e) => {
        if (e.target === el.usageGuideModal) {
            hideUsageGuideModal();
        }
    };
    
    el.proxyQuickToggle.addEventListener('click', () => {
        setProxyGlobalState(!state.proxyGlobalEnable, true);
    });
    el.proxyGlobalEnableToggle.addEventListener('change', (e) => {
        setProxyGlobalState(e.target.checked, true);
    });
    el.refreshApiStatusBtn.addEventListener('click', handleRefreshApiStatus);
    el.ybp.onclick = () => {
    closeSideNav();
    showApiStatusPanel();
};
    el.closeApiStatusPanel.addEventListener('click', hideApiStatusPanel);
    el.apiStatusOverlay.addEventListener('click', hideApiStatusPanel);
    el.avatarContainer.addEventListener('click', () => {
        el.avatarUploadInput.click();
    });
    el.avatarUploadInput.addEventListener('change', handleAvatarChange);
    el.importBtn.addEventListener('click', importProxiesFromUrl);
    el.newFolderBtn.onclick = function() {
        if (!state.currentRepo) {
            showCreateRepoModal();
        } else {
            showCreateFolderModal();
        }
    };
   
el.authBtn.addEventListener('click', async () => {
    const token = el.tokenInput.value.trim();
    const btn = el.authBtn;
    const btnText = btn.querySelector('span');
    const spinner = btn.querySelector('i');
    btn.classList.remove('success', 'error');
    el.tokenInput.classList.remove('error');
    if (!token) {
        showToast('请输入GitHub访问令牌');
        el.tokenInput.classList.add('error');
        btn.classList.add('error');
        return;
    }
    btn.disabled = true;
    btnText.textContent = '正在验证';
    spinner.classList.remove('hidden');

    try {
        const res = await fetch('https://api.github.com/user', {
            headers: { Authorization: `token ${token}` }
        });

        if (!res.ok) {
            if (res.status === 401) {
                throw new Error('令牌无效或已过期');
            }
            throw new Error(`验证失败: ${res.statusText}`);
        }

        const scopesHeader = res.headers.get('x-oauth-scopes');

        if (scopesHeader !== null) {
            if (!scopesHeader.includes('repo')) {
                showToast('此经典令牌权限不足，大部分功能将无法使用。', 'error', 6000);
            }
        }

        const userData = await res.json(); 

        let existingAccount = state.accounts.find(acc => acc.token === token);
        if (!existingAccount) {
            const newAccount = {
                id: `gh_${Date.now()}`,
                name: `${userData.login}`, 
                token: token
            };
            state.accounts.push(newAccount);
            saveAccounts();
            existingAccount = newAccount;
            showToast('新账号已自动保存');
        }
        
        setActiveAccount(existingAccount.id);
        
        btn.classList.add('success');
        btnText.textContent = '登录成功 ✓';
        spinner.classList.add('hidden');
        state.shouldAnimateList = true;
        
        await Promise.all([
            fetchUserInfo(), 
            fetchRepos(true),
        ]);

        setTimeout(async () => {
            showApp();
            showToast('欢迎回来！');

            if (state.proxies.length === 0) {
                findAndSetBestProxy();
            } else if (state.autoSelectProxy) {
                findAndSetBestProxy();
            } else {
                state.activeProxyIndex = parseInt(localStorage.getItem('active_proxy_index') || '0');
                state.proxyGlobalEnable = JSON.parse(localStorage.getItem('proxy_global_enable') || 'true');
                saveProxyConfig();
            }

            btn.disabled = false;
            btnText.textContent = '登录';
            btn.classList.remove('success');
        }, 1000);

    } catch (error) {
        showToast(error.message || '网络连接失败，请重试');
        el.tokenInput.classList.add('error');
        btn.classList.add('error');
        btn.disabled = false;
        btnText.textContent = '登录';
        spinner.classList.add('hidden');
    }
});


    [el.sideNavToggleBtn, el.mainOverlay].forEach(element => {
    element.addEventListener('click', () => {
        el.sideNav.classList.toggle('open');
        el.mainOverlay.classList.toggle('open');
    });
});
    el.createBranchCancel.onclick = function() {
        hideCreateBranchModal();
    };
    el.cancelSelectBtn.addEventListener('click', () => toggleMultiSelectMode(false));
    el.selectAllBtn.addEventListener('click', () => {
        const allVisiblePaths = state.displayFiles.map(f => f.path);
        const areAllSelected = allVisiblePaths.length > 0 && allVisiblePaths.every(path => state.selectedItems.has(path));
        allVisiblePaths.forEach(path => {
            if (areAllSelected) {
                state.selectedItems.delete(path);
            } else {
                state.selectedItems.add(path);
            }
        });
        renderFileList();
    });
    el.invertSelectBtn.addEventListener('click', () => {
        const allVisiblePaths = state.displayFiles.map(f => f.path);
        allVisiblePaths.forEach(path => {
            if (state.selectedItems.has(path)) {
                state.selectedItems.delete(path);
            } else {
                state.selectedItems.add(path);
            }
        });
        renderFileList();
    });
    el.downloadBtn.addEventListener('click', downloadSelectedItemsAsZip);
    el.deleteBtn.addEventListener('click', () => {
        if (state.selectedItems.size === 0) return;
        const selectedFiles = state.files.filter(f => state.selectedItems.has(f.path));
        const fileCount = selectedFiles.filter(f => f.type === 'file').length;
        const dirCount = selectedFiles.filter(f => f.type === 'dir').length;
        let desc = `确定要删除这 ${state.selectedItems.size} 个项目吗？`;
        if (fileCount > 0 && dirCount > 0) desc += ` (包含 ${fileCount} 个文件和 ${dirCount} 个文件夹)`;
        else if (fileCount > 0) desc += ` (共 ${fileCount} 个文件)`;
        else if (dirCount > 0) desc += ` (共 ${dirCount} 个文件夹)`;
        showDeleteModal(null, false, '确认批量删除', desc, async function() {
            showToast(`开始删除 ${selectedFiles.length} 个项目...`);
            for (const item of selectedFiles) {
                await deleteSingleItem(item);
            }
            showToast('批量删除完成！');
            toggleMultiSelectMode(false);
            state.shouldAnimateList = true;
            fetchFiles(true);
        });
    });
    function handleInteractionToCloseMenu(e) {
        if (!el.contextMenu.classList.contains('hidden') && !el.contextMenu.contains(e.target)) {
            hideContextMenu();
        }
    }
    document.addEventListener('mousedown', handleInteractionToCloseMenu);
    document.addEventListener('touchstart', handleInteractionToCloseMenu, { passive: true });
    document.addEventListener('click', function(e) {
        if (!el.mainMenuPopup.classList.contains('hidden') && !el.mainMenuPopup.contains(e.target) && !e.target.closest('#mainMenuBtn')) {
            hideMainMenuPopup();
        }
        if (!el.customSortDropdown.classList.contains('hidden') && !el.customSortDropdown.contains(e.target) && !e.target.closest('#sortToggleBtn')) {
            hideSortDropdown();
        }
    });
    
    
    
el.menuLogout.onclick = () => {
    closeSideNav();
    
    const performLogout = () => {
        state.token = null; 
        setActiveAccount(null);
        localStorage.removeItem('user_avatar');
        localStorage.removeItem('cached_repos');
        localStorage.removeItem('repos_cache_time');
        state.repos = [];
        state.currentRepo = null;
        state.user = null;
        showAuth();
    };

    showDeleteModal(
        null,
        false,
        '确认退出',
        '您确定要退出当前账号吗？',
        performLogout,
        '确认退出',
        'btn-danger'
    );
};
    el.menuProxySettings.onclick = () => {
    closeSideNav();
    openProxySettingsModal();
};
    

el.menuBatchPublishSites.onclick = () => {
    closeSideNav();
    showPublishManagerModal();
};
    el.closeEditModal.onclick = hideEditModal;
    el.cancelEdit.onclick = hideEditModal;
    el.saveEdit.onclick = saveEditedFile;
    el.backBtn.onclick = goUp;
    el.newFileBtn.onclick = showCreateFileModal;
    // 更新原有绑定
    el.uploadBtn.onclick = handleUploadClick;
    
    // 新增面板按钮绑定
    el.preUploadAddBtn.onclick = () => el.fileUploadInput.click();
    
    el.preUploadClearBtn.onclick = () => {
        state.pendingUploadFiles = [];
        renderPreUploadList();
    };
    
    el.preUploadStartBtn.onclick = handleStartBatchUpload;
    el.fileUploadInput.addEventListener('change', handleFilesSelected);
    el.searchToggleBtn.addEventListener('click', () => {
        el.searchInput.classList.toggle('hidden');
        if (!el.searchInput.classList.contains('hidden')) {
            el.searchInput.focus();
            el.searchInput.style.display = 'block';
        } else {
            el.searchInput.value = '';
            state.searchQuery = '';
            applyFiltersAndSort();
            renderFileList();
            el.searchInput.style.display = 'none';
        }
    });
    if (el.searchInput) {
    el.searchInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            const query = el.searchInput.value.trim();
            if (query) {
                performRecursiveSearch(query);
            } else {
                state.isLocalSearchResultsView = false;
                applyFiltersAndSort();
                renderFileList();
            }
        }
    });

    el.searchInput.addEventListener('input', () => {
        if (el.searchInput.value.trim() === '') {
            state.isLocalSearchResultsView = false;
            applyFiltersAndSort();
            renderFileList();
        }
    });
}
    el.multiSelectToggleBtn.onclick = () => {
        toggleMultiSelectMode(!state.isMultiSelectMode);
    };
    el.sortToggleBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        if (el.customSortDropdown.classList.contains('hidden')) {
            showSortDropdown();
        } else {
            hideSortDropdown();
        }
    });
    el.customSortDropdown.addEventListener('click', (e) => {
        const item = e.target.closest('.dropdown-item');
        state.shouldAnimateList = true;
        if (!item) return;
        hideSortDropdown();
        const newSortBy = item.dataset.value;
        const newPriority = item.dataset.priority;
        if (newSortBy) {
            state.sortBy = newSortBy;
            localStorage.setItem('sort_by', state.sortBy);
        }
        if (newPriority) {
            state.directorySortPriority = newPriority;
            localStorage.setItem('directory_sort_priority', state.directorySortPriority);
        }
        updateSortDropdownUI();
        applyFiltersAndSort();
        renderFileList();
    });
    if (el.customSortDropdown) {
        Array.from(el.customSortDropdown.children).forEach(item => {
            if (item.dataset.value === state.sortBy) {
                item.classList.add('selected');
            }
        });
    }
    if (el.viewToggleBtn) {
    updateFileListViewMode();
    el.viewToggleBtn.addEventListener('click', () => {
        state.viewMode = state.viewMode === 'list' ? 'grid' : 'list';
        localStorage.setItem('view_mode', state.viewMode);
        updateFileListViewMode();
        
        if (state.isSearchResultsView) {
            renderGlobalSearchResults(state.lastSearchResults);
        } else {
            renderFileList();
        }
    });
}
    el.proxyCancelSettingsBtn.addEventListener('click', closeProxySettingsModal);
        el.proxyAutoSelectToggle.addEventListener('click', async () => {
    state.autoSelectProxy = !state.autoSelectProxy;
    localStorage.setItem('proxy_auto_select', JSON.stringify(state.autoSelectProxy));
    updateProxySettingsUI();

    if (state.autoSelectProxy) {
        await findAndSetBestProxy(true);
    } else {
        showToast('已关闭自动优选');
    }
});
    el.proxyAddBtn.addEventListener('click', () => openAddEditProxyModal());
    el.proxyTestAllBtn.addEventListener('click', testAllProxies);
    el.proxyClearAllBtn.addEventListener('click', showConfirmClearAllProxiesModal);
    el.addEditProxyUrlInput.addEventListener('input', validateAddEditProxyInput);
    el.confirmDeleteProxyCancelBtn.addEventListener('click', hideConfirmDeleteProxyModal);
    el.clearAllProxiesCancelBtn.addEventListener('click', hideConfirmClearAllProxiesModal);
    el.clearAllProxiesConfirmBtn.addEventListener('click', clearAllProxiesConfirmed);
    el.renameInput.oninput = function() {
        el.renameConfirm.disabled = !el.renameInput.value.trim() || el.renameInput.value.trim() === state.selectedFile?.name;
    };
    el.renameCancel.onclick = function() {
        hideRenameModal();
    };
    el.deleteCancel.onclick = function() {
        hideDeleteModal();
    };
    el.createRepoCancel.onclick = function() {
        hideCreateRepoModal();
    };
    el.createFolderInput.oninput = function() {
        el.createFolderConfirm.disabled = !el.createFolderInput.value.trim();
    };
    el.createFolderCancel.onclick = function() {
        hideCreateFolderModal();
    };
    el.createFileNameInput.oninput = function() {
        el.createFileConfirm.disabled = !el.createFileNameInput.value.trim() || el.createFileNameInput.value.trim().endsWith('/');
    };
    el.createFileCancel.onclick = function() {
        hideCreateFileModal();
    };
    el.createBranchNameInput.oninput = function() {
        el.createBranchConfirm.disabled = !el.createBranchNameInput.value.trim();
    }
    el.menuContextMenuSettings.onclick = () => {
    closeSideNav();
    openContextMenuSettingsModal();
};
    el.contextMenuSettingsCloseBtn.onclick = () => {
        hideContextMenuSettingsModal();
    };
    el.contextMenuSettingsModal.querySelector('.context-menu-settings-tabs').addEventListener('click', e => {
        if (e.target.matches('.tab-btn')) {
            const container = e.target.parentElement;
            container.querySelector('.active').classList.remove('active');
            e.target.classList.add('active');
            renderContextMenuSettings(e.target.dataset.tab);
        }
    });
    
        el.repoList.addEventListener('click', async (e) => {
        const starButton = e.target.closest('.star-text-btn:not(.js-view-releases-btn)');
    if (!starButton) return;

        e.preventDefault();
        e.stopPropagation();

        const repoFullName = starButton.dataset.repoFullname;
        const isCurrentlyStarred = starButton.classList.contains('starred');

        starButton.disabled = true;
        starButton.textContent = '处理中...';

        try {
            if (isCurrentlyStarred) {
                await unstarRepository(repoFullName);
                state.starredRepos = state.starredRepos.filter(r => r.full_name !== repoFullName);
                showToast(`已取消关注 ${repoFullName}`);
            } else {
                await starRepository(repoFullName);
                const repoInfoRes = await fetch(`https://api.github.com/repos/${repoFullName}`, {
                    headers: { 'Authorization': `token ${state.token}` }
                });
                if (repoInfoRes.ok) {
                    state.starredRepos.unshift(await repoInfoRes.json());
                }
                showToast(`已关注 ${repoFullName}`);
            }
            const isNowStarred = !isCurrentlyStarred;
            starButton.textContent = isNowStarred ? '取消关注' : '关注';
            starButton.classList.toggle('starred', isNowStarred);

        } catch (error) {
            showToast(error.message, 'error');
            starButton.textContent = isCurrentlyStarred ? '取消关注' : '关注';
        } finally {
            starButton.disabled = false;
        }
    });
    
    
    
    el.repoList.addEventListener('click', (e) => {
    const releasesButton = e.target.closest('.js-view-releases-btn');
    if (!releasesButton) return;

    e.preventDefault();
    e.stopPropagation();

    state.repoListScrollPosition = el.main.scrollTop; // <-- 添加这一行

    const repoFullName = releasesButton.dataset.repoFullname;
    fetchAndDisplayReleases(repoFullName);
});
    
    el.repoList.addEventListener('click', (e) => {
    const forkButton = e.target.closest('.fork-text-btn');
    if (!forkButton) return;

    e.preventDefault();
    e.stopPropagation();

    const repoFullName = forkButton.dataset.repoFullname;
    const repoToFork = state.currentRepoList.find(r => r.full_name === repoFullName);
    
    if (repoToFork) {
        showForkRepoModal(repoToFork);
    } else {
        showToast('无法找到仓库数据，请稍后再试。', 'error');
    }
});

    el.contextMenuSettingsContent.addEventListener('change', e => {
        if (e.target.matches('input[type="checkbox"]')) {
            const { category, action } = e.target.dataset;
            const isVisible = e.target.checked;
            state.contextMenuVisibility[category][action] = isVisible;
            if (action === 'setAsMainSite') {
                 state.contextMenuVisibility.repo.copyMainSiteLink = isVisible;
            }
            saveContextMenuSettings();
        }
    });
    
    el.closeCustomDomainModalBtn.onclick = hideCustomDomainModal;
el.customDomainCancelBtn.onclick = hideCustomDomainModal;
el.customDomainSaveBtn.onclick = handleSaveCustomDomain;
el.customDomainInput.addEventListener('input', () => {
    el.customDomainSaveBtn.disabled = el.customDomainInput.value.trim() === '';
});
el.publishManageList.addEventListener('click', (e) => {
    const configureBtn = e.target.closest('.configure-domain-btn');
    const copyLinkBtn = e.target.closest('.copy-site-link-btn');
    const setAsMainSiteBtn = e.target.closest('.set-as-main-site-btn');
    const removeBtn = e.target.closest('.remove-domain-btn');

    if (removeBtn) {
        const repoFullName = removeBtn.dataset.repoFullname;
        if (repoFullName) {
            const repo = state.repos.find(r => r.full_name === repoFullName);
            if (repo) {
                showRemoveCustomDomainConfirmation(repo);
            }
        }
        return;
    }

    if (configureBtn) {
        const repoFullName = configureBtn.dataset.repoFullname;
        if (repoFullName) {
            showCustomDomainModal(repoFullName);
        }
        return;
    }
    
    if (setAsMainSiteBtn) {
        const repoFullName = setAsMainSiteBtn.dataset.repoFullname;
        const repo = state.repos.find(r => r.full_name === repoFullName);
        if (repo) {
            showPublishBranchSelectorModal(repo, 'mainSite');
        }
        return;
    }

    if (copyLinkBtn) {
        const repoFullName = copyLinkBtn.dataset.repoFullname;
        if (repoFullName && state.user && state.user.login) {
            const [owner, repoName] = repoFullName.split('/');
            const isMainSiteRepo = repoName === `${state.user.login}.github.io`;
            const siteUrl = isMainSiteRepo
                ? `https://${owner}.github.io/`
                : `https://${owner}.github.io/${repoName}/`;
            navigator.clipboard.writeText(siteUrl).then(() => {
                showToast(isMainSiteRepo ? '主站链接已复制' : '项目链接已复制');
            });
        }
        return;
    }
});

        const viewStarredBtn = document.getElementById('viewStarredBtn');
if (viewStarredBtn) {
    viewStarredBtn.addEventListener('click', () => {
        const icon = viewStarredBtn.querySelector('i');
        state.repoListScrollPosition = 0;
        
        if (icon.classList.contains('fa-star')) {
            history.pushState({ view: 'starred_repos' }, '', window.location.pathname);
            state.currentView = 'starred_repos';
            el.currentRepo.textContent = '星标仓库';
            fetchStarredRepos();
            updatePaginationUI();
        
        } else {
            history.pushState({ view: 'own_repos' }, '', window.location.pathname);
            state.currentRepo = null;
            state.currentPath = '';
            state.currentView = 'own_repos';
            el.currentRepo.textContent = '选择仓库';
            
            state.repos = [...state.myRepos]; 
            
            showRepoListView();
            renderRepoList(state.repos); 
            
            fetchRepos(true, false);
            updatePaginationUI();
        }

        updateHomeStarredButtonState();
        updateGlobalSearchVisibility();
    });
}
// 在多个视图切换函数中调用状态更新
const originalShowRepoListView = window.showRepoListView;
window.showRepoListView = function() {
    originalShowRepoListView.apply(this, arguments);
    updateHomeStarredButtonState();
};

const originalNavigateToRepo = window.navigateToRepo;
window.navigateToRepo = function() {
    originalNavigateToRepo.apply(this, arguments);
    updateHomeStarredButtonState();
};

const originalFetchAndDisplayUserRepos = window.fetchAndDisplayUserRepos;
window.fetchAndDisplayUserRepos = function() {
    originalFetchAndDisplayUserRepos.apply(this, arguments);
    updateHomeStarredButtonState();
};

const globalSearchToggleBtn = document.getElementById('globalSearchToggleBtn');
const globalSearchContainer = document.getElementById('globalSearchContainer');
const globalSearchInput = document.getElementById('globalSearchInput');



globalSearchInput.addEventListener('focus', () => {
        renderSearchHistory();
    });


globalSearchInput.addEventListener('blur', () => {
        setTimeout(() => {
            document.getElementById('globalSearchHistoryContainer').classList.add('hidden');
        }, 150); // 延迟150毫秒
    });

globalSearchToggleBtn.addEventListener('click', () => {
    globalSearchContainer.classList.toggle('hidden');
    globalSearchToggleBtn.classList.toggle('active');
    if (!globalSearchContainer.classList.contains('hidden')) {
        globalSearchInput.focus();
    }
});

globalSearchInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
        handleGlobalSearch(globalSearchInput.value);
    }
});


 
    
    // 关闭弹窗
    if (el.closeReleaseManagerBtn) {
        el.closeReleaseManagerBtn.onclick = hideReleaseManagerModal;
    }
    
    // 取消按钮
    if (el.cancelReleaseBtn) {
        el.cancelReleaseBtn.onclick = hideReleaseManagerModal;
    }

    // 提交发布按钮
    if (el.submitReleaseBtn) {
        el.submitReleaseBtn.onclick = createRelease;
    }
    
    // 点击遮罩层关闭
    if (el.releaseManagerModal) {
        el.releaseManagerModal.onclick = (e) => {
            if (e.target === el.releaseManagerModal) hideReleaseManagerModal();
        };
    }




//尾巴
}




async function performRecursiveSearch(query) {
    el.fileList.innerHTML = '<div class="loading-spinner"><div class="spinner"></div></div>';
    state.isLocalSearchResultsView = true;

    try {
        const [owner, repo] = state.currentRepo.split('/');
        const url = `https://api.github.com/repos/${owner}/${repo}/git/trees/${state.currentBranch}?recursive=1`;
        const res = await fetch(url, { headers: { Authorization: `token ${state.token}` } });
        if (!res.ok) throw new Error('API请求失败，可能结果过多');
        const data = await res.json();

        if (data.truncated) {
            showToast('文件过多，仅显示部分结果', 'info');
        }

        const queryLower = query.toLowerCase();
        const currentPath = state.currentPath;

        const results = data.tree.filter(item => {
            if (!item.path.startsWith(currentPath)) {
                return false;
            }
            const itemName = item.path.split('/').pop().toLowerCase();
            return itemName.includes(queryLower);
        }).map(item => {
            const isDir = item.type === 'tree';
            const relativePath = item.path.substring(currentPath.length);
            return {
                name: relativePath,
                path: item.path,
                sha: item.sha,
                size: item.size,
                type: isDir ? 'dir' : 'file',
                html_url: `https://github.com/${state.currentRepo}/${isDir ? 'tree' : 'blob'}/${state.currentBranch}/${item.path}`,
                download_url: isDir ? null : `https://raw.githubusercontent.com/${state.currentRepo}/${state.currentBranch}/${item.path}`,
            };
        });

        state.displayFiles = results;
        renderFileList();

    } catch (error) {
        showToast(`搜索失败: ${error.message}`, 'error');
        el.fileList.innerHTML = `<div class="empty-state"><p>${error.message}</p></div>`;
    }
}



(function() {
    const config = {
        minFontSize: 1, maxFontSize: 99, defaultFontSize: 10,
        storageKey: 'editor-font-size', scaleSensitivity: 0.01
    };
    function getSavedFontSize() { return parseInt(localStorage.getItem(config.storageKey)) || config.defaultFontSize; }
    function saveFontSize(size) { localStorage.setItem(config.storageKey, size); }
    function createFontSizeDisplay() {
        const display = document.createElement('div');
        display.style.cssText = `position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; padding: 6px 12px; border-radius: 12px; font-size: 12px; font-weight: bold; z-index: 1000; pointer-events: none; opacity: 0; transition: opacity 0.1s; background-color: rgba(0,0,0,0.5);`;
        return display;
    }
    function showFontSizeTooltip(display, size) {
        display.textContent = `${size}px`;
        display.style.opacity = '1';
        clearTimeout(display.hideTimeout);
        display.hideTimeout = setTimeout(() => { display.style.opacity = '0'; }, 1000);
    }
    function initGestureControls() {
        const observer = new MutationObserver(() => {
            const editModal = document.getElementById('editModal');
            const fileContent = document.getElementById('fileContent');
            const editorContainer = document.querySelector('.editor-container');
            if (editModal && fileContent && editorContainer && !fileContent.hasGestureControl) {
                fileContent.hasGestureControl = true;
                let currentSize = getSavedFontSize();
                fileContent.style.fontSize = currentSize + 'px';
                fileContent.style.lineHeight = (currentSize * 1.5) + 'px';
                const fontSizeDisplay = createFontSizeDisplay();
                editorContainer.appendChild(fontSizeDisplay);
                let initialDistance = 0, initialFontSize = currentSize, isPinching = false;
                function getTouchDistance(touches) { const dx = touches[0].clientX - touches[1].clientX, dy = touches[0].clientY - touches[1].clientY; return Math.sqrt(dx * dx + dy * dy); }
                function updateFontSize(newSize) {
                    newSize = Math.max(config.minFontSize, Math.min(config.maxFontSize, Math.round(newSize)));
                    if (newSize === currentSize) return;
                    const textarea = fileContent;
                    const oldScrollHeight = textarea.scrollHeight, oldScrollTop = textarea.scrollTop, viewportHeight = textarea.clientHeight;
                    const centerRatio = oldScrollHeight > viewportHeight ? (oldScrollTop + viewportHeight / 2) / oldScrollHeight : 0.5;
                    currentSize = newSize;
                    textarea.style.fontSize = newSize + 'px';
                    textarea.style.lineHeight = (newSize * 1.5) + 'px';
                    const newScrollHeight = textarea.scrollHeight;
                    const newScrollTop = (newScrollHeight * centerRatio) - (viewportHeight / 2);
                    textarea.scrollTop = newScrollTop;
                    showFontSizeTooltip(fontSizeDisplay, newSize);
                    saveFontSize(newSize);
                }
                fileContent.addEventListener('touchstart', (e) => { if (e.touches.length === 2) { e.preventDefault(); isPinching = true; initialDistance = getTouchDistance(e.touches); initialFontSize = currentSize; } }, { passive: false });
                fileContent.addEventListener('touchmove', (e) => { if (isPinching && e.touches.length === 2) { e.preventDefault(); const currentDistance = getTouchDistance(e.touches); const scale = currentDistance / initialDistance; const newSize = initialFontSize * scale; updateFontSize(newSize); } }, { passive: false });
                fileContent.addEventListener('touchend', () => { if (isPinching) isPinching = false; });
                fileContent.addEventListener('wheel', (e) => { if (e.ctrlKey || e.metaKey) { e.preventDefault(); const delta = e.deltaY > 0 ? -1 : 1; updateFontSize(currentSize + delta); } }, { passive: false });
                fileContent.addEventListener('keydown', (e) => {
                    if ((e.ctrlKey || e.metaKey) && (e.key === '+' || e.key === '=')) { e.preventDefault(); updateFontSize(currentSize + 1); }
                    else if ((e.ctrlKey || e.metaKey) && e.key === '-') { e.preventDefault(); updateFontSize(currentSize - 1); }
                    else if ((e.ctrlKey || e.metaKey) && e.key === '0') { e.preventDefault(); updateFontSize(config.defaultFontSize); }
                });
                const editModalObserver = new MutationObserver(() => { if (!editModal.classList.contains('hidden')) { currentSize = getSavedFontSize(); fileContent.style.fontSize = currentSize + 'px'; fileContent.style.lineHeight = (currentSize * 1.5) + 'px'; } });
                editModalObserver.observe(editModal, { attributes: true, attributeFilter: ['class'] });
            }
        });
        observer.observe(document.body, { childList: true, subtree: true });
    }
    if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', initGestureControls); } else { initGestureControls(); }
})();

(function() {
    'use strict';
    const config = { buttonId: 'toggleMaximizeModal', modalId: 'editModal', closeButtonId: 'closeEditModal', maximizedClass: 'maximized', expandIcon: 'fa-expand', compressIcon: 'fa-compress', buttonTitle: { maximize: '最大化', restore: '恢复' } };
    let maximizeButton = null, editModal = null, isToggling = false, modalObserver = null;
    
    function toggleMaximize() {
    if (!editModal || !maximizeButton || isToggling) return;
    isToggling = true;
    const icon = maximizeButton.querySelector('i');
    
    const isCurrentlyMaximized = editModal.classList.contains(config.maximizedClass);

    if (isCurrentlyMaximized) {
        editModal.classList.remove(config.maximizedClass);
        icon.classList.remove(config.compressIcon);
        icon.classList.add(config.expandIcon);
        maximizeButton.title = config.buttonTitle.maximize;
        try { if (typeof window.adjustEditorDimensions === 'function') setTimeout(window.adjustEditorDimensions, 100); } catch (e) { console.error('调整编辑器尺寸时出错：', e); }
    } else {
        editModal.classList.add(config.maximizedClass);
        icon.classList.remove(config.expandIcon);
        icon.classList.add(config.compressIcon);
        maximizeButton.title = config.buttonTitle.restore;
    }

    const newState = !isCurrentlyMaximized;
    try { localStorage.setItem('editor-maximized', newState.toString()); } catch (e) { console.error('保存最大化状态失败：', e); }

    setTimeout(() => { isToggling = false; }, 300);
}

    function resetMaximizedState() {
    if (isToggling || !editModal) return;

    if (editModal.classList.contains(config.maximizedClass)) {
        const icon = maximizeButton.querySelector('i');
        editModal.classList.remove(config.maximizedClass);
        if (icon) {
            icon.classList.remove(config.compressIcon);
            icon.classList.add(config.expandIcon);
        }
        maximizeButton.title = config.buttonTitle.maximize;
    }
}

function showEditorScaleHintOnce() {
    const hintKey = 'editor_scale_hint_shown';
    try {
        if (localStorage.getItem(hintKey)) {
            return;
        }
        const hintElement = el.editorScaleHint;
        if (!hintElement) {
            return;
        }
        
        hintElement.classList.remove('hidden');
        
        setTimeout(() => {
            hintElement.style.transition = 'opacity 0.5s ease-out';
            hintElement.style.opacity = '0';
            setTimeout(() => {
                hintElement.classList.add('hidden');
                hintElement.style.opacity = '';
                hintElement.style.transition = '';
            }, 500);
        }, 3000);

        localStorage.setItem(hintKey, 'true');
    } catch (e) {
        console.error("Could not show editor scale hint:", e);
    }
}
    
function initializeButton() {
    if (maximizeButton) return; 

    editModal = document.getElementById(config.modalId);
    maximizeButton = document.getElementById(config.buttonId);

    if (!editModal || !maximizeButton) return;

    maximizeButton.addEventListener('click', toggleMaximize);
}

    function init() {
    
        const observer = new MutationObserver(() => { if (!maximizeButton || !document.getElementById(config.buttonId) || !document.getElementById(config.modalId)) initializeButton(); });
        observer.observe(document.body, { childList: true, subtree: true });
        initializeButton();
        document.addEventListener('keydown', (e) => { if (editModal && !editModal.classList.contains('hidden')) { if (e.key === 'F11' || (e.ctrlKey && e.shiftKey && e.key === 'M')) { e.preventDefault(); toggleMaximize(); } } });
    }
    init();
})();


function initImageObserver() {
    imageObserver = new IntersectionObserver((entries, observer) => {
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                const container = entry.target;
                loadThumbnailImage(container);
                observer.unobserve(container);
            }
        });
    }, { rootMargin: '0px 0px 200px 0px' });
}


async function init() {
if (!state.loadedImageMap) state.loadedImageMap = new Map();
await autoClearCacheIfNeeded();
    try {
        const lastVersion = localStorage.getItem('last_app_version');
        if (lastVersion !== CURRENT_VERSION) {
            const keysToKeep = [
                'github_accounts', 'active_github_account_id', 'app_theme', 
                'context_menu_visibility', 'last_app_version'
            ];
            for (let i = localStorage.length - 1; i >= 0; i--) {
                const key = localStorage.key(i);
                if (!keysToKeep.includes(key)) localStorage.removeItem(key);
            }
            state.fileCache.clear();
            localStorage.setItem('last_app_version', CURRENT_VERSION);
        }
    } catch (e) {
        console.error('处理版本更新检查时出错:', e);
    }

    themeManager.init();
    loadLocalAvatar();
    loadSearchHistory();
    loadContextMenuSettings();
    initImageObserver();
    setupEventListeners();
    updateSortDropdownUI();

    initializeActiveToken();

    if (state.token) {
        showApp();
        try {
            // 核心修改1：先等待用户信息加载完成，确保头像URL可用
            await fetchUserInfo();

            // 核心修改2：不再强制刷新(移除true)，从而启用缓存
            await Promise.all([
                fetchRepos(),
                fetchStarredRepos(false, false)
            ]);
            
            state.myRepos = [...state.repos];
            prefetchCustomDomains();

            if (state.proxies.length === 0) {
                findAndSetBestProxy();
            } else if (state.autoSelectProxy) {
                setTimeout(() => findAndSetBestProxy(), 1000);
            } else {
                state.activeProxyIndex = parseInt(localStorage.getItem('active_proxy_index') || '0');
                state.proxyGlobalEnable = JSON.parse(localStorage.getItem('proxy_global_enable') || 'true');
                saveProxyConfig();
            }
        } catch (e) {
            console.error("Auto-login failed:", e);
            showToast('自动登录失败，请重新选择账号');
            setActiveAccount(null);
            showAuth();
        }
    } else {
        showAuth();
    }
    
    el.closePublishManagerBtn.onclick = hidePublishManagerModal;
    el.officialConfigTabBtn.onclick = () => {
        state.publishManagerActiveTab = 'official';
        renderPublishManagerLists();
    };
    el.customDomainTabBtn.onclick = () => {
        state.publishManagerActiveTab = 'custom';
        renderPublishManagerLists();
    };
}


document.addEventListener('DOMContentLoaded', async function() {
    document.documentElement.style.userSelect = 'none';
    history.replaceState({ repo: null, path: '' }, '', window.location.pathname);
    await init();
    initMediaPreview();
    initPullToRefresh();
   window.addEventListener('popstate', async (event) => {
    if (handleBackPress()) {
        return;
    }

    state.shouldAnimateList = true;
    const historyState = event.state || { view: 'own_repos' };

    switch (historyState.view) {
        case 'file_list':
    let repoData = state.repos.find(r => r.full_name === historyState.repo) 
                || state.starredRepos.find(r => r.full_name === historyState.repo)
                || (state.currentRepoList && state.currentRepoList.find(r => r.full_name === historyState.repo));

    if (repoData) {
        navigateToRepo(repoData, historyState.branch || repoData.default_branch, historyState.path || '', false);
    } else if (historyState.repo) {
        try {
            showToast('正在恢复导航状态...', 'info', 1000);
            const res = await fetch(`https://api.github.com/repos/${historyState.repo}`, { headers: { Authorization: `token ${state.token}` } });
            if (res.ok) {
                const freshRepoData = await res.json();
                navigateToRepo(freshRepoData, historyState.branch || freshRepoData.default_branch, historyState.path || '', false);
            } else {
                showToast('无法获取仓库信息，返回主列表', 'error');
                state.currentView = 'own_repos';
                showRepoListView();
            }
        } catch (e) {
            showToast('网络错误，返回主列表', 'error');
            state.currentView = 'own_repos';
            showRepoListView();
        }
    } else {
        state.currentView = 'own_repos';
        showRepoListView();
    }
    break;
        
        case 'releases_list':
            await fetchAndDisplayReleases(historyState.repo, false);
            break;
            
        case 'assets_list':
            if (state.releases && state.releases.length > 0) {
                const release = state.releases.find(r => r.id === historyState.releaseId);
                if (release) {
                    fetchAndDisplayAssets(release, false);
                } else {
                    await fetchAndDisplayReleases(historyState.repo, false);
                }
            } else {
                await fetchAndDisplayReleases(historyState.repo, false);
            }
            break;

        case 'starred_repos':
            state.currentView = 'starred_repos';
            showRepoListView();
            if (state.starredRepos.length === 0) {
                await fetchStarredRepos(true);
            } else {
                renderRepoList(state.starredRepos);
            }
            setTimeout(() => { el.main.scrollTop = state.repoListScrollPosition; }, 0);
            break;

        case 'other_user_repos':
            await _renderAndFetchUserRepos(historyState.owner);
            break;

        case 'search_results':
            await searchGlobalFiles(historyState.query, false);
            break;

        case 'public_search_results':
            await searchPublicRepositories(historyState.query, historyState.page || 1, false);
            setTimeout(() => { el.main.scrollTop = state.repoListScrollPosition; }, 0);
            break;

        case 'own_repos':
        default:
            state.currentView = 'own_repos';
            showRepoListView();
            state.repos = [...state.myRepos];
            renderRepoList(state.repos);
            setTimeout(() => { el.main.scrollTop = state.repoListScrollPosition; }, 0);
            break;
    }
    
    updatePaginationUI();
});


});




function injectModalStyles() {
    if (document.getElementById('dynamic-modal-styles')) {
        return;
    }

    const css = `
        .announcement-dialog,
        .update-dialog-container {
            position: relative; 
            max-width: 340px; 
            width: 90%;
            border-radius: 0.8rem; 
            background: linear-gradient(145deg, #1a1a2e, #16213e); 
            box-shadow: 0 10px 30px rgba(0,0,0,0.5); 
            border: 1px solid rgba(255,255,255,0.05); 
            color: #e0e7ff; 
            padding: 1.2rem; 
            transform: scale(0.9); 
            opacity: 0; 
            animation: zoomIn 0.4s 0.1s forwards;
        }
        .announcement-header { 
            font-size: 1rem; 
            font-weight: 600; 
            margin-bottom: 0.8rem; 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
        }
        .announcement-content { 
            font-size: 0.8rem; 
            color: #d1d5db; 
            line-height: 1.6; 
            max-height: 200px; 
            overflow-y: auto; 
            padding: 0.5rem; 
            background: rgba(0,0,0,0.2); 
            border-radius: 0.3rem; 
        }
        #closeAnnouncementBtn { 
            background: none; 
            border: none; 
            color: #e0e7ff; 
            font-size: 1.2rem; 
            cursor: pointer; 
            opacity: 0.7; 
        }
        .update-dialog-content { 
            position: relative; 
            z-index: 1; 
        }
        .update-dialog-header { 
            display: flex; 
            justify-content: space-between; 
            align-items: flex-start; 
            line-height: 1.6rem; 
            padding-bottom: 0.3rem; 
        }
        #closeUpdateModalBtn { 
            position: absolute; 
            top: 0; 
            right: 0; 
        }
        .update-log { 
            border-bottom: 1px solid rgba(255,255,255,0.1); 
            font-size: 0.8rem; 
            color: #d1d5db; 
            line-height: 1.6rem; 
            max-height: 300px; 
            overflow-y: auto; 
            padding: 0.68rem; 
            margin-bottom: 1.4rem; 
            background: rgba(0,0,0,0.2); 
            border-radius: 0.3rem; 
        }
        .update-buttons { 
    display: flex; 
    gap: 1rem; 
    margin-top: 1.2rem;
}
        .update-btn { 
            flex: 1; 
            padding: 0.6rem; 
            border: none; 
            border-radius: 0.4rem; 
            font-size: 0.8rem; 
            font-weight: 600; 
            cursor: pointer; 
            transition: transform 0.2s, box-shadow 0.2s; 
            opacity: 0.8; 
        }
        .update-btn:hover { 
            transform: translateY(-2px); 
            box-shadow: 0 4px 15px rgba(0,0,0,0.4); 
        }
        .btn-download { 
            background: linear-gradient(90deg, #a855f7, #6366f1, #3b82f6); 
            color: white; 
        }
        @keyframes zoomIn { 
            to { transform: scale(1); opacity: 1; } 
        }

        /* --- 新增的浅色主题样式 --- */
        .light-theme .announcement-dialog,
        .light-theme .update-dialog-container {
            background: linear-gradient(145deg, #ffffff, #eef2f7);
            box-shadow: 0 0px 0px rgba(0, 0, 0, 0);
            border: 0px solid #e5e7eb;
            color: #1f2937;
        }

        .light-theme .announcement-content,
        .light-theme .update-log {
            background: 0;
            color: #4b5563;
            border-bottom: 1px solid #e5e7eb;
        }

        .light-theme #closeAnnouncementBtn,
        .light-theme #closeUpdateModalBtn {
            color: #4b5563;
        }
        body.light-theme #closeUpdateModalBtn {
    color: #4b5563 !important;
}

body.light-theme .update-log {
    background-color: #e5e7eb;
}
        /* --- 浅色主题样式结束 --- */
    `;
    
    const styleSheet = document.createElement('style');
    styleSheet.id = 'dynamic-modal-styles';
    styleSheet.innerHTML = css;
    document.head.appendChild(styleSheet);
}

async function checkServerInfo() {
    injectModalStyles();
    const CONFIG_URL = 'https://raw.githubusercontent.com/rjdsq/rjdsq.github.io/main/github/更新/更新2.0.json';

    const PROXY_PREFIXES = [
        'https://gh.ptoe.cc/',
        'https://ghproxy.net/',
        'https://ghfast.top/',
        'https://tvv.tw/'
    ];

    const timestamp = `?t=${new Date().getTime()}`;

    const urlsToTry = [
        ...PROXY_PREFIXES.map(prefix => prefix + CONFIG_URL + timestamp),
        CONFIG_URL + timestamp
    ];

    let serverInfo = null;
    let success = false;

    for (const url of urlsToTry) {
        try {
            const response = await fetch(url, { cache: 'no-store' });
            if (response.ok) {
                serverInfo = await response.json();
                success = true;
                break;
            }
        } catch (error) {
            console.warn(`Attempt to fetch config from ${url} failed. Trying next...`);
        }
    }
    
    if (success && serverInfo) {
        try {
            handleUpdate(serverInfo);
            handleAnnouncement(serverInfo);
        } catch (processingError) {
             console.error('Error processing server info:', processingError);
        }
    } else {
        console.error('Check for server info failed: All URLs were unreachable.');
    }
}

function handleAnnouncement(info) {
    if (info && info.公告开关 === '开' && info.公告) {
        showAnnouncementDialog(info);
    }
}

function handleUpdate(info) {
    if (info && isNewerVersion(info.版本, CURRENT_VERSION)) {
        showUpdateDialog(info);
    }
}

function isNewerVersion(remoteVersion, localVersion) {
    const remoteParts = remoteVersion.split('.').map(Number);
    const localParts = localVersion.split('.').map(Number);
    const len = Math.max(remoteParts.length, localParts.length);
    for (let i = 0; i < len; i++) {
        const remote = remoteParts[i] || 0;
        const local = localParts[i] || 0;
        if (remote > local) return true;
        if (remote < local) return false;
    }
    return false;
}

function showAnnouncementDialog(info) {
    if (document.getElementById('announcementModal')) return;

    const announcementText = info.公告 || '';
    let buttonsHTML = '';
    const hasLinkButton = info.公告链接 && info.公告链接.trim() !== '';
    const hasCopyButton = info.公告复制内容 && info.公告复制内容.trim() !== '';



    if (hasCopyButton) {
        const copyButtonText = info.公告复制按钮文本 || '复制内容';
        buttonsHTML += `<button id="announcementCopyBtn" class="update-btn btn-download">${escapeHtml(copyButtonText)}</button>`;
    }
    
    if (hasLinkButton) {
        const linkButtonText = info.公告链接按钮文本 || '前往链接';
        buttonsHTML += `<button id="announcementLinkBtn" class="update-btn btn-download">${escapeHtml(linkButtonText)}</button>`;
    }

    
    const modal = document.createElement('div');
    modal.id = 'announcementModal';
    modal.className = 'modal-overlay';
    modal.style.cssText = `z-index: 201; opacity: 0; transition: opacity 0.3s ease;`;
    
    modal.innerHTML = `
        <div class="announcement-dialog">
            <div class="announcement-header">
                <span>公告：</span>
                <button id="closeAnnouncementBtn" title="关闭"><i class="fa fa-times"></i></button>
            </div>
            <div class="announcement-content">${announcementText.replace(/\n/g, '<br>')}</div>
            ${buttonsHTML ? `<div class="update-buttons">${buttonsHTML}</div>` : ''}
        </div>
    `;

    document.body.appendChild(modal);
    setTimeout(() => { modal.style.opacity = '1'; }, 10);

    const closeModal = () => {
        modal.style.opacity = '0';
        modal.querySelector('.announcement-dialog').style.animation = 'zoomIn 0.3s reverse forwards';
        setTimeout(() => modal.remove(), 300);
    };

    document.getElementById('closeAnnouncementBtn').onclick = closeModal;
    modal.onclick = (e) => { if (e.target === modal) closeModal(); };

    if (hasLinkButton) {
        document.getElementById('announcementLinkBtn').onclick = () => {
            window.open(info.公告链接, '_blank');
        };
    }

      if (hasCopyButton) {
        const copyButtonText = info.公告复制按钮文本 || '复制内容';
        document.getElementById('announcementCopyBtn').onclick = () => {
            navigator.clipboard.writeText(info.公告复制内容).then(() => {
                showToast(`已${escapeHtml(copyButtonText)}`);
            }).catch(() => {
                showToast('复制失败');
            });
        };
    }
}

function showUpdateDialog(updateInfo) {
    if (document.getElementById('updateModal')) return;
    
    const modal = document.createElement('div');
    modal.id = 'updateModal';
    modal.className = 'modal-overlay';
    modal.style.cssText = `z-index: 200; opacity: 0; transition: opacity 0.3s ease;`;
    
    const isForced = updateInfo.强制更新 === '开';
    const updateLogHTML = (updateInfo.更新日志 || '').replace(/\n/g, '<br>');
    
    modal.innerHTML = `
        <div class="update-dialog-container">
            <div class="update-dialog-content">
                <div class="update-dialog-header">
                    <div style="flex-grow: 1;">
                        <span style="font-size:1rem; font-weight: 600;">版本更新： v${escapeHtml(updateInfo.版本)}</span>
                        <div style="font-size: 0.8rem; color: #ff0036; font-weight: 400; margin-top: 0.2rem; text-align: right;">当前： v${CURRENT_VERSION}</div>
                    </div>
                    ${!isForced ? `<button id="closeUpdateModalBtn" class="btn-icon-sm" style="color:white;" title="关闭"><i class="fa fa-times"></i></button>` : ''}
                </div>
                <div class="update-log">${updateLogHTML}</div>
                <div class="update-buttons">
                    <button id="copyUpdateLinkBtn" class="update-btn btn-download">复制下载链接</button>
                    <button id="downloadUpdateBtn" class="update-btn btn-download">下载更新</button>
                </div>
            </div>
        </div>
    `;

    document.body.appendChild(modal);
    setTimeout(() => { modal.style.opacity = '1'; }, 10);

    if (!isForced) {
        const closeModal = () => {
            modal.style.opacity = '0';
            modal.querySelector('.update-dialog-container').style.animation = 'zoomIn 0.3s reverse forwards';
            setTimeout(() => modal.remove(), 300);
        };
        document.getElementById('closeUpdateModalBtn').onclick = closeModal;
        modal.onclick = (e) => { if (e.target === modal) closeModal(); };
    }

    document.getElementById('copyUpdateLinkBtn').onclick = () => {
        navigator.clipboard.writeText(updateInfo.下载地址).then(() => {
            showToast('下载地址已复制!');
        }).catch(() => {
            showToast('复制失败,权限不足');
        });
    };
    
    document.getElementById('downloadUpdateBtn').onclick = () => {
        window.open(updateInfo.下载地址, '_blank');
    };
}

const originalInit = window.init;
window.init = async function() {
    if(originalInit) {
        await originalInit.apply(this, arguments);
    }
    checkServerInfo();
};




async function unzipFile(file) {
    const confirmUnzip = async () => {
        const [owner, repo] = state.currentRepo.split('/');
        
        try {
            showToast('正在下载压缩包...');
            const response = await fetch(getProxiedUrl(file.download_url));
            if (!response.ok) {
                throw new Error(`下载压缩包失败: ${response.statusText}`);
            }
            const blob = await response.blob();

            showToast('正在读取压缩包内容...');
            const zip = await JSZip.loadAsync(blob);
            const filesInZip = Object.values(zip.files).filter(item => !item.dir);
            const totalFiles = filesInZip.length;
            let uploadedCount = 0;

            if (totalFiles === 0) {
                showToast('压缩包为空或无法读取');
                return;
            }
            
            showToast(`开始上传 ${totalFiles} 个文件...`);

            for (const zipEntry of filesInZip) {
                const contentBase64 = await zipEntry.async('base64');
                const entryPath = zipEntry.name;
                const fullPath = state.currentPath ? `${state.currentPath}${entryPath}` : entryPath;
                
                const uploadUrl = `https://api.github.com/repos/${owner}/${repo}/contents/${fullPath}`;
                
                let existingFileSha = null;
                try {
                    const checkRes = await fetch(uploadUrl + `?ref=${state.currentBranch}`, {
                         headers: { 'Authorization': `token ${state.token}` }
                    });
                    if (checkRes.ok) {
                        existingFileSha = (await checkRes.json()).sha;
                    }
                } catch (e) {
                }

                const body = {
                    message: `Unzip ${file.name}: add ${entryPath}`,
                    content: contentBase64,
                    branch: state.currentBranch,
                };

                if (existingFileSha) {
                    body.sha = existingFileSha;
                    body.message = `Unzip ${file.name}: update ${entryPath}`;
                }

                const uploadResponse = await fetch(uploadUrl, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `token ${state.token}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(body)
                });

                if (!uploadResponse.ok) {
                    console.error(`上传失败: ${fullPath}`, await uploadResponse.json());
                    showToast(`文件 ${entryPath} 上传失败，已跳过。`);
                } else {
                    uploadedCount++;
                    showToast(`正在上传... (${uploadedCount}/${totalFiles})`);
                }
            }

            showToast(`解压完成！成功上传 ${uploadedCount} 个文件。`);
            state.shouldAnimateList = true;
            fetchFiles(true);

        } catch (error) {
            console.error('解压过程中发生错误:', error);
            showToast(`解压失败: ${error.message}`);
        }
    };

    showDeleteModal(
        null,
        false,
        '确认解压',
        `确定要将 "${escapeHtml(file.name)}" 解压到当前目录吗？同名文件将被覆盖。`,
        confirmUnzip,
        '确认解压',
        'btn-primary'
    );
}





</script>























































<script>
const CloudEffectManager = {
    settings: {
        repoOwner: 'rjdsq',
        repoName: 'github-king',
        path: 'js'
    },
    activeEffects: new Map(),

    init() {
        this.injectStyles();
        this.bindEvents();
        this.restoreSettings();
    },

    injectStyles() {
        if (document.getElementById('cloud-effect-styles')) return;
        const style = document.createElement('style');
        style.id = 'cloud-effect-styles';
        style.innerHTML = `
            .effect-item {
                position: relative;
                display: flex;
                align-items: center;
                justify-content: space-between;
                padding-right: 10px;
                min-height: 44px;
            }
            .effect-controls {
                display: flex;
                align-items: center;
                gap: 10px;
            }
            .layer-toggle-btn {
                appearance: none;
                display: flex;
                align-items: center;
                justify-content: center;
                padding: 4px 12px;
                font-size: 0.75rem;
                font-weight: 500;
                border-radius: 20px;
                border: 1px solid #4b5563;
                background-color: transparent;
                color: #9ca3af;
                cursor: pointer;
                transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
                z-index: 2;
                white-space: nowrap;
                min-width: 48px;
            }
            .layer-toggle-btn:hover {
                border-color: #6b7280;
                background-color: rgba(255, 255, 255, 0.05);
                color: #e5e7eb;
            }
            .layer-toggle-btn:active {
                transform: scale(0.96);
            }
            .layer-toggle-btn.is-top {
                border-color: #059669;
                background-color: rgba(16, 185, 129, 0.1);
                color: #34d399;
            }
            body.light-theme .layer-toggle-btn {
                border-color: #e5e7eb;
                background-color: #f9fafb;
                color: #6b7280;
            }
            body.light-theme .layer-toggle-btn:hover {
                border-color: #d1d5db;
                background-color: #f3f4f6;
                color: #374151;
            }
            body.light-theme .layer-toggle-btn.is-top {
                border-color: #34d399;
                background-color: #ecfdf5;
                color: #059669;
            }
        `;
        document.head.appendChild(style);
    },

    bindEvents() {
        const btn = document.getElementById('menuEffectsManager');
        const modal = document.getElementById('effectsManagerModal');
        const closeBtn = document.getElementById('closeEffectsManagerBtn');

        if (btn) {
            btn.onclick = () => {
                if (typeof closeSideNav === 'function') closeSideNav();
                modal?.classList.remove('hidden');
                this.loadList();
            };
        }
        if (closeBtn) {
            closeBtn.onclick = () => modal?.classList.add('hidden');
        }
    },

    restoreSettings() {
        try {
            const savedData = JSON.parse(localStorage.getItem('cloud_effects_data') || '[]');
            if (Array.isArray(savedData)) {
                savedData.forEach(item => {
                    const isTop = item.isTop !== undefined ? item.isTop : true;
                    this.toggleEffect(item.id, item.name, item.url, false, isTop);
                });
            }
        } catch (e) {
            console.error(e);
        }
    },

    async loadList() {
        const listEl = document.getElementById('effectsList');
        if (!listEl) return;

        listEl.innerHTML = '<div class="loading-spinner"><div class="spinner"></div></div>';

        try {
            const headers = {};
            if (typeof state !== 'undefined' && state.token) {
                headers['Authorization'] = `token ${state.token}`;
            }

            const apiUrl = `https://api.github.com/repos/${this.settings.repoOwner}/${this.settings.repoName}/contents/${this.settings.path}`;
            const res = await fetch(apiUrl, { headers });

            if (!res.ok) throw new Error(res.status);
            const data = await res.json();

            listEl.innerHTML = '';

            const jsFiles = data.filter(f => f.name.endsWith('.js'));
            if (jsFiles.length === 0) {
                listEl.innerHTML = '<div class="empty-state"><p>暂无云端特效</p></div>';
                return;
            }

            jsFiles.forEach(file => {
                const name = file.name.replace('.js', '');
                const rawUrl = file.download_url || `https://raw.githubusercontent.com/${this.settings.repoOwner}/${this.settings.repoName}/master/${this.settings.path}/${file.name}`;
                this.renderItem(listEl, file.sha, name, rawUrl);
            });

        } catch (e) {
            listEl.innerHTML = `<div class="empty-state"><p>${e.message}</p></div>`;
        }
    },

    renderItem(container, id, name, url) {
        const effectData = this.activeEffects.get(url);
        const isActive = !!effectData;
        const isTop = effectData ? effectData.isTop : true;

        const item = document.createElement('div');
        item.className = `effect-item ${isActive ? 'active' : ''}`;
        
        item.innerHTML = `
            <span class="effect-name">${name}</span>
            <div class="effect-controls">
                <button class="layer-toggle-btn ${isTop ? 'is-top' : ''}" type="button">
                    ${isTop ? '层级：顶层' : '层级：背景'}
                </button>
                <div class="effect-toggle"></div>
            </div>
        `;

        const layerBtn = item.querySelector('.layer-toggle-btn');
        layerBtn.onclick = (e) => {
            e.stopPropagation(); 
            e.preventDefault();
            
            if (this.activeEffects.has(url)) {
                this.toggleLayer(url, layerBtn);
            } else {
                const currentIsTop = layerBtn.classList.contains('is-top');
                const newIsTop = !currentIsTop;
                
                layerBtn.classList.toggle('is-top', newIsTop);
                layerBtn.textContent = newIsTop ? '层级：顶层' : '层级：背景';
                layerBtn.dataset.presetTop = newIsTop;
            }
        };

        item.onclick = () => {
            let preferredIsTop = true;
            if (layerBtn.dataset.presetTop !== undefined) {
                preferredIsTop = layerBtn.dataset.presetTop === 'true';
            } else if (this.activeEffects.has(url)) {
                preferredIsTop = this.activeEffects.get(url).isTop;
            } else {
                preferredIsTop = layerBtn.classList.contains('is-top');
            }

            const isNowActive = this.toggleEffect(id, name, url, true, preferredIsTop);
            item.classList.toggle('active', isNowActive);
        };
        
        container.appendChild(item);
    },

    toggleLayer(url, btnElement) {
        const effect = this.activeEffects.get(url);
        if (!effect) return;

        effect.isTop = !effect.isTop;
        
        const frameId = `effect-frame-${this.hashString(url)}`;
        const iframe = document.getElementById(frameId);
        if (iframe) {
            iframe.style.zIndex = effect.isTop ? 2147483647 : -1;
        }

        if (btnElement) {
            btnElement.classList.toggle('is-top', effect.isTop);
            btnElement.textContent = effect.isTop ? '层级：顶层' : '层级：背景';
        }

        this.saveSettings();
    },

    toggleEffect(id, name, url, shouldSave = true, isTop = true) {
        if (this.activeEffects.has(url)) {
            this.activeEffects.delete(url);
            this.stopEffect(url);
            if (shouldSave) {
                this.saveSettings();
            }
            return false;
        } else {
            this.activeEffects.set(url, { id, name, url, isTop });
            this.startEffect(url, isTop);
            if (shouldSave) {
                this.saveSettings();
            }
            return true;
        }
    },

    saveSettings() {
        const dataToSave = Array.from(this.activeEffects.values());
        localStorage.setItem('cloud_effects_data', JSON.stringify(dataToSave));
    },

    startEffect(url, isTop) {
        this.createIframeEffect(url, isTop);
    },

    stopEffect(url) {
        const frameId = `effect-frame-${this.hashString(url)}`;
        const frame = document.getElementById(frameId);
        if (frame) {
            frame.remove();
        }
    },

    async createIframeEffect(url, isTop = true) {
        const frameId = `effect-frame-${this.hashString(url)}`;
        if (document.getElementById(frameId)) return;

        const iframe = document.createElement('iframe');
        iframe.id = frameId;
        
        const zIndex = isTop ? 2147483647 : -1;

        iframe.style.cssText = `
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 300vw; 
            height: 280vh; 
            border: none; 
            z-index: ${zIndex}; 
            pointer-events: none; 
            background: transparent; 
            transform: scale(0.5); 
            transform-origin: 0 0;
        `;
        document.body.appendChild(iframe);

        try {
            const finalUrl = typeof getProxiedUrl === 'function' ? getProxiedUrl(url) : url;

            const res = await fetch(finalUrl);
            if (!res.ok) throw new Error('Script download failed');
            const jsCode = await res.text();

            const doc = iframe.contentWindow.document;
            doc.open();
            
            doc.write(`
                <!DOCTYPE html>
                <html>
                <head>
                    <style>
                        * { margin: 0; padding: 0; box-sizing: border-box; }
                        body, html { 
                            width: 100%; 
                            height: 100%; 
                            overflow: hidden; 
                            background: transparent;
                        }
                        canvas { display: block; }
                    </style>
                </head>
                <body>
                    <script>
                        window.onerror = function() { return true; };
                        setTimeout(() => {
                            try {
                                ${jsCode}
                            } catch(e) {
                                console.error("Cloud Effect Error:", e);
                            }
                        }, 50);
                    <\/script>
                </body>
                </html>
            `);
            doc.close();

        } catch (e) {
            console.error(e);
            iframe.remove();
            this.activeEffects.delete(url);
            this.saveSettings();
            this.toast('特效加载失败', 'error');
        }
    },

    hashString(str) {
        let hash = 0;
        if (!str || str.length === 0) return hash;
        for (let i = 0; i < str.length; i++) {
            const char = str.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash;
        }
        return Math.abs(hash);
    },

    toast(msg, type = 'info') {
        if (typeof showToast === 'function') {
            showToast(msg, type);
        } else {
            console.log(msg);
        }
    }
};

document.addEventListener('DOMContentLoaded', () => {
    CloudEffectManager.init();
});
</script>



<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
</body>
</html>
