<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#f0f2f5">
    <title>GitHub king - 仓库管理器</title>
    <link rel="dns-prefetch" href="https://cdn.bootcdn.net">
    <link rel="stylesheet" href="./style.css">
    <link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/font-awesome/6.4.2/css/all.min.css">
    <script src="./tx.js" defer></script>
    <script>
        (function() {
            try {
                const savedTheme = localStorage.getItem('app_theme') || 'light';
                const themeColorMeta = document.querySelector('meta[name="theme-color"]');
                
                if (savedTheme === 'light') {
                    document.documentElement.classList.add('light-theme-loading');
                    if (themeColorMeta) themeColorMeta.setAttribute('content', '#f0f2f5');
                } else {
                    if (themeColorMeta) themeColorMeta.setAttribute('content', '#04091a');
                }
            } catch (e) {}
        })();
        
        document.addEventListener('DOMContentLoaded', function() {
            if (document.documentElement.classList.contains('light-theme-loading')) {
                document.body.classList.add('light-theme');
                requestAnimationFrame(() => {
                    document.documentElement.classList.remove('light-theme-loading');
                });
            }
        });
    </script>
</head>
	<style>



	</style>
	<body>


	<canvas id="particle-canvas"></canvas>
		<!-- 认证页面 -->
		
		<div id="authScreen">
    <div class="login-container">
        <div class="auth-header">
            <i class="fa-brands fa-github-alt"></i>
            <h1>Github King</h1>
            <p>极速 · 优雅 · 全能</p>
        </div>

        <div class="auth-form">
            <input type="text" id="tokenInput" placeholder="Access Token" autocomplete="off" spellcheck="false">
            
            <div class="auth-buttons-container">
                <button id="authBtn">
                    <span>进入系统</span>
                    <i class="fa fa-spinner fa-spin hidden"></i>
                </button>
                <button class="auth-button" id="manageAccountsBtn">
                    <span>账号管理</span>
                </button>
            </div>
        </div>

        <div class="auth-helper-links">
    <button id="showTokenGuideBtn" class="text-btn">
        <i class="fa-regular fa-circle-question"></i> 如何获取令牌 Access Token？
    </button>

</div>
<div  class="" style="font-size: 8px; text-align: center; color: #4b5563;">
        ©️ 2025 牡丹君 全能仓库管理器
    </div>
</div>

</div>


		
		
	<!-- 提示消息框 -->
<!-- 提示消息框 -->
<div id="toast">
    <span id="toastMessage"></span>
</div>
		<!-- 主应用容器 -->
		<div id="app" class="hidden">
			<!-- 头部栏 -->
			



<header>

				<div class="header-left">
				<!-- class github图标 -->
					
					
    
					<h1 id="currentRepo">
						选择仓库
					</h1>
					<div id="branchSwitcherContainer" class="hidden">
					</div>
					<div id="pathNav">
					</div>
					<div id="pathNavContainer">
					</div>
				</div>
				<div class="header-right">
    <div id="globalSearchContainer" class="hidden">
    <input id="globalSearchInput" placeholder="搜仓库/@用户/链接/#文件" autocomplete="off">
    <div id="globalSearchHistoryContainer" class="custom-dropdown hidden"></div>
</div>
    <button id="globalSearchToggleBtn" class="btn-icon" title="全局搜索">
        <i class="fa fa-search"></i>
    </button>
    <button id="viewStarredBtn" class="btn-icon" title="查看星标仓库">
        <i class="fa-regular fa-star"></i>
    </button>
    
    <button id="sideNavToggleBtn" title="菜单">
        <i class="fa-regular fa-user"></i>
    </button>
</div>
			</header>
			<!-- 主内容区 -->
			
			<!-- 全局加载动画 -->
				<div id="mainLoader" class="loading-overlay hidden">
					<div class="spinner">
					</div>
				</div>
			<main>
			<div id="pull-to-refresh">
					
					<div class="ptr-spinner spinner"></div>
				</div>
				
				
				<!-- 文件工具栏 -->
				<div id="toolbar" class="hidden">
					<div class="toolbar-left">
						<input id="searchInput" placeholder="搜索文件/文件夹..." class="hidden">
					</div>
					<button id="searchToggleBtn" class="btn-icon" title="搜索">
						<i class="fa fa-search">
						</i>
					</button>
					<button id="proxyQuickToggle" title="代理状态">
						<i class="fa fa-power-off">
						</i>
					</button>
					<div class="toolbar-right">
						<div class="custom-select-container">
							<button id="sortToggleBtn" class="btn-icon" title="排序">
							<i class="fa-solid fa-up-down"></i>
							</button>
							<!-- 排序下拉菜单 -->
							<div id="customSortDropdown" class="hidden custom-dropdown">      
    <div class="dropdown-item" data-priority="dirs_first">
        <i class="fa-solid fa-folder" style="width: 16px; color: #fbbf24;"></i>
        <span>文件夹置顶</span>
    </div>
    <div class="dropdown-item" data-priority="files_first">
        <i class="fa-solid fa-file" style="width: 16px; color: #60a5fa;"></i>
        <span>文件置顶</span>
    </div>
    <div class="dropdown-divider"></div>
    <div class="dropdown-item" data-value="type_name_asc">
        <i class="fa-solid fa-wand-magic-sparkles" style="width: 16px; color: #a78bfa;"></i>
        <span>智能排序 (推荐)</span>
    </div>
    <div class="dropdown-item" data-value="name_asc">
        <i class="fa-solid fa-arrow-down-a-z" style="width: 16px; color: #34d399;"></i>
        <span>名称 (A → Z)</span>
    </div>
    <div class="dropdown-item" data-value="name_desc">
        <i class="fa-solid fa-arrow-down-z-a" style="width: 16px; color: #34d399;"></i>
        <span>名称 (Z → A)</span>
    </div>
    
    <div class="dropdown-item" data-value="size_desc">
        <i class="fa-solid fa-arrow-down-wide-short" style="width: 16px; color: #fb923c;"></i>
        <span>大小 (大 → 小)</span>
    </div>
    <div class="dropdown-item" data-value="size_asc">
        <i class="fa-solid fa-arrow-down-short-wide" style="width: 16px; color: #fb923c;"></i>
        <span>大小 (小 → 大)</span>
    </div>
</div>
						</div>
						<button id="multiSelectToggleBtn" class="btn-icon" title="多项选择">
						<i class="fa-regular fa-circle-check"></i>
						</button>
						<button id="viewToggleBtn" title="切换视图">
							<i class="fa fa-th-large">
							</i>
						</button>
					</div>
				</div>
				<!-- 仓库列表 -->
				<div id="repoList">
					<div class="loading-spinner">
						<div class="spinner">
						</div>
					</div>
				</div>
				<!-- 文件列表 -->
				<div id="fileList" class="hidden">
					<div class="loading-spinner">
						<div class="spinner">
						</div>
					</div>
				</div>
			</main>
						<!-- 重命名弹窗 -->
			<div id="renameModal" class="modal-overlay hidden">
				<div class="modal-form-container">
					<h3 id="renameTitle">
						<span class="modal-title-text">
							重命名
						</span>
						<button class="btn-icon-sm" onclick="hideRenameModal()"
						title="关闭">
							<i class="fa fa-times">
							</i>
						</button>
					</h3>
					<input type="text" id="renameInput" value="" autocomplete="off">
					
					<!-- 【核心新增】在这里添加一个空的容器，作为“插槽” -->
					<div id="renameModalExtraSettings"></div>

					<div id="renameWarn" class="text-red-400" >
					</div>
					<div class="modal-buttons">
						<button id="renameCancel" class="btn btn-cancel">
							取消
						</button>
						<button id="renameConfirm" class="btn btn-primary" disabled>
							确认
						</button>
					</div>
				</div>
			</div>
			
			<!-- 文件编辑弹窗 -->
						<!-- 文件编辑弹窗 -->
			<div id="editModal" class="hidden">
				<div class="modal-content">
					<div class="modal-header">
    <h5 id="editFileName">
        编辑文件
    </h5>
    <button id="closeEditModal">
        <i class="fa fa-times">
        </i>
    </button>
</div>
					<div id="editStatus">
					</div>
					<div class="editor-container">
						<!-- 新增的搜索面板 -->
						<div id="editorSearchPanel" class="hidden">
							<input type="text" id="editorSearchInput" placeholder="搜索...">
							<span id="editorSearchMatchCount"></span>
							<button id="editorSearchPrevBtn" title="上一个"><i class="fa fa-chevron-up"></i></button>
							<button id="editorSearchNextBtn" title="下一个"><i class="fa fa-chevron-down"></i></button>
							<button id="editorSearchCloseBtn" title="关闭搜索"><i class="fa fa-times"></i></button>
						</div>

						<div id="editorOverlay">
							<div class="spinner-container">
								<i class="fa fa-spinner fa-spin">
								</i>
							</div>
						</div>
						<div id="saveNotification">
							<i class="fa fa-check">
							</i>
							保存成功
						</div>
						<textarea id="fileContent">
						</textarea>
					</div>
					<div class="modal-footer">
					<!-- [新增] 全选按钮 -->
    <button id="selectAllEditorBtn" title="全选内容">
        <i class="fa-solid fa-check-double"></i>
        <span>全选</span>
    </button>
    <button id="revertEditBtn" title="撤销修改" disabled>
        <i class="fa fa-undo"></i>
        <span>撤销</span>
    </button>
    <button id="toggleMaximizeModal" title="最大化">
        <i class="fa fa-expand"></i>
        <span>全屏</span>
    </button>
    <button id="cancelEdit">
        <i class="fa fa-times"></i>
        <span>取消</span>
    </button>
    
    
    
    <button id="searchInFileBtn">
        <i class="fa fa-search"></i>
        <span>搜索</span>
    </button>
    <button id="saveEdit">
        <i class="fa-solid fa-check"></i>
        <span>保存</span>
    </button>
</div>
				</div>
			</div>
			
			
			<!-- 右键/长按菜单 -->
			<div id="contextMenu" class="hidden">
				<div id="contextMenuItems">
				</div>
			</div>
			
			<!-- 隐藏的文件上传输入框 -->
			<input type="file" id="fileUploadInput" multiple class="hidden">
			
			
			
			
			<div id="mainOverlay"></div>
<aside id="sideNav">
    <div class="user-profile-header">
        <div id="avatarContainer" title="点击更换头像">
            <i id="userAvatarPlaceholder" class="fa fa-github"></i>
            <img id="userAvatar" src="" alt="User Avatar" class="fa fa-github hidden">
        </div>
        <span id="userName">name</span>
    </div>
    
    <ul class="side-nav-main">
        <li><a href="javascript:void(0);" id="menuProxySettings"><i class="fa-solid fa-gears"></i>代理设置</a></li>
        <li><a href="javascript:void(0);" id="menuContextMenuSettings"><i class="fa-regular fa-hand-pointer"></i>菜单设置</a></li>
        
        <li><a href="javascript:void(0);" id="menuBatchPublishSites"><i class="fa-solid fa-layer-group"></i>网站部署</a></li>
        <li><a href="javascript:void(0);" id="menuEffectsManager"><i class="fa-solid fa-wand-magic-sparkles" style=""></i>云端插件</a></li>
        
        
    </ul>

    <ul class="side-nav-bottom">
    
    
    
    <li><a href="javascript:void(0);" id="menuThemeToggle"><i class="fa-regular fa-cloud"></i>切换主题</a></li>
    
    
        <li><a href="javascript:void(0);" id="menuSwitchAccount"><i class="fa fa-exchange"></i>切换账号</a></li>
        
        <li><a href="javascript:void(0);" id="ybp"><i class="fa-regular fa-lightbulb"></i>数据监控</a></li>
        
        <li><a href="javascript:void(0);" id="menuUsageGuide"><i class="fa-regular fa-circle-question"></i>使用指南</a></li>
        <li><a href="javascript:void(0);" id="menuLogout"><i class="fa fa-sign-out"></i>退出登录</a></li>
    </ul>
</aside>

			<!-- 底部操作栏 -->
			<footer>
			<canvas id="nav-spectrum"></canvas>
			<video id="globalAudioPlayer" width="0" height="0" style="display: none;"></video>
			
			
			
			
    <button id="backBtn" title="返回上级" class="hidden">
        <i class="fa-solid fa-arrow-left"></i>
    </button>
    <button id="newFolderBtn" title="新建仓库">
        <i class="fa-regular fa-folder-open"></i>
    </button>
    <button id="newReleaseBtn" title="发布新版本" class="hidden">
        <i class="fa fa-plus-circle"></i>
    </button>
    <button id="newFileBtn" title="新建文件" class="hidden">
        <i class="fa-solid fa-arrow-right"></i>
    </button>
    <button id="uploadBtn" title="上传文件" class="hidden">
        <i class="fa-solid fa-arrows-up-down"></i>
    </button>
</footer>
			<!-- 媒体文件预览容器 -->
			<div id="mediaPreview" class="hidden">
				<img id="mediaPreviewImg" style="display:none;" alt="预览图片">
				<video id="mediaPreviewVideo" style="display:none;" controls>
				</video>
			</div>
			
			
			
			
			
			</div>
			
			
			
			
			
			
			<!-- 新建仓库弹窗 -->
			<div id="createRepoModal" class="modal-overlay hidden">
				<div class="modal-form-container">
					<h3>
						<span class="modal-title-text">
							新建仓库
						</span>
						<button class="btn-icon-sm" onclick="hideCreateRepoModal()"
						title="关闭">
							<i class="fa fa-times">
							</i>
						</button>
					</h3>
					<input id="createRepoNameInput" placeholder="输入仓库名称（仅支持英文、数字、连字符）">
					<div id="repoNameError" class="text-red-400" style="font-size: 0.75rem; margin-top: -0.4rem; margin-bottom: 0.4rem; display: none;">
					</div>
					<textarea id="createRepoDescInput" placeholder="仓库描述（可选）">
					</textarea>
					<div class="checkbox-container">
						<input type="checkbox" id="createRepoPrivate">
						<label for="createRepoPrivate">
							公开仓库
						</label>
					</div>
					<div class="modal-buttons">
						<button id="createRepoCancel" class="btn btn-cancel">
							取消
						</button>
						<button id="createRepoConfirm" class="btn btn-primary" disabled>
							创建仓库
						</button>
					</div>
				</div>
			</div>
			<!-- 新建文件夹弹窗 -->
			<div id="createFolderModal" class="modal-overlay hidden">
				<div class="modal-form-container">
					<h3>
						<span class="modal-title-text">
							新建文件夹
						</span>
						<button class="btn-icon-sm" onclick="hideCreateFolderModal()"
						title="关闭">
							<i class="fa fa-times">
							</i>
						</button>
					</h3>
					<input id="createFolderInput" placeholder="输入文件夹名称">
					<div class="modal-buttons">
						<button id="createFolderCancel" class="btn btn-cancel">
							取消
						</button>
						<button id="createFolderConfirm" class="btn btn-primary" disabled>
							确认
						</button>
					</div>
				</div>
			</div>
			<!-- 新建文件弹窗 -->
			<div id="createFileModal" class="modal-overlay hidden">
				<div class="modal-form-container">
					<h3>
						<span class="modal-title-text">
							新建文件
						</span>
						<button class="btn-icon-sm" onclick="hideCreateFileModal()"
						title="关闭">
							<i class="fa fa-times">
							</i>
						</button>
					</h3>
					<input id="createFileNameInput" placeholder="输入文件名，如 example.txt">
					<textarea id="createFileContentInput" placeholder="文件内容（可选）">
					</textarea>
					<div class="modal-buttons">
						<button id="createFileCancel" class="btn btn-cancel">
							取消
						</button>
						<button id="createFileConfirm" class="btn btn-primary" disabled>
							确认
						</button>
					</div>
				</div>
			</div>
			
			
			<!-- 新建分支弹窗 -->
			<div id="createBranchModal" class="modal-overlay hidden">
				<div class="modal-form-container">
					<h3>
						<span class="modal-title-text">
							分支管理
						</span>
						<button class="btn-icon-sm" onclick="hideCreateBranchModal()"
						title="关闭">
							<i class="fa fa-times">
							</i>
						</button>
					</h3>
					<div class="form-group">
						<label for="createBranchNameInput">
							新分支名称:
						</label>
						<input id="createBranchNameInput" placeholder="输入新分支名称">
					</div>
					<div class="form-group">
						<label>
							基于分支:
						</label>
						<div class="branch-select-container">
							<div id="sourceBranchSelector" class="custom-branch-select-wrapper">
								<button class="custom-branch-select-trigger">
									<span>
									</span>
									<i class="fa fa-chevron-down">
									</i>
									
								</button>
								<div class="custom-branch-select-options">
								</div>
							</div>
							<button id="renameBranchBtn" class="btn-icon" title="重命名所选分支">
								<i class="fa fa-pencil">
								</i>
							</button>
							<button id="deleteBranchBtn" class="btn-icon danger" title="删除所选分支">
								<i class="fa-regular fa-trash-can">
								</i>
							</button>
						</div>
					</div>
					<div class="modal-buttons">
						<button id="createBranchCancel" class="btn btn-cancel">
							取消
						</button>
						<button id="createBranchConfirm" class="btn btn-primary" disabled>
							创建分支
						</button>
					</div>
				</div>
			</div>
	
	
<div id="setAsSiteModal" class="modal-overlay hidden">
    <div class="modal-form-container">
        <h3>
            <span class="modal-title-text">发布主网站</span>
            <button class="btn-icon-sm" id="setAsSiteCloseBtn" title="关闭"><i class="fa fa-times"></i></button>
        </h3>
        <p>选择一个分支作为您网站的发布源。</p>
        <div class="form-group">
            <label for="setAsSiteBranchSelector">选择分支:</label>
            <div id="setAsSiteBranchSelector" class="custom-branch-select-wrapper">
                <button class="custom-branch-select-trigger">
                    <span></span>
                    <i class="fa fa-chevron-down"></i>
                </button>
                <div class="custom-branch-select-options">
                    <!-- Branches will be populated here -->
                </div>
            </div>
        </div>
        <div class="modal-buttons">
            <button id="setAsSiteCancelBtn" class="btn btn-cancel">取消</button>
            <button id="setAsSiteConfirmBtn" class="btn btn-primary">确认发布</button>
        </div>
    </div>
</div>
		<!-- 文件上传面板 -->
		<div id="uploadPanel" class="hidden">
			<div id="uploadItems" class="scmz">
			</div>
		</div>
		<!-- 代理设置弹窗 -->
<div id="proxySettingsModal" class="modal-overlay hidden">
    <div class="modal-form-container">
        <!-- 弹窗头部 -->
        <h3>
            <span class="modal-title-text">代理设置</span>
            <div class="proxy-header-actions">
                <label class="switch" title="点击切换全局代理状态">
                    <input type="checkbox" id="proxyGlobalEnableToggle">
                    <span class="slider round"></span>
                </label>
                <button id="proxyCancelSettingsBtn" class="btn-icon-sm" title="关闭设置">
                    <i class="fa fa-times"></i>
                </button>
            </div>
        </h3>

        <!-- 代理列表区域 -->
        <div class="proxy-list-container" id="proxyListContainer">
            <div class="empty-state hidden" id="proxyListEmpty">
                <i class="fa fa-plug"></i>
                <p>暂无代理节点</p>
                <span>点击右下角的 <i class="fa fa-plus-circle"></i> 添加，或从工具栏 <i class="fa fa-cloud-download"></i> 导入</span>
            </div>
            <!-- 代理项动态生成 -->
        </div>

        <!-- 底部操作区 -->
        <div class="proxy-footer-actions">
            <div class="proxy-footer-toolbar">
                <button id="importBtn" class="btn-icon" title="从订阅链接导入并刷新">
    <i class="fa fa-cloud-download"></i>
    <span class="spinner-small hidden" id="importSpinner"></span>
</button>
                <button id="proxyTestAllBtn" class="btn-icon" title="全部测试延迟">
                    <i class="fa-solid fa-bolt"></i>
                    <span class="spinner-small hidden" id="proxyTestAllSpinner"></span>
                </button>
                <button id="proxyAutoSelectToggle" class="btn-icon" title="点击切换自动选择最低延迟代理">
                    <i class="fa fa-magic"></i>
                </button>
                <button id="proxyClearAllBtn" class="btn-icon danger" title="清空所有代理">
                    <i class="fa-regular fa-trash-can"></i>
                </button>
                <button id="proxyAddBtn" class="btn-icon" title="添加代理">
            <i class="fa fa-plus"></i>
        </button>
            </div>
            
            
        </div>
    </div>
</div>
		<!-- 添加/编辑代理弹窗 -->
<div id="addEditProxyModal" class="modal-overlay hidden">
    <div class="modal-form-container">
        <h3 id="addEditProxyTitle">
            <span class="modal-title-text">添加新代理</span>
            <button class="btn-icon-sm" onclick="closeAddEditProxyModal()" title="关闭">
                <i class="fa fa-times"></i>
            </button>
        </h3>

        <input id="addEditProxyUrlInput" type="url" placeholder="请输入代理域名或URL" autocomplete="off">
        
        <div id="addEditProxyError" class="text-red-400" style="font-size: 0.75rem; margin-top: -0.4rem; margin-bottom: 0.4rem; display: none;">
            
        </div>

      

        
        <div class="modal-buttons" style="margin-top:0.6rem;">
            <button id="addEditProxyCancelBtn" class="btn btn-cancel">取消</button>
            <button id="addEditProxySaveBtn" class="btn btn-primary" disabled>保存</button>
        </div>
    </div>
</div>
		<!-- 确认删除代理弹窗 -->
		<div id="confirmDeleteProxyModal" class="modal-overlay hidden">
			<div class="modal-form-container">
				<h3 id="confirmDeleteProxyTitle">
					<span class="modal-title-text">
						确认删除
					</span>
					<button class="btn-icon-sm" onclick="hideConfirmDeleteProxyModal()" title="取消">
						<i class="fa fa-times">
						</i>
					</button>
				</h3>
				<p id="confirmDeleteProxyMessage">
				</p>
				<div class="modal-buttons">
					<button id="confirmDeleteProxyCancelBtn" class="btn btn-cancel">
						取消
					</button>
					<button id="confirmDeleteProxyConfirmBtn" class="btn btn-danger">
						确认删除
					</button>
				</div>
			</div>
		</div>
		<!-- 确认清空代理弹窗 -->
		<div id="confirmClearAllProxiesModal" class="modal-overlay hidden">
			<div class="modal-form-container">
				<h3>
					<span class="modal-title-text">
						确认清空所有代理
					</span>
					<button class="btn-icon-sm" onclick="hideConfirmClearAllProxiesModal()"
					title="取消">
						<i class="fa fa-times">
						</i>
					</button>
				</h3>
				<p>
					这将删除所有代理
				</p>
				<div class="modal-buttons">
					<button id="clearAllProxiesCancelBtn" class="btn btn-cancel">
						取消
					</button>
					<button id="clearAllProxiesConfirmBtn" class="btn btn-danger">
						确认清空
					</button>
				</div>
			</div>
		</div>
		
		
		
		<!-- 多选操作栏 -->
		<div id="multi-select-bar">
			<button class="action-btn cancel-btn" id="cancel-select-btn" title="取消">
				<i class="fa fa-times">
				</i>
			</button>
			<div id="selected-count">
				未选择项目
			</div>
			<div class="action-buttons">
				<button class="action-btn delete-btn" id="delete-btn" title="删除" disabled>
					<i class="fa-regular fa-trash-can"></i>
				</button>
				
				<button class="action-btn" id="download-btn" title="下载" disabled>
					<i class="fa-regular fa-circle-down"></i>
				</button>
				<button class="action-btn" id="invert-select-btn" title="反选" disabled>
					<i class="fa-solid fa-repeat"></i>
				</button>
				<button class="action-btn" id="select-all-btn" title="全选">
					<i class="fa-regular fa-square-minus">
					</i>
				</button>
			</div>
		</div>
		<!-- API状态侧边栏 -->
<div id="apiStatusOverlay" class="api-status-overlay hidden"></div>
<div id="apiStatusPanel" class="api-status-panel">
    <div class.api-status-header">

    <!-- 头部操作按钮 -->
    <div class="api-status-header-actions">
        <h5>数据监控 仪表盘</h5>
        <!-- 刷新按钮 -->
        <button id="refreshApiStatusBtn" class="btn-icon-sm" title="刷新">
            <i class="fa fa-refresh"></i>
        </button>
        <!-- 关闭按钮 -->
        <button id="closeApiStatusPanel" class="btn-icon-sm" title="关闭">
            <i class="fa fa-times"></i>
        </button>
    </div>
</div>


    <div id="apiStatusContent" class="api-status-content"> 
        <!-- 内容动态生成 -->
        <div class="loading-spinner" style="height: auto; padding: 2rem 0;">
            <div class="spinner">
            </div>
        </div>
    </div>
    
</div>
		<!-- 右键菜单设置弹窗 -->
<div id="contextMenuSettingsModal" class="modal-overlay hidden">
    <div class="modal-form-container">
        <h3>
            <span class="modal-title-text">长按菜单项设置</span>
            <button class="btn-icon-sm" id="contextMenuSettingsCloseBtn" title="关闭"><i class="fa fa-times"></i></button>
        </h3>
        <p style="font-size:0.7rem; margin-top:-0.4rem; margin-bottom:0.4rem;">选择在长按时希望看到的快捷操作</p>
        <div class="context-menu-settings-tabs">
        <button class="tab-btn  active" data-tab="file">文件</button>
        <button class="tab-btn" data-tab="folder">文件夹</button>
            <button class="tab-btn" data-tab="repo">仓库</button>
            
            
        </div>
        <div id="contextMenuSettingsContent">
            <!-- 设置项动态生成 -->
        </div>
    </div>
</div>


<!-- 隐藏的头像上传输入框 -->
    <input type="file" id="avatarUploadInput" class="hidden" accept="image/*">
    
    <div id="editorScaleHint" class="hidden">双指缩放来调整大小</div>
    
    
    
    
    <!-- [添加] 账号管理模态框 -->
<div id="accountManagerModal" class="modal-overlay hidden">
    <div class="modal-form-container">
        <h3>
            <span class="modal-title-text">账号管理</span>
            <button class="btn-icon-sm" id="closeAccountManagerModalBtn" title="关闭"><i class="fa fa-times"></i></button>
        </h3>
        
        <!-- 这个容器用于动态显示已保存的账号列表 -->
        <div id="accountListContainer" class="scmz">
            <!-- 账号列表项会由 JavaScript 动态生成并插入到这里 -->
        </div>

        <!-- 当没有保存任何账号时，显示此提示信息 -->
        <div id="accountListEmpty" class="empty-state hidden">
            <i class="fa fa-key"></i>
            <p>您还没有保存任何账号</p>
        </div>

        <!-- 弹窗底部的按钮区域 -->
        <div class="modal-buttons">
            <button id="showAddAccountModalBtn" class="btn btn-primary">
                <i class="fa fa-plus-circle"></i> 添加新账号
            </button>
        </div>
    </div>
</div>




<!-- ====================================================== -->
<!--              添加与编辑账号的弹窗 (模态框)              -->
<!-- ====================================================== -->
<div id="addEditAccountModal" class="modal-overlay hidden">
    <div class="modal-form-container">
        <h3 id="addEditAccountTitle">
            <span class="modal-title-text">添加新账号</span>
            <button class="btn-icon-sm" id="closeAddEditAccountModalBtn" title="关闭"><i class="fa fa-times"></i></button>
        </h3>
        
        <!-- 输入框：用于设置账号的自定义名称 -->
        <input id="accountNameInput" type="text" placeholder="设置一个名称" autocomplete="off">
        
        <!-- 输入框：用于粘贴用户的 GitHub 访问令牌 -->
        <input id="accountTokenInput" type="text" placeholder="粘贴你的GitHub访问令牌" autocomplete="off">
        
        <!-- 用于显示错误信息的容器 -->
        <div id="addEditAccountError" class="text-red-400"></div>
        
        <!-- 弹窗底部的按钮区域 -->
        <div class="modal-buttons">
            <button id="addEditAccountCancelBtn" class="btn btn-cancel">取消</button>
            <button id="addEditAccountSaveBtn" class="btn btn-primary" disabled>
                <span>保存</span><i class="fa fa-spinner fa-spin hidden"></i>
            </button>
        </div>
    </div>
</div>


<!-- 网站发布管理弹窗 -->
<div id="publishManagerModal" class="modal-overlay hidden">
    <div class="modal-form-container">
       <h3>
    <span class="modal-title-text">网站管理</span>
    <div style="display: flex; align-items: center;">
        <button class="btn-icon-sm" id="showPublishHelpBtn" title="帮助说明" style="margin-right: 0.5rem;"><i class="fa fa-question-circle"></i></button>
        <button class="btn-icon-sm" id="closePublishManagerBtn" title="关闭"><i class="fa fa-times"></i></button>
    </div>
</h3>
        
        <div id="publishManageList" class="publish-list">
            <!-- 统一的仓库列表将在这里生成 -->
        </div>

        <div class="modal-buttons">
                    <div class="modal-buttons publish-manager-tabs">
            <button id="officialConfigTabBtn" class="btn btn-tab active">
                官方配置
            </button>
            <button id="customDomainTabBtn" class="btn btn-tab">
                 自定义域名
            </button>
        </div>
        </div>
    </div>
</div>

<!-- Fork 仓库弹窗 -->
<div id="forkRepoModal" class="modal-overlay hidden">
    <div class="modal-form-container">
        <h3>
            <span class="modal-title-text">复刻仓库</span>
            <button class="btn-icon-sm" id="closeForkRepoModalBtn" title="关闭"><i class="fa fa-times"></i></button>
        </h3>
        <p id="forkOriginInfo" class="fork-origin-info"></p>
        <input id="forkRepoNameInput" placeholder="输入新的仓库名称">
        <div id="forkRepoError" class="text-red-400" style="font-size: 0.75rem; margin-top: 0.4rem; display: none;"></div>
        <div class="modal-buttons">
            <button id="forkRepoCancelBtn" class="btn btn-cancel">取消</button>
            <button id="forkRepoConfirmBtn" class="btn btn-primary" disabled>确认复刻</button>
        </div>
    </div>
</div>
<!-- 删除确认弹窗 -->
			<div id="deleteModal" class="modal-overlay hidden">
				<div class="modal-form-container">
					<h3 id="deleteTitle">
						<span class="modal-title-text">
							确认删除
						</span>
						<button class="btn-icon-sm" onclick="hideDeleteModal()"
						title="关闭">
							<i class="fa fa-times">
							</i>
						</button>
					</h3>
					<p id="deleteDesc">
					</p>
					<div class="modal-buttons">
						<button id="deleteCancel" class="btn btn-cancel">
							取消
						</button>
						<button id="deleteConfirm" class="btn btn-danger">
							确认删除
						</button>
					</div>
				</div>
			</div>
			
			<!-- 配置自定义域名弹窗 -->
<div id="customDomainModal" class="modal-overlay hidden">
    <div class="modal-form-container">
        <h3>
            <span class="modal-title-text">配置自定义域名</span>
            <button class="btn-icon-sm" id="closeCustomDomainModalBtn" title="关闭"><i class="fa fa-times"></i></button>
        </h3>
        <p id="customDomainRepoName" style="font-size: 0.8rem; color: #a2a7c7; margin-bottom: 0.8rem;"></p>
        <input id="customDomainInput" type="text" placeholder="例如: 123.baidu.com" autocomplete="off">
        <div id="customDomainError" class="text-red-400" style="font-size: 0.75rem; margin-top: -0.4rem; margin-bottom: 0.4rem; display: none;"></div>
        <div class="modal-buttons">
            <button id="customDomainCancelBtn" class="btn btn-cancel">取消</button>
            <button id="customDomainSaveBtn" class="btn btn-primary" disabled>
                <span>确认</span><i class="fa fa-spinner fa-spin hidden"></i>
            </button>
        </div>
    </div>
</div>


<div id="publishHelpModal" class="modal-overlay hidden">
    <div class="publish-help-dialog">
        <div class="publish-help-header">
            <h3><i class="fa-regular fa-circle-question"></i> 网站部署功能指南</h3>
            <button class="btn-icon-sm" id="closePublishHelpBtn" title="关闭"><i class="fa fa-times"></i></button>
        </div>
        <div class="publish-help-content scmz">
        
            <h4 style="color: #f87171;"><i class="fa-solid fa-triangle-exclamation"></i> 核心规则：域名使用限制</h4>
            <p style="font-weight: bold;">
                自定义域名同一时间只能用于主站或项目网站之一，不能同时使用。为其中一类配置域名，会导致另一类的自定义域名失效。请务必提前规划。
            </p>
           
            <h4><i class="fa-solid fa-bolt"></i> 功能概览</h4>
            <p>
                此功能利用 GitHub Pages 服务，将您的公开仓库一键发布为可公开访问的静态网站。它分为两个管理面板：
            </p>
            <ul>
                <li><b>官方配置：</b> 在此管理所有公开仓库的发布状态。您可以将任何仓库发布为项目网站，或将特定仓库设为您的个人主站。发布的网站将通过 GitHub 官方域名 (<code>*.github.io</code>) 访问。</li>
                <li><b>自定义域名：</b> 在此为您已经发布的网站绑定您自己的域名，让访问更专业、更便捷。</li>
            </ul>

            <h4><i class="fa-solid fa-sitemap"></i> 操作流程</h4>
            <ul>
                 <li><b>发布为主站：</b> 在“官方配置”面板中，找到您想作为主站的仓库，点击“发布为主站”按钮。程序会自动将其重命名为 <code>您的用户名.github.io</code> 并发布。</li>
                 <li><b>发布为项目：</b> 对于其他公开仓库，点击“发布项目”按钮，即可将其发布。</li>
                 <li><b>配置自定义域名：</b> 切换到“自定义域名”面板，找到已发布的网站，点击“配置域名”并按提示操作。</li>
                 <li><b>复制链接：</b> 在任一面板中，直接点击已发布的仓库条目，即可快速复制其对应的访问链接。</li>
            </ul>

            <h4><i class="fa-solid fa-link"></i> 自定义域名配置指南</h4>
            <p>
                要成功绑定您的域名，通常需要以下两个步骤：
            </p>
            <p><strong>第 1 步：在您的域名提供商处添加解析记录</strong></p>
            <ul>
                <li><b>记录类型：</b> 选择 <code>CNAME</code></li>
                <li><b>主机记录：</b> 填入您想使用的前缀，例如 <code>www</code> 或 <code>blog</code>。</li>
                <li><b>记录值 (指向)：</b> 填入您的 GitHub Pages 主站地址，格式为 <code>您的用户名.github.io</code>。
                    <ul style="margin-top:0.4rem;">
                        <li>例如：<code>rjdsq.github.io</code></li>
                    </ul>
                </li>
            </ul>
             <p style="margin-top:0.8rem;">
                <strong>第 2 步 (必须)：将您的域名添加到 Cloudflare</strong>
            </p>
            <p>
                为确保您的网站在中国大陆地区能被稳定访问并自动启用 HTTPS，强烈建议将您的域名添加到免费的 Cloudflare 服务中。
            </p>
            <ul>
                <li><b>配置地址：</b><code style="user-select: text;">https://dash.cloudflare.com</code></li>
                <li><b>操作建议：</b> 登录后，直接添加您的顶级域名（例如 <code>baidu.com</code>），Cloudflare 会自动引导您完成后续设置。</li>
            </ul>
            
            <h4><i class="fa-solid fa-clipboard-list"></i> 重要提示</h4>
            <ul>
                <li><b>仓库要求：</b> 只有<b>公开 (Public)</b> 仓库才能被发布为网站。</li>
                <li><b>主站唯一性：</b> 一个 GitHub 账号只能拥有一个主站，其仓库名必须严格遵守 <code>用户名.github.io</code> 的格式。</li>
                <li><b>取消发布：</b> 对于项目网站，此操作会禁用其 GitHub Pages 功能；对于主站，为安全起见，程序会将其重命名为一个备份名称来使其下线，您的文件不会丢失。</li>
                <li><b>CNAME 文件：</b> 成功配置自定义域名后，系统会在您的仓库根目录下创建一个名为 <code>CNAME</code> 的文件，请不要手动删除或修改它。</li>
            </ul>
        </div>
    </div>
</div>





<div id="usageGuideModal" class="modal-overlay hidden">
    <div class="publish-help-dialog">
        <div class="publish-help-header">
            <h3><i class="fa-solid fa-book-open"></i> 全能使用手册</h3>
            <button class="btn-icon-sm" id="closeUsageGuideBtn" title="关闭"><i class="fa fa-times"></i></button>
        </div>
        <div class="publish-help-content scmz">
            <p style="margin-bottom: 1rem;  font-size: 0.85rem;">
                本手册涵盖了应用内 100% 的功能细节与隐藏操作，助您成为真正的 GitHub King。
            </p>

            <h4><i class="fa-solid fa-compass"></i> 基础导航与视图</h4>
            <ul>
                <li><b>视图切换：</b> 点击工具栏 <i class="fa fa-th-large"></i> 按钮，可在“详细列表”与“网格图标”模式间切换（网格模式更适合预览图片）。</li>
                <li><b>智能排序：</b> 点击工具栏 <i class="fa-solid fa-up-down"></i> 按钮。支持按名称、大小、修改时间排序。默认开启“文件夹置顶”，让目录结构更清晰。</li>
                <li><b>星标/主页切换：</b> 在仓库列表页，点击顶部 <i class="fa-regular fa-star"></i> 可在“我的仓库”与“星标仓库 (Starred)”间快速切换。</li>
                <li><b>面包屑导航：</b> 顶部标题下方显示当前路径（如 <code>src/components/</code>），点击任意节点可快速跳转；点击标题文字可直接回退至根目录。</li>
                <li><b>下拉刷新：</b> 在任意列表顶部下拉，即可同步最新数据。</li>
            </ul>

            <h4><i class="fa-solid fa-layer-group"></i> 核心交互：万能长按菜单</h4>
            <p style="font-size: 0.75rem; color: #94a3b8;">在列表项上<b>长按 (手机)</b> 或 <b>右键 (电脑)</b> 触发：</p>
            
            <strong>1. 仓库级操作：</strong>
            <ul>
                <li><b>置顶/取消 (Pin)：</b> 将常用仓库固定在列表最顶部，不受更新时间影响。</li>
                <li><b>复刻 (Fork)：</b> 一键将他人的仓库完整克隆到您的账号下。</li>
                <li><b>查看所有仓库：</b> 快速列出该仓库作者名下的所有公开仓库。</li>
                <li><b>仓库设置：</b> 修改仓库名称、简介描述，或切换公开/私有状态。</li>
                <li><b>分支管理：</b> 创建新分支（支持基于特定分支）、重命名分支、删除分支。</li>
                <li><b>版本管理 (Releases)：</b> 创建发行版、上传附件、标记预发布、删除版本。</li>
                <li><b>代理下载：</b> 将整个仓库打包为 ZIP，通过加速节点下载。</li>
                <li><b>复制链接：</b> 包含主站链接、项目演示链接、自定义域名链接、GitHub 原生链接。</li>
                <li><b>仓库详情：</b> 查看 Star/Fork/Watch 统计、创建时间、语言构成及 Readme 预览。</li>
            </ul>

            <strong>2. 文件/文件夹操作：</strong>
            <ul>
                <li><b>进入目录：</b> (仅搜索结果中) 直接定位并跳转到该文件所在的具体文件夹。</li>
                <li><b>在线解压 (Unzip)：</b> 选中 ZIP 文件长按，直接在云端解压并上传到当前目录（支持覆盖检测）。</li>
                <li><b>下载 ZIP：</b> (仅文件夹) 将文件夹自动打包并下载。</li>
                <li><b>编辑/重命名：</b> 打开代码编辑器或修改文件名。</li>
                <li><b>复制链接组：</b>
                    <br>- <b>Raw：</b> 原始数据流链接。
                    <br>- <b>Proxy：</b> 经过 CDN 加速的下载链接（适合分享）。
                    <br>- <b>Pages：</b> 该文件的静态网页访问地址。
                </li>
            </ul>

            <h4><i class="fa-solid fa-terminal"></i> 极客搜索语法 (顶部搜索框)</h4>
            <ul>
                <li><b>搜公共库：</b> 直接输入关键词（如 <code>react</code>）。</li>
                <li><b>搜用户：</b> 输入 <code>@</code> + 用户名（如 <code>@google</code>），查看其所有仓库。</li>
                <li><b>搜我的文件：</b> 输入 <code>#</code> + 文件名（如 <code>#config.js</code>），深度遍历您名下<b>所有</b>仓库。</li>
                <li><b>链接直达：</b> 粘贴 GitHub 仓库或文件链接，自动解析并跳转。</li>
                <li><b>本地搜索：</b> 进入仓库后，使用工具栏的 <i class="fa fa-search"></i> 可在<b>当前仓库</b>内递归搜索文件。</li>
            </ul>

            <h4><i class="fa-solid fa-code"></i> 编辑器与媒体预览</h4>
            <ul>
                <li><b>双指缩放：</b> 在代码编辑器中，双指捏合/张开可无级调节字体大小。</li>
                <li><b>沉浸全屏：</b> 点击编辑器底部 <i class="fa fa-expand"></i> 进入全屏模式。</li>
                <li><b>内容查找：</b> 编辑器内支持关键词高亮查找与跳转。</li>
                <li><b>撤销修改：</b> 未保存前，点击 <i class="fa fa-undo"></i> 可一键还原文件。</li>
                <li><b>媒体画廊：</b> 支持图片、视频在线预览。</li>
                <li><b>音频频谱：</b> 播放音频文件时，底部导航栏背景特效会出现随音乐律动的波纹彩蛋。</li>
            </ul>

            <h4><i class="fa-solid fa-toolbox"></i> 批量操作与网络工具</h4>
            <ul>
                <li><b>多选模式：</b> 点击工具栏 <i class="fa-regular fa-circle-check"></i> 进入。
                    <br>- 支持<b>反选</b>、<b>全选</b>。
                    <br>- <b>批量删除：</b> 一次性删除多个文件/文件夹。
                    <br>- <b>批量下载：</b> 将选中的多个文件打包成一个 ZIP 下载。
                </li>
                <li><b>智能代理：</b> 导入代理源后，系统会<b>自动并发测速</b>，并静默切换到当前网络下延迟最低的节点，加速图片加载与下载。</li>
                <li><b>API 仪表盘：</b> 侧边栏“数据监控”，实时显示 Core/Search 额度使用情况及重置时间。</li>
                <li><b>多账号管理：</b> 登录页或侧边栏可添加多个 Token，一键无缝切换账号。</li>
            </ul>

            <h4><i class="fa-solid fa-wand-magic-sparkles"></i> 个性化定制</h4>
            <ul>
                <li><b>云端插件：</b> 侧边栏“主题设置”中，插件列表实时从云端更新（如下雨、樱花、极光）。</li>
                <li><b>层级控制：</b> 插件支持切换<b>“顶层”</b>（覆盖内容，视觉强）或<b>“背景特效”</b>（置于底层，不挡操作）。</li>
                <li><b>日夜模式：</b> 点击侧边栏头像旁的图标，在暗色/亮色主题间切换。</li>
            </ul>
        </div>
    </div>
</div>




<div id="repoDetailsModal" class="modal-overlay hidden">
    <div class="repo-details-dialog">
        <div class="repo-details-header">
            <img id="repoDetailsAvatar" src="" alt="Owner Avatar">
            <div class="repo-details-title">
                <h3 id="repoDetailsName"></h3>
                <p id="repoDetailsOwner"></p>
            </div>
            <button id="repoDetailsCloseBtn" class="btn-icon-sm" title="关闭"><i class="fa fa-times"></i></button>
        </div>

        <div class="repo-details-stats">
            <span id="repoDetailsStars"><i class="fa-regular fa-star"></i> ---</span>
            <span id="repoDetailsForks"><i class="fa-solid fa-code-fork"></i> ---</span>
            <span id="repoDetailsWatchers"><i class="fa-regular fa-eye"></i> ---</span>
        </div>

        <div class="repo-details-body">
            <p id="repoDetailsDescription"></p>
        </div>

        <div class="repo-details-topics" id="repoDetailsTopics">
        </div>

        <div class="repo-details-meta">
            <p id="repoDetailsLanguage"><strong>语言：</strong> ---</p>
            <p id="repoDetailsLicense"><strong>许可证：</strong> ---</p>
            <p id="repoDetailsDates">---</p>
        </div>

        <div class="repo-details-footer">
            <button id="repoDetailsGoToBtn" class="btn btn-primary">进入仓库</button>
        </div>
    </div>
</div>


<!-- 待上传文件管理面板 -->
<div id="preUploadModal" class="modal-overlay hidden">
    <div class="modal-form-container">
        <h3>
            <span class="modal-title-text">待上传文件</span>
            <button class="btn-icon-sm" onclick="hidePreUploadModal()" title="关闭">
                <i class="fa fa-times"></i>
            </button>
        </h3>
        
        <div id="preUploadList" class="scmz" style="max-height: 300px; overflow-y: auto; margin: 10px 0; border: 1px solid #374151; border-radius: 4px; padding: 5px;">
            <div class="empty-state" style="padding: 20px;">
                <p>暂无文件，请点击下方按钮添加</p>
            </div>
        </div>

        <div class="modal-buttons" style="justify-content: space-between;">
            <button id="preUploadAddBtn" class="btn btn-secondary">
                <i class="fa fa-plus"></i> 添加文件
            </button>
            <div style="display: flex; gap: 10px;">
                <button id="preUploadClearBtn" class="btn btn-danger">清空</button>
                <button id="preUploadStartBtn" class="btn btn-primary">开始上传</button>
            </div>
        </div>
    </div>
</div>




<!-- 版本管理/发布弹窗 (修复缺失部分) -->
<div id="releaseManagerModal" class="modal-overlay hidden">
    <div class="modal-form-container">
        <h3>
            <span class="modal-title-text">发布新版本</span>
            <button class="btn-icon-sm" id="closeReleaseManagerBtn" title="关闭">
                <i class="fa fa-times"></i>
            </button>
        </h3>
        
        <!-- 发布表单 -->
        <div id="createReleaseForm" class="flex flex-col gap-2">
        
        <div class="form-group">
                <label style="font-size:0.75rem; color:#a2a7c7;">标题</label>
                <input id="releaseNameInput" placeholder="版本标题 (可选)">
            </div>
            
            <div class="form-group">
                <label style="font-size:0.75rem; color:#a2a7c7;">版本号</label>
                <input id="releaseTagNameInput" placeholder="v1.0.0">
            </div>
            
            
            
            <div class="form-group">
                <label style="font-size:0.75rem; color:#a2a7c7;">描述内容</label>
                <textarea id="releaseBodyInput" placeholder="本次更新了什么..." style="min-height:100px;"></textarea>
            </div>

            <div class="checkbox-container" style="margin-bottom:10px;">
                <input type="checkbox" id="releasePrerelease">
                <label for="releasePrerelease">设为预发布 (Pre-release)</label>
            </div>

            <div class="modal-buttons">
                <button id="cancelReleaseBtn" class="btn btn-cancel">取消</button>
                <button id="submitReleaseBtn" class="btn btn-primary">发布版本</button>
            </div>
        </div>
        
        <!-- 这里的隐藏元素是为了兼容原有JS逻辑防止报错 -->
        <div id="releaseManagerList" class="hidden"></div>
        <span id="releaseCountBadge" class="hidden"></span>
        <button id="toggleCreateReleaseFormBtn" class="hidden"><i class="fa fa-chevron-down"></i></button>
    </div>
</div>



<!-- 插件弹窗 -->
<div id="effectsManagerModal" class="modal-overlay hidden">
    <div class="modal-form-container">
        <h3>
            <span class="modal-title-text">在线插件</span>
            <div style="display: flex; align-items: center; gap: 0.5rem;">
                <button class="btn-icon-sm" id="refreshEffectsManagerBtn" title="刷新">
                    <i class="fa fa-refresh"></i>
                </button>
                <button class="btn-icon-sm" id="closeEffectsManagerBtn" title="关闭">
                    <i class="fa fa-times"></i>
                </button>
            </div>
        </h3>
        
        <div id="effectsList" class="scmz" style="max-height: 400px; min-height: 260px; overflow-y: auto; display: flex; flex-direction: column; gap: 0.5rem; padding-bottom: 0.3rem;">
        </div>
    </div>
</div>





<!-- 仓库概览/入口模态框 -->
<div id="repoOverviewModal" class="modal-overlay hidden">
    <div class="repo-overview-card">
        <!-- 头部：标题与描述 -->
        <div class="repo-overview-header">
            <!-- 找到 id="repoOverviewModal" 内部的 .repo-header-top 区域 -->
<div class="repo-header-top">
    <img id="overviewAvatar" src="" alt="Avatar">
    <div class="repo-title-block">
        <h3 id="overviewName">Repository Name</h3>
        <div class="repo-badges">
            <span id="overviewLang" class="badge">Java</span>
            <span id="overviewSize" class="badge">9.48 MB</span>
            <span id="overviewLicense" class="badge">MIT</span>
        </div>
    </div>
    
    <!-- [核心修改]：在关闭按钮左侧增加了一个开关容器 -->
    <div style="display: flex; align-items: center; gap: 8px;">
        <label class="switch" title="开启后，点击列表将直接进入仓库" style="transform: scale(0.75); transform-origin: right center;">
            <input type="checkbox" id="overviewDirectEntryToggle">
            <span class="slider round"></span>
        </label>
        <button class="btn-icon-sm" id="closeOverviewBtn" title="关闭">
            <i class="fa fa-times"></i>
        </button>
    </div>
    <!-- [修改结束] -->
    
</div>
            <p id="overviewDesc">这里是仓库的描述信息...</p>
            <div class="repo-dates">
                <i class="fa-regular fa-clock"></i> <span id="overviewDates">Updated 7s ago</span>
            </div>
        </div>

        <!-- 核心统计数据 (四宫格) -->
        <div class="repo-stats-grid">
            <div class="stat-item">
                <span id="statIssues" class="stat-num">25</span>
                <span class="stat-label">问题</span>
            </div>
            <div class="stat-item">
                <span id="statStars" class="stat-num">912</span>
                <span class="stat-label">星标</span>
            </div>
            <div class="stat-item">
                <span id="statForks" class="stat-num">65</span>
                <span class="stat-label">复刻</span>
            </div>
            <div class="stat-item">
                <span id="statWatchers" class="stat-num">33</span>
                <span class="stat-label">围观</span>
            </div>
        </div>

        <!-- README 预览 / 功能区 -->
        <div class="repo-overview-body">
           <!-- <h4 class="section-title">README：</h4>-->
            <div id="overviewReadme" class="readme-preview">
                <div class="loading-spinner small"><div class="spinner-small"></div> 正在加载简介...</div>
            </div>
        </div>

        <!-- 底部操作按钮 -->
        <div class="repo-overview-footer">
            <button id="overviewStarBtn" class="btn btn-secondary">
                <i class="fa-regular fa-star"></i> 关注
            </button>
            <!-- 核心按钮：进入文件列表 -->
            <button id="overviewEnterBtn" class="btn btn-primary">
                <i class="fa-solid fa-code"></i> 进入代码浏览
            </button>
        </div>
    </div>
</div>



<div id="tokenGuideModal" class="modal-overlay hidden">
    <div class="modal-form-container auth-glass-modal">
        <h3>
            <span class="modal-title-text">令牌获取指南</span>
            <button class="btn-icon-sm" id="closeTokenGuideBtn">
                <i class="fa fa-times"></i>
            </button>
        </h3>
        <div class="token-guide-content">
            <ol>
                <li>
                    复制下方官网链接，在浏览器中打开：
                    <div class="code-box">https://github.com/settings/tokens/new</div>
                </li>
                <li>
                    登录 GitHub 官网
                    <small>若登陆后未跳转至token生成页，请再次粘贴链接进行访问</small>
                </li>
                <li>
                    在设置页面配置权限：
                    <ul>
                        <li><strong>Note 备注：</strong> 随意填写</li>
                        <li><strong>Expiration (有效期)：</strong> 建议选择 "No expiration" 永不过期或自定义时间</li>
                        <li><strong>Select scopes (权限)：</strong> <span class="highlight">务必勾选 "repo" </span> 这是读写仓库所必须的， 推荐所有勾选框都打勾</li>
                    </ul>
                </li>
                <li>滑动到底部，点击绿色的 <strong>Generate token</strong> 保存按钮</li>
                <li>
                    <strong>复制</strong> 生成的字符串 (ghp_开头)，回到本应用粘贴登录
                </li>
            </ol>
        </div>
        <div class="modal-buttons">
            <button id="tokenGuideKnownBtn" class="btn btn-primary" style="width: 100%; ">我已知晓</button>
        </div>
    </div>
</div>






<script>

let currentManagingRepo = null;
let imageObserver = null;
const CURRENT_VERSION = "3.9";
document.documentElement.style.userSelect = 'none';

let modalLastTapTime = 0;
let modalLastTappedRepoId = null;
let currentFetchController = null;
let isContextMenuClosing = false;
const PROXY_TEST_URL = 'https://raw.githubusercontent.com/rjdsq/github-king/main/代理/代理.txt';
const IMAGE_EXTS = ['png', 'jpg', 'jpeg', 'gif', 'webp', 'ico', 'bmp', 'svg'];
const VIDEO_EXTS = ['mp4', 'webm', 'ogg', 'mov', 'avi', 'mkv'];
const AUDIO_EXTS = ['mp3', 'wav', 'ogg', 'flac', 'm4a'];
const ZIP_EXTS = ['zip',];
const uiStateStack = [];


const NON_EDITABLE_EXTS = [
    'zip', 'rar', '7z', 'tar', 'gz', 'iso', 'bin',
    'pdf', 'doc', 'docx', 'xls', 'xlsx', 'ppt', 'pptx',
    'exe', 'dll', 'so', 'dmg', 'app', 'apk',
    'woff', 'woff2', 'ttf', 'otf',
    'db', 'sqlite', 'mdb'
];



const UpdatedFilesManager = {
    getKey(path) {
        return `smart_sha_${state.currentRepo}_${state.currentBranch}_${path}`;
    },
    get(path) {
        return localStorage.getItem(this.getKey(path));
    },
    set(path, sha) {
        localStorage.setItem(this.getKey(path), sha);
    },
    remove(path) {
        localStorage.removeItem(this.getKey(path));
    }
};


const ConsistencyManager = {
    DURATION: 60000, 
    buffer: [],

    // 核心修复：强力路径标准化，忽略末尾斜杠差异
    isSameDir(pathA, pathB) {
        const a = (pathA || '').replace(/\/+$/, '');
        const b = (pathB || '').replace(/\/+$/, '');
        return a === b;
    },

    add(action) {
        this.load();
        this.clean();
        
        // 防重：移除针对同一文件的旧记录
        const targetPath = action.file ? action.file.path : (action.path || action.oldPath);
        if (targetPath) {
            this.buffer = this.buffer.filter(item => {
                const itemPath = item.file ? item.file.path : (item.path || item.oldPath);
                return itemPath !== targetPath;
            });
        }

        this.buffer.push({ ...action, timestamp: Date.now() });
        this.save();
    },

    clean() {
        const now = Date.now();
        this.buffer = this.buffer.filter(item => now - item.timestamp < this.DURATION);
    },

    save() {
        try {
            localStorage.setItem('consistency_buffer', JSON.stringify(this.buffer));
        } catch(e) {}
    },

    load() {
        try {
            const saved = JSON.parse(localStorage.getItem('consistency_buffer') || '[]');
            this.buffer = Array.isArray(saved) ? saved : [];
        } catch (e) {
            this.buffer = [];
        }
    },

    apply(fileList) {
        this.load();
        this.clean();
        
        if (this.buffer.length === 0) return fileList || [];

        let result = [...(fileList || [])];
        const currentPath = state.currentPath || '';

        this.buffer.forEach(action => {
            // --- 删除 ---
            if (action.type === 'delete') {
                result = result.filter(f => f.path !== action.path && !f.path.startsWith(action.path + '/'));
            }
            // --- 新增 ---
            else if (action.type === 'add') {
                // 只有当当前目录匹配时才插入
                if (this.isSameDir(action.parentPath, currentPath)) {
                    result = result.filter(f => f.path !== action.file.path); // 先删旧
                    result.push(action.file); // 再加新
                }
            }
            // --- 重命名 ---
            else if (action.type === 'rename') {
                // 1. 在当前视图中移除旧文件
                result = result.filter(f => f.path !== action.oldPath);
                
                // 2. 如果新文件在当前视图，则添加
                if (this.isSameDir(action.newParentPath, currentPath)) {
                    result = result.filter(f => f.path !== action.newFile.path);
                    result.push(action.newFile);
                }
            }
        });

        return result;
    }
};
// 初始化
ConsistencyManager.load();




const SimpleDB = {
    DB_NAME: 'GithubManagerDataDB',
    STORE_NAME: 'general_store',
    INDEX_NAME: 'lastAccessed',
    DB_VERSION: 2,
    MAX_STORAGE_BYTES: 5 * 1024 * 1024 * 1024,
    dbPromise: null,

    init() {
        if (!this.dbPromise) {
            this.dbPromise = new Promise((resolve, reject) => {
                const request = indexedDB.open(this.DB_NAME, this.DB_VERSION);
                request.onupgradeneeded = (e) => {
                    const db = e.target.result;
                    if (db.objectStoreNames.contains(this.STORE_NAME)) {
                        db.deleteObjectStore(this.STORE_NAME);
                    }
                    const store = db.createObjectStore(this.STORE_NAME, { keyPath: 'key' });
                    store.createIndex(this.INDEX_NAME, this.INDEX_NAME, { unique: false });
                };
                request.onsuccess = (e) => resolve(e.target.result);
                request.onerror = (e) => reject(e);
            });
        }
        return this.dbPromise;
    },

    async get(key) {
        const db = await this.init();
        return new Promise((resolve) => {
            const tx = db.transaction(this.STORE_NAME, 'readwrite');
            const store = tx.objectStore(this.STORE_NAME);
            const req = store.get(key);
            req.onsuccess = () => {
                const record = req.result;
                if (record) {
                    resolve(record.value);
                    const now = Date.now();
                    if (now - record.lastAccessed > 1000 * 60 * 60) {
                        record.lastAccessed = now;
                        store.put(record);
                    }
                } else {
                    resolve(null);
                }
            };
            req.onerror = () => resolve(null);
        });
    },

    async set(key, value) {
        const db = await this.init();
        const record = {
            key: key,
            value: value,
            lastAccessed: Date.now()
        };
        return new Promise(async (resolve, reject) => {
            const tx = db.transaction(this.STORE_NAME, 'readwrite');
            const store = tx.objectStore(this.STORE_NAME);
            const req = store.put(record);
            req.onsuccess = () => {
                resolve();
                this.enforceLimits();
            };
            req.onerror = (e) => {
                if (e.target.error.name === 'QuotaExceededError') {
                    this.enforceLimits(true).then(() => {
                        this.set(key, value).then(resolve).catch(reject);
                    });
                } else {
                    reject(e);
                }
            };
        });
    },

    async del(key) {
        const db = await this.init();
        return new Promise((resolve) => {
            const tx = db.transaction(this.STORE_NAME, 'readwrite');
            tx.objectStore(this.STORE_NAME).delete(key);
            tx.oncomplete = () => resolve();
        });
    },

    async clear() {
        const db = await this.init();
        return new Promise((resolve) => {
            const tx = db.transaction(this.STORE_NAME, 'readwrite');
            tx.objectStore(this.STORE_NAME).clear();
            tx.oncomplete = () => resolve();
        });
    },

    async keys() {
        const db = await this.init();
        return new Promise((resolve) => {
            const tx = db.transaction(this.STORE_NAME, 'readonly');
            const req = tx.objectStore(this.STORE_NAME).getAllKeys();
            req.onsuccess = () => resolve(req.result);
        });
    },

    async enforceLimits(forceImmediate = false) {
        if (!forceImmediate && Math.random() > 0.1) return;
        
        try {
            const estimate = await navigator.storage.estimate();
            if (estimate.usage <= this.MAX_STORAGE_BYTES) return;

            const db = await this.init();
            const tx = db.transaction(this.STORE_NAME, 'readwrite');
            const store = tx.objectStore(this.STORE_NAME);
            const index = store.index(this.INDEX_NAME);
            const cursorReq = index.openCursor(); 
            let deletedCount = 0;

            cursorReq.onsuccess = async (e) => {
                const cursor = e.target.result;
                if (cursor) {
                    cursor.delete();
                    deletedCount++;
                    const currentEstimate = await navigator.storage.estimate();
                    if (currentEstimate.usage > this.MAX_STORAGE_BYTES) {
                        cursor.continue();
                    }
                }
            };
        } catch (e) {
            console.warn(e);
        }
    }
};



const state = {
    
    accounts: JSON.parse(localStorage.getItem('github_accounts') || '[]'),
    activeAccountId: localStorage.getItem('active_github_account_id') || null,
    token: null,
    localAvatar: null,
    viewingOwner: null,
    pendingUploadFiles: [], 
    currentRepo: null,
    currentPath: '',
    currentBranch: null,
    branches: [],
    files: [],
    publicSearchQuery: '',
    displayFiles: [],
    isRefreshing: false,
    repos: [],
    starredRepos: [],
    selectedFile: null,
    selectedRepo: null,
    uploadQueue: [],
    releases: [],                      // 用于存储当前仓库的版本列表
    currentRelease: null,              // 用于存储当前正在查看的单个版本对象
    viewingReleasesForRepo: null,   
    
    editingFile: null,
    fileSha: '',
    publishManagerActiveTab: 'official',
    configuringDomainRepoFullName: null,
    
    publicSearchPage: 1,
    publicSearchTotalResults: 0,
    publicSearchPerPage: 20, 
    
    repoListScrollPosition: 0,
    publicSearchCache: new Map(),
    
    
    myRepos: [],
    
    
    originalContent: '',
    proxies: JSON.parse(localStorage.getItem('proxies') || '[]'),
    activeProxyIndex: parseInt(localStorage.getItem('active_proxy_index') || '0'),
    proxyGlobalEnable: JSON.parse(localStorage.getItem('proxy_global_enable') || 'true'),
    autoSelectProxy: JSON.parse(localStorage.getItem('proxy_auto_select') || 'false'),
    editingProxyIndex: null,
    user: null,
    fileCache: new Map(),
    viewMode: localStorage.getItem('view_mode') || 'grid',
    sortBy: localStorage.getItem('sort_by') || 'name_asc',
    
    
        directorySortPriority: localStorage.getItem('directory_sort_priority') || 'dirs_first',
    searchQuery: '',
    REPOS_PER_PAGE: 20,
    myReposPage: 1,
    starredReposPage: 1,
    userReposPage: 1,
    
   
    
    isMultiSelectMode: false,
    selectedItems: new Set(),
    contextMenuVisibility: {},
    shouldAnimateList: true,
    currentView: 'own_repos',
    viewingOwner: null,
    editorSearchState: {
    query: '',
    matches: [],
    currentIndex: -1
},

    
    isSearchResultsView: false,
    isLocalSearchResultsView: false,
    lastSearchResults: [],
    currentRepoList: [],
   searchHistory: [],
  
    pullToRefresh: {
        active: false,
        startY: 0,
        pullDistance: 0,
        threshold: 60,
        el: null,
        indicator: null
    }
};




const recentlySavedCache = new Map();

if (state.proxies.length === 0) {
    state.activeProxyIndex = -1;
} else if (state.activeProxyIndex < 0 || state.activeProxyIndex >= state.proxies.length) {
    state.activeProxyIndex = 0;
}


initializeActiveToken(); 
const CONTEXT_MENU_DEFINITIONS = {
    repo: [
        { action: 'togglePin', icon: 'fa-thumbtack', text: '置顶/取消' },
        { action: 'forkRepo', icon: 'fa-code-fork', text: '复刻仓库' },
        
        { action: 'viewUserRepos', icon: 'fa-solid fa-user-group', text: '所有仓库' },
        { action: 'renameRepo', icon: 'fa-pencil', text: '仓库设置' },
        { action: 'createBranch', icon: 'fa-code-fork', text: '分支管理' },
        { action: 'manageReleases', icon: 'fa-tags', text: '版本管理' },
        { action: 'downloadRepoDirect', icon: 'fa-regular fa-circle-down', text: '代理下载' },
        { action: 'copyMainSiteLink', icon: 'fa-link', text: '主站链接' },
        { action: 'copyProjectSiteLink', icon: 'fa-link', text: '网站链接' },
        { action: 'copyCustomDomainLink', icon: 'fa-link', text: '域名链接' },
        { action: 'copyRepoGitHubLink', icon: 'fa-link', text: '仓库链接' },
        { action: 'viewDetails', icon: 'fa-regular fa-eye', text: '仓库详情' },
        { action: 'deleteRepo', icon: 'fa-trash', text: '删除', className: 'text-red-400' }
    ],
    
    folder: [
        { action: 'copyPagesLink', icon: 'fa-globe', text: '网站链接' },
        { action: 'copyGitHubLink', icon: 'fa-link', text: '仓库链接' },
        { action: 'rename', icon: 'fa-pencil', text: '重命名' },
        { action: 'downloadFolder', icon: 'fa-regular fa-circle-down', text: '下载 ZIP' },
        { action: 'delete', icon: 'fa-trash', text: '删除', className: 'text-red-400' }
    ],
    
    file: [
        { action: 'goToDirectory', icon: 'fa-regular fa-folder-open', text: '进入目录' }, 
        { action: 'edit', icon: 'fa-edit', text: '编辑' },
        { action: 'rename', icon: 'fa-pencil', text: '重命名' },
        { action: 'download', icon: 'fa-download', text: '代理下载' },
        { action: 'copyPagesLink', icon: 'fa-link', text: '网站链接' },
        { action: 'copyCustomDomainLink', icon: 'fa-link', text: '域名链接' },
        { action: 'copyGitHubLink', icon: 'fa-link', text: '仓库链接' },
        { action: 'copyLink', icon: 'fa-link', text: '复制raw链接' },
        { action: 'copyProxy', icon: 'fa-link', text: '复制代理链接' },
        { action: 'unzip', icon: 'fa-regular fa-circle-down', text: '解压缩(仅ZIP)' },
        { action: 'delete', icon: 'fa-trash', text: '删除', className: 'text-red-400' }
    ]
};
const DEFAULT_MENU_VISIBILITY = {
    repo: CONTEXT_MENU_DEFINITIONS.repo.reduce((acc, item) => ({ ...acc, [item.action]: true }), {}),
    folder: CONTEXT_MENU_DEFINITIONS.folder.reduce((acc, item) => ({ ...acc, [item.action]: true }), {}),
    file: CONTEXT_MENU_DEFINITIONS.file.reduce((acc, item) => ({ ...acc, [item.action]: true }), {})
};

const el = {

main: document.querySelector('main'), 
    authScreen: document.getElementById('authScreen'),
    app: document.getElementById('app'),
    tokenInput: document.getElementById('tokenInput'),
    authBtn: document.getElementById('authBtn'),
    fileList: document.getElementById('fileList'),
    repoList: document.getElementById('repoList'),
    pathNav: document.getElementById('pathNav'),
    pathNavContainer: document.getElementById('pathNavContainer'),
    ybp: document.getElementById('ybp'),
    branchSwitcherContainer: document.getElementById('branchSwitcherContainer'),
    backBtn: document.getElementById('backBtn'),
    newFolderBtn: document.getElementById('newFolderBtn'),
    uploadBtn: document.getElementById('uploadBtn'),
    sideNav: document.getElementById('sideNav'),
    // 在 const el = { ... } 内部添加：
    newReleaseBtn: document.getElementById('newReleaseBtn'),
    mainOverlay: document.getElementById('mainOverlay'),
    sideNavToggleBtn: document.getElementById('sideNavToggleBtn'),
    menuUsageGuide: document.getElementById('menuUsageGuide'), // <--- 添加这一行
    usageGuideModal: document.getElementById('usageGuideModal'),   // <--- 添加这一行
    closeUsageGuideBtn: document.getElementById('closeUsageGuideBtn'),
    contextMenu: document.getElementById('contextMenu'),
    contextMenuItems: document.getElementById('contextMenuItems'),
    toast: document.getElementById('toast'),
    toastMessage: document.getElementById('toastMessage'),
    uploadPanel: document.getElementById('uploadPanel'),
    uploadItems: document.getElementById('uploadItems'),
    editModal: document.getElementById('editModal'),
    editFileName: document.getElementById('editFileName'),
    fileContent: document.getElementById('fileContent'),
    closeEditModal: document.getElementById('closeEditModal'),
    cancelEdit: document.getElementById('cancelEdit'),
    saveEdit: document.getElementById('saveEdit'),
    editStatus: document.getElementById('editStatus'),
    editorOverlay: document.getElementById('editorOverlay'),
    saveNotification: document.getElementById('saveNotification'),
    setAsSiteModal: document.getElementById('setAsSiteModal'),
setAsSiteCloseBtn: document.getElementById('setAsSiteCloseBtn'),
setAsSiteCancelBtn: document.getElementById('setAsSiteCancelBtn'),
setAsSiteConfirmBtn: document.getElementById('setAsSiteConfirmBtn'),
    fileUploadInput: document.getElementById('fileUploadInput'),
    mainLoader: document.getElementById('mainLoader'),
    repoDetailsModal: document.getElementById('repoDetailsModal'),
    menuLogout: document.getElementById('menuLogout'),
    menuProxySettings: document.getElementById('menuProxySettings'),
    proxyTestAllBoltIcon: document.querySelector('#proxyTestAllBtn > i'),
    
    menuBatchPublishSites: document.getElementById('menuBatchPublishSites'),
    newFileBtn: document.getElementById('newFileBtn'),
    
     publishManageList: document.getElementById('publishManageList'),
       customDomainTabBtn: document.getElementById('customDomainTabBtn'),


    releaseManagerModal: document.getElementById('releaseManagerModal'),
    closeReleaseManagerBtn: document.getElementById('closeReleaseManagerBtn'),
    releaseTagNameInput: document.getElementById('releaseTagNameInput'),
    releaseNameInput: document.getElementById('releaseNameInput'),
    releaseBodyInput: document.getElementById('releaseBodyInput'),
    releasePrerelease: document.getElementById('releasePrerelease'),
    submitReleaseBtn: document.getElementById('submitReleaseBtn'),
    cancelReleaseBtn: document.getElementById('cancelReleaseBtn'),




    customDomainModal: document.getElementById('customDomainModal'),
    closeCustomDomainModalBtn: document.getElementById('closeCustomDomainModalBtn'),
    customDomainRepoName: document.getElementById('customDomainRepoName'),
    customDomainInput: document.getElementById('customDomainInput'),
    customDomainError: document.getElementById('customDomainError'),
    customDomainCancelBtn: document.getElementById('customDomainCancelBtn'),
    customDomainSaveBtn: document.getElementById('customDomainSaveBtn'),
menuUsageGuide: document.getElementById('menuUsageGuide'),
    preUploadModal: document.getElementById('preUploadModal'),
    preUploadList: document.getElementById('preUploadList'),
    preUploadAddBtn: document.getElementById('preUploadAddBtn'),
    preUploadStartBtn: document.getElementById('preUploadStartBtn'),
    preUploadClearBtn: document.getElementById('preUploadClearBtn'),
    customDomainTabBtn: document.getElementById('customDomainTabBtn'),
    toolbar: document.getElementById('toolbar'),
    searchInput: document.getElementById('searchInput'),
    viewToggleBtn: document.getElementById('viewToggleBtn'),
    proxyQuickToggle: document.getElementById('proxyQuickToggle'),
    proxySettingsModal: document.getElementById('proxySettingsModal'),
    proxyAutoSelectToggle: document.getElementById('proxyAutoSelectToggle'),
    userName: document.getElementById('userName'),
    importBtn: document.getElementById('importBtn'),
    proxyGlobalEnableToggle: document.getElementById('proxyGlobalEnableToggle'),
    proxyAddBtn: document.getElementById('proxyAddBtn'),
    proxyListContainer: document.getElementById('proxyListContainer'),
    proxyListEmpty: document.getElementById('proxyListEmpty'),
    proxyTestAllBtn: document.getElementById('proxyTestAllBtn'),
    proxyTestAllSpinner: document.getElementById('proxyTestAllSpinner'),
    proxyClearAllBtn: document.getElementById('proxyClearAllBtn'),
    proxyCancelSettingsBtn: document.getElementById('proxyCancelSettingsBtn'),
    addEditProxyModal: document.getElementById('addEditProxyModal'),
    addEditProxyTitle: document.getElementById('addEditProxyTitle'),
    addEditProxyUrlInput: document.getElementById('addEditProxyUrlInput'),
    addEditProxyError: document.getElementById('addEditProxyError'),
    addEditProxySaveBtn: document.getElementById('addEditProxySaveBtn'),
    confirmDeleteProxyModal: document.getElementById('confirmDeleteProxyModal'),
    confirmDeleteProxyTitle: document.getElementById('confirmDeleteProxyTitle'),
        importSpinner: document.getElementById('importSpinner'),
    confirmDeleteProxyMessage: document.getElementById('confirmDeleteProxyMessage'),
    confirmDeleteProxyCancelBtn: document.getElementById('confirmDeleteProxyCancelBtn'),
    confirmDeleteProxyConfirmBtn: document.getElementById('confirmDeleteProxyConfirmBtn'),
    confirmClearAllProxiesModal: document.getElementById('confirmClearAllProxiesModal'),
    clearAllProxiesCancelBtn: document.getElementById('clearAllProxiesCancelBtn'),
    clearAllProxiesConfirmBtn: document.getElementById('clearAllProxiesConfirmBtn'),
    renameModal: document.getElementById('renameModal'),
    renameTitle: document.getElementById('renameTitle'),
    renameInput: document.getElementById('renameInput'),
    renameWarn: document.getElementById('renameWarn'),
    renameCancel: document.getElementById('renameCancel'),
    renameConfirm: document.getElementById('renameConfirm'),
    renameBranchBtn: document.getElementById('renameBranchBtn'),
    deleteModal: document.getElementById('deleteModal'),
    deleteTitle: document.getElementById('deleteTitle'),
    deleteDesc: document.getElementById('deleteDesc'),
    deleteCancel: document.getElementById('deleteCancel'),
    deleteConfirm: document.getElementById('deleteConfirm'),
    createRepoModal: document.getElementById('createRepoModal'),
    createRepoNameInput: document.getElementById('createRepoNameInput'),
    createRepoDescInput: document.getElementById('createRepoDescInput'),
    createRepoPrivate: document.getElementById('createRepoPrivate'),
    repoNameError: document.getElementById('repoNameError'),
    createRepoCancel: document.getElementById('createRepoCancel'),
    createRepoConfirm: document.getElementById('createRepoConfirm'),
    createFolderModal: document.getElementById('createFolderModal'),
    createFolderInput: document.getElementById('createFolderInput'),
    createFolderCancel: document.getElementById('createFolderCancel'),
    createFolderConfirm: document.getElementById('createFolderConfirm'),
    createFileModal: document.getElementById('createFileModal'),
    createFileNameInput: document.getElementById('createFileNameInput'),
    createFileContentInput: document.getElementById('createFileContentInput'),
    createFileCancel: document.getElementById('createFileCancel'),
    createFileConfirm: document.getElementById('createFileConfirm'),
    createBranchModal: document.getElementById('createBranchModal'),
    createBranchNameInput: document.getElementById('createBranchNameInput'),
    createBranchCancel: document.getElementById('createBranchCancel'),
    createBranchConfirm: document.getElementById('createBranchConfirm'),
    deleteBranchBtn: document.getElementById('deleteBranchBtn'),
    searchToggleBtn: document.getElementById('searchToggleBtn'),
    sortToggleBtn: document.getElementById('sortToggleBtn'),
    customSortDropdown: document.getElementById('customSortDropdown'),
    avatarContainer: document.getElementById('avatarContainer'),
    avatarUploadInput: document.getElementById('avatarUploadInput'),
    userAvatar: document.getElementById('userAvatar'),
    userAvatarPlaceholder: document.getElementById('userAvatarPlaceholder'),
    multiSelectToggleBtn: document.getElementById('multiSelectToggleBtn'),
    multiSelectBar: document.getElementById('multi-select-bar'),
    cancelSelectBtn: document.getElementById('cancel-select-btn'),
    selectAllBtn: document.getElementById('select-all-btn'),
    invertSelectBtn: document.getElementById('invert-select-btn'),
    downloadBtn: document.getElementById('download-btn'),
    deleteBtn: document.getElementById('delete-btn'),
    selectedCountSpan: document.getElementById('selected-count'),
    menuContextMenuSettings: document.getElementById('menuContextMenuSettings'),
    contextMenuSettingsModal: document.getElementById('contextMenuSettingsModal'),
    contextMenuSettingsCloseBtn: document.getElementById('contextMenuSettingsCloseBtn'),
    contextMenuSettingsContent: document.getElementById('contextMenuSettingsContent'),
    currentRepo: document.getElementById('currentRepo'),
    apiStatusPanel: document.getElementById('apiStatusPanel'),
    apiStatusOverlay: document.getElementById('apiStatusOverlay'),
    apiStatusContent: document.getElementById('apiStatusContent'),
    closeApiStatusPanel: document.getElementById('closeApiStatusPanel'),
    refreshApiStatusBtn: document.getElementById('refreshApiStatusBtn'),
    revertEditBtn: document.getElementById('revertEditBtn'),
    editorScaleHint: document.getElementById('editorScaleHint'),
    searchInFileBtn: document.getElementById('searchInFileBtn'),
editorSearchPanel: document.getElementById('editorSearchPanel'),
editorSearchInput: document.getElementById('editorSearchInput'),
editorSearchMatchCount: document.getElementById('editorSearchMatchCount'),
editorSearchPrevBtn: document.getElementById('editorSearchPrevBtn'),
editorSearchNextBtn: document.getElementById('editorSearchNextBtn'),
editorSearchCloseBtn: document.getElementById('editorSearchCloseBtn'),
    manageAccountsBtn: document.getElementById('manageAccountsBtn'),
    menuSwitchAccount: document.getElementById('menuSwitchAccount'),
    accountManagerModal: document.getElementById('accountManagerModal'),
    closeAccountManagerModalBtn: document.getElementById('closeAccountManagerModalBtn'),
    accountListContainer: document.getElementById('accountListContainer'),
    accountListEmpty: document.getElementById('accountListEmpty'),
    showAddAccountModalBtn: document.getElementById('showAddAccountModalBtn'),
    addEditAccountModal: document.getElementById('addEditAccountModal'),
    addEditAccountTitle: document.getElementById('addEditAccountTitle'),
    closeAddEditAccountModalBtn: document.getElementById('closeAddEditAccountModalBtn'),
    accountNameInput: document.getElementById('accountNameInput'),
    accountTokenInput: document.getElementById('accountTokenInput'),
    addEditAccountError: document.getElementById('addEditAccountError'),
    addEditAccountCancelBtn: document.getElementById('addEditAccountCancelBtn'),
    addEditAccountSaveBtn: document.getElementById('addEditAccountSaveBtn'),
    menuThemeToggle: document.getElementById('menuThemeToggle'),
    publishManagerModal: document.getElementById('publishManagerModal'),
    closePublishManagerBtn: document.getElementById('closePublishManagerBtn'),
    publishManageList: document.getElementById('publishManageList'),
    officialConfigTabBtn: document.getElementById('officialConfigTabBtn'),
    showPublishHelpBtn: document.getElementById('showPublishHelpBtn'),
    publishHelpModal: document.getElementById('publishHelpModal'),
    closePublishHelpBtn: document.getElementById('closePublishHelpBtn')
    
};





function handleBackPress() {
    if (uiStateStack.length > 0) {
        const closeFunction = uiStateStack.pop();
        if (typeof closeFunction === 'function') {
            closeFunction();
        }
        history.pushState(history.state, '', window.location.href);
        return true;
    }
    return false;
}







const themeManager = {
    apply(theme) {
        const themeToggle = document.getElementById('menuThemeToggle');
        if (!themeToggle) return;
        const icon = themeToggle.querySelector('i');
        
        document.documentElement.classList.remove('light-theme-loading');

        const oldThemeMeta = document.querySelector('meta[name="theme-color"]');
        if (oldThemeMeta) {
            oldThemeMeta.remove();
        }
        
        const oldAppleMeta = document.querySelector('meta[name="apple-mobile-web-app-status-bar-style"]');
        if (oldAppleMeta) {
            oldAppleMeta.remove();
        }

        const newThemeMeta = document.createElement('meta');
        newThemeMeta.setAttribute('name', 'theme-color');
        
        const newAppleMeta = document.createElement('meta');
        newAppleMeta.setAttribute('name', 'apple-mobile-web-app-status-bar-style');

        if (theme === 'light') {
            document.body.classList.add('light-theme');
            if (icon) icon.className = 'fa-regular fa-moon';
            newThemeMeta.setAttribute('content', '#f0f2f5');
            newAppleMeta.setAttribute('content', 'default');
        } else {
            document.body.classList.remove('light-theme');
            if (icon) icon.className = 'fa-regular fa-cloud';
            newThemeMeta.setAttribute('content', '#04091a');
            newAppleMeta.setAttribute('content', 'black-translucent');
        }
        
        setTimeout(() => {
            document.head.appendChild(newThemeMeta);
            document.head.appendChild(newAppleMeta);
        }, 0);
    },
    toggle() {
        const currentTheme = document.body.classList.contains('light-theme') ? 'light' : 'dark';
        const newTheme = currentTheme === 'light' ? 'dark' : 'light';
        this.apply(newTheme);
        try {
            localStorage.setItem('app_theme', newTheme);
        } catch (e) {
            console.error('无法保存主题设置:', e);
        }
    },
    init() {
        try {
            const savedTheme = localStorage.getItem('app_theme') || 'light';
            this.apply(savedTheme);
        } catch (e) {
            console.error('无法加载主题设置:', e);
            this.apply('light');
        }
    }
};






function loadSearchHistory() {
    try {
        const history = JSON.parse(localStorage.getItem('search_history') || '[]');
        state.searchHistory = Array.isArray(history) ? history : [];
    } catch (e) {
        state.searchHistory = [];
    }
}

function saveSearchHistory() {
    localStorage.setItem('search_history', JSON.stringify(state.searchHistory));
}

function addSearchToHistory(query) {
    if (!query) return;
    const trimmedQuery = query.trim();
    if (!trimmedQuery) return;
    
    const existingIndex = state.searchHistory.indexOf(trimmedQuery);
    if (existingIndex > -1) {
        state.searchHistory.splice(existingIndex, 1);
    }
    state.searchHistory.unshift(trimmedQuery);
    state.searchHistory = state.searchHistory.slice(0, 10);
    saveSearchHistory();
}

function clearSearchHistory() {
    state.searchHistory = [];
    saveSearchHistory();
    renderSearchHistory();
}

function renderSearchHistory() {
    const container = document.getElementById('globalSearchHistoryContainer');
    container.innerHTML = '';

    if (state.searchHistory.length === 0) {
        container.classList.add('hidden');
        return;
    }

    state.searchHistory.forEach(query => {
        const item = document.createElement('div');
        item.className = 'history-item';
        item.textContent = query;

        item.addEventListener('mousedown', (e) => {
            e.preventDefault();
            const searchInput = document.getElementById('globalSearchInput');
            searchInput.value = query;
            handleGlobalSearch(query);
            container.classList.add('hidden');
        });
        container.appendChild(item);
    });

    const footer = document.createElement('div');
    footer.className = 'search-history-footer';
    
    const clearBtn = document.createElement('button');
    clearBtn.id = 'clearSearchHistoryBtn';
    clearBtn.textContent = '清空搜索历史';
    
    clearBtn.addEventListener('mousedown', (e) => {
        e.preventDefault();
        clearSearchHistory();
    });
    
    footer.appendChild(clearBtn);
    container.appendChild(footer);

    container.classList.remove('hidden');
}



function formatNumber(num) {
    if (num === null || num === undefined) return '---';
    if (num < 1000) return num.toString();
    if (num < 1000000) return (num / 1000).toFixed(1).replace(/\.0$/, '') + 'k';
    return (num / 1000000).toFixed(1).replace(/\.0$/, '') + 'M';
}

async function showRepoDetailsModal(repo) {
    if (!repo) return;

    const modalAvatar = document.getElementById('repoDetailsAvatar');
    
    modalAvatar.src = '';
    modalAvatar.classList.remove('loaded');
    modalAvatar._targetUrl = null; 

    const listItemAvatar = document.querySelector(`.file-item[data-repo-id="${repo.id}"] .repo-avatar`);

    if (listItemAvatar && listItemAvatar.src && listItemAvatar.classList.contains('loaded')) {
        modalAvatar.src = listItemAvatar.src;
        modalAvatar.classList.add('loaded');
    } else {
        AvatarManager.loadAvatar(modalAvatar, repo.owner.avatar_url, repo.owner.login);
    }

    document.getElementById('repoDetailsName').textContent = repo.name;
    document.getElementById('repoDetailsOwner').textContent = repo.owner.login;
    document.getElementById('repoDetailsStars').innerHTML = `<i class="fa-regular fa-star"></i> ${formatNumber(repo.stargazers_count)}`;
    document.getElementById('repoDetailsForks').innerHTML = `<i class="fa-solid fa-code-fork"></i> ${formatNumber(repo.forks_count)}`;
    document.getElementById('repoDetailsWatchers').innerHTML = `<i class="fa-regular fa-eye"></i> ${formatNumber(repo.watchers_count)}`;

    const descriptionEl = document.getElementById('repoDetailsDescription');
    const cacheKey = `readme_summary_${repo.full_name}`;
    let hasRenderedReadme = false;

    descriptionEl.innerHTML = '<div class="loading-spinner small"><div class="spinner-small"></div></div>';

    try {
        const cachedReadme = await SimpleDB.get(cacheKey);
        if (cachedReadme) {
            descriptionEl.innerHTML = cachedReadme;
            hasRenderedReadme = true;
        }
    } catch (e) {}

    if (!hasRenderedReadme) {
        descriptionEl.textContent = repo.description || '暂无描述';
    }

    const topicsContainer = document.getElementById('repoDetailsTopics');
    topicsContainer.innerHTML = '';
    if (repo.topics && repo.topics.length > 0) {
        repo.topics.forEach(topic => {
            const tag = document.createElement('span');
            tag.className = 'topic-tag';
            tag.textContent = topic;
            topicsContainer.appendChild(tag);
        });
    }

    document.getElementById('repoDetailsLanguage').innerHTML = `<strong>语言：</strong> ${repo.language || '未知'}`;
    document.getElementById('repoDetailsLicense').innerHTML = `<strong>许可证：</strong> ${repo.license ? repo.license.name : '无'}`;
    document.getElementById('repoDetailsDates').textContent = `创建于 ${formatRelativeTime(new Date(repo.created_at))} · 更新于 ${formatRelativeTime(new Date(repo.updated_at))}`;

    const goToBtn = document.getElementById('repoDetailsGoToBtn');
    goToBtn.onclick = (e) => {
        e.stopPropagation();
        hideRepoDetailsModal();
        navigateToRepo(repo, repo.default_branch);
    };

    el.repoDetailsModal.classList.remove('hidden');
    uiStateStack.push(hideRepoDetailsModal);

    if (!hasRenderedReadme) {
        fetch(`https://api.github.com/repos/${repo.full_name}/readme`, {
            headers: { 'Authorization': `token ${state.token}`, 'Accept': 'application/vnd.github.v3.html' }
        }).then(res => {
            if (res.ok) return res.text();
            throw new Error('No README');
        }).then(html => {
            const cleanHtml = html.replace(/<script\b[^>]*>([\s\S]*?)<\/script>/gim, "").replace(/<style\b[^>]*>([\s\S]*?)<\/style>/gim, "");
            descriptionEl.innerHTML = cleanHtml;
            SimpleDB.set(cacheKey, cleanHtml);
        }).catch(() => {
            descriptionEl.textContent = repo.description || '暂无描述';
        });
    }
}




function hideRepoDetailsModal() {
    el.repoDetailsModal.classList.add('hidden');
    const index = uiStateStack.indexOf(hideRepoDetailsModal);
    if (index > -1) uiStateStack.splice(index, 1);
}


async function preloadReadmesForCurrentPage(repos) {
    if (!repos || repos.length === 0) return;
    if (window.isReadmePreloading) return;
    window.isReadmePreloading = true;
    const queue = [...repos];
    const processQueue = async () => {
        if (queue.length === 0) {
            window.isReadmePreloading = false;
            return;
        }
        const repo = queue.shift();
        const cacheKey = `readme_summary_${repo.full_name}`;
        try {
            const cached = await SimpleDB.get(cacheKey);
            if (!cached) {
                const res = await fetch(`https://api.github.com/repos/${repo.full_name}/readme`, {
                    headers: { 'Authorization': `token ${state.token}`, 'Accept': 'application/vnd.github.v3.html' },
                    signal: AbortSignal.timeout(5000) 
                });
                if (res.ok) {
                    const html = await res.text();
                    const cleanHtml = html.replace(/<script\b[^>]*>([\s\S]*?)<\/script>/gim, "").replace(/<style\b[^>]*>([\s\S]*?)<\/style>/gim, "");
                    await SimpleDB.set(cacheKey, cleanHtml);
                }
            }
        } catch (e) {}
        if ('requestIdleCallback' in window) {
            requestIdleCallback(processQueue);
        } else {
            setTimeout(processQueue, 200);
        }
    };
    processQueue();
}





function initializeActiveToken() {
    state.token = null; 
    if (state.activeAccountId && state.accounts.length > 0) {
        const activeAccount = state.accounts.find(acc => acc.id === state.activeAccountId);
        if (activeAccount) {
            state.token = activeAccount.token;
        } else {

            state.activeAccountId = null;
            localStorage.removeItem('active_github_account_id');
        }
    }
}



function showAccountManagerModal() {
    renderAccountList();
    el.accountManagerModal.classList.remove('hidden');
    uiStateStack.push(closeAccountManagerModal);
}

function closeAccountManagerModal() {
    el.accountManagerModal.classList.add('hidden');
    const index = uiStateStack.indexOf(closeAccountManagerModal);
    if (index > -1) uiStateStack.splice(index, 1);
}


function showAddEditAccountModal(accountId = null) {
    editingAccountId = accountId;
    const title = el.addEditAccountTitle.querySelector('.modal-title-text');
    const saveBtn = el.addEditAccountSaveBtn;

    el.addEditAccountError.style.display = 'none';
    saveBtn.disabled = true;

    if (accountId) { 
        
        const account = state.accounts.find(acc => acc.id === accountId);
        title.textContent = '编辑账号'; 
        el.accountNameInput.style.display = 'block'; 
        el.accountNameInput.value = account.name;
        el.accountTokenInput.value = account.token; 

    } else { 
        
        title.textContent = '添加新账号';
        el.accountNameInput.style.display = 'none'; 
        el.accountNameInput.value = '';
        el.accountTokenInput.value = '';
    }
    
    el.addEditAccountModal.classList.remove('hidden');
    uiStateStack.push(closeAddEditAccountModal);
}

function closeAddEditAccountModal() {
    el.addEditAccountModal.classList.add('hidden');
    const index = uiStateStack.indexOf(closeAddEditAccountModal);
    if (index > -1) uiStateStack.splice(index, 1);
}


async function handleSaveAccount() {
    const name = el.accountNameInput.value.trim(); 
    const token = el.accountTokenInput.value.trim();
    const saveBtn = el.addEditAccountSaveBtn;
    const spinner = saveBtn.querySelector('i');
    
    saveBtn.disabled = true;
    spinner.classList.remove('hidden');
    el.addEditAccountError.style.display = 'none';

    try {
        if (editingAccountId) {
            
            const account = state.accounts.find(acc => acc.id === editingAccountId);
            
            if (token !== account.token) {
                
                const res = await fetch('https://api.github.com/user', { headers: { Authorization: `token ${token}` } });
                if (!res.ok) throw new Error('新令牌无效或已过期');
                
                
                account.token = token;
            }
            
            account.name = name; 
            saveAccounts();

            if (state.activeAccountId === editingAccountId) {
                initializeActiveToken();
            }

            renderAccountList();
            closeAddEditAccountModal();
            showToast('账号信息已更新');

        } else {
            
            const res = await fetch('https://api.github.com/user', { headers: { Authorization: `token ${token}` } });
            if (!res.ok) throw new Error('令牌无效或已过期');
            
            const userData = await res.json(); 
            const githubUsername = userData.login; 

            const newAccount = {
                id: `gh_${Date.now()}`,
                name: githubUsername, 
                token: token
            };
            state.accounts.push(newAccount);
            saveAccounts();
            renderAccountList();
            closeAddEditAccountModal();
            showToast(`账号 "${githubUsername}" 添加成功`);
        }
    } catch (error) {
        el.addEditAccountError.textContent = error.message;
        el.addEditAccountError.style.display = 'block';
    } finally {
        saveBtn.disabled = false;
        spinner.classList.add('hidden');
    }
}

function getFileIcon(filename) {
    const ext = filename.split('.').pop().toLowerCase();
    const icons = {
    js: 'fa-solid fa-code', html: 'fa-brands fa-html5', css: 'fa-brands fa-css3', php: 'fa-regular fa-file-code', py: 'fa-regular fa-file-code',
    java: 'fa-regular fa-file-code', rb: 'fa-regular fa-file-code', cpp: 'fa-regular fa-file-code', c: 'fa-regular fa-file-code',
    cs: 'fa-regular fa-file-code', swift: 'fa-regular fa-file-code', go: 'fa-regular fa-file-code', xml: 'fa-regular fa-file-code',
    json: 'fa-regular fa-file-code', yml: 'fa-regular fa-file-code', yaml: 'fa-regular fa-file-code', sql: 'fa-solid fa-database',
    csv: 'fa-regular fa-file-excel', ini: 'fa-solid fa-gear', conf: 'fa-solid fa-gear', log: 'fa-regular fa-file-lines',
    md: 'fa-regular fa-file-lines', txt: 'fa-regular fa-file-lines', rtf: 'fa-regular fa-file-word', pdf: 'fa-regular fa-file-pdf',
    doc: 'fa-regular fa-file-word', docx: 'fa-regular fa-file-word', xls: 'fa-regular fa-file-excel', xlsx: 'fa-regular fa-file-excel',
    ppt: 'fa-regular fa-file-powerpoint', pptx: 'fa-regular fa-file-powerpoint', png: 'fa-regular fa-file-image',
    jpg: 'fa-regular fa-file-image', jpeg: 'fa-regular fa-file-image', gif: 'fa-regular fa-file-image', svg: 'fa-regular fa-file-image',
    bmp: 'fa-regular fa-file-image', ico: 'fa-regular fa-file-image', webp: 'fa-regular fa-file-image', mp3: 'fa-regular fa-file-audio',
    wav: 'fa-regular fa-file-audio', ogg: 'fa-regular fa-file-audio', flac: 'fa-regular fa-file-audio', m4a: 'fa-regular fa-file-audio',
    mp4: 'fa-regular fa-file-video', webm: 'fa-regular fa-file-video', mov: 'fa-regular fa-file-video', mkv: 'fa-regular fa-file-video',
    avi: 'fa-regular fa-file-video', flv: 'fa-regular fa-file-video', zip: 'fa-regular fa-file-zipper', rar: 'fa-regular fa-file-zipper',
    '7z': 'fa-regular fa-file-zipper', tar: 'fa-regular fa-file-zipper', gz: 'fa-regular fa-file-zipper', git: 'fa-brands fa-git-alt',
    apk: 'fa-brands fa-android', exe: 'fa-solid fa-gears', dmg: 'fa-brands fa-apple', ttf: 'fa-solid fa-font', otf: 'fa-solid fa-font',
    woff: 'fa-solid fa-font', woff2: 'fa-solid fa-font'
}
    return icons[ext] || 'fa-file';
}


function getFileCategory(file) {
    if (file.type === 'dir') {
        return 'folder';
    }
    const ext = file.name.split('.').pop().toLowerCase();
    if (IMAGE_EXTS.includes(ext)) {
        return 'image';
    }
    if (VIDEO_EXTS.includes(ext)) {
        return 'video';
    }
    if (AUDIO_EXTS.includes(ext)) {
        return 'audio';
    }
    const archiveExts = ['zip', 'rar', '7z', 'tar', 'gz'];
    if (archiveExts.includes(ext)) {
        return 'archive';
    }
    const docExts = ['pdf', 'doc', 'docx', 'xls', 'xlsx', 'ppt', 'pptx', 'txt', 'md'];
    if (docExts.includes(ext)) {
        return 'document';
    }
    return 'z_other';
}

function formatSize(bytes) {
    if (!bytes && bytes !== 0) return '';
    const k = 1024;
    const sizes = ['B', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.max(0, Math.log(bytes || 1) / Math.log(k)));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

function formatRelativeTime(date) {
    const diffMs = new Date() - date;
    const diffMins = Math.floor(diffMs / 60000);
    const diffHours = Math.floor(diffMins / 60);
    const diffDays = Math.floor(diffHours / 24);
    if (diffMins < 1) return '刚刚';
    if (diffMins < 60) return `${diffMins}分钟前`;
    if (diffHours < 24) return `${diffHours}小时前`;
    if (diffDays < 30) return `${diffDays}天前`;
    return date.toLocaleDateString();
}

function escapeHtml(unsafe) {
    return unsafe.replace(/&/g, "&amp;").replace(/</g, "&lt;")
        .replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
}

function getDomainFromUrl(url) {
    try {
        const urlObj = new URL(url.startsWith('http') ? url : `https://${url}`);
        return urlObj.hostname;
    } catch (e) {
        return '';
    }
}

function getProxiedUrl(originalUrl) {
    try {
        if (!originalUrl || !originalUrl.startsWith('http')) return originalUrl;
        
        const enable = state.proxyGlobalEnable;
        if (!enable) return originalUrl;

        const proxies = state.proxies;
        const index = state.activeProxyIndex;

        if (proxies.length > 0 && index >= 0 && index < proxies.length) {
            let proxyUrl = proxies[index].url;
            if (proxyUrl) {
                if (!proxyUrl.endsWith('/')) proxyUrl += '/';
                return proxyUrl + originalUrl;
            }
        }
    } catch (e) {}
    return originalUrl;
}

function applyFiltersAndSort() {
    let arr = Array.isArray(state.files) ? [...state.files] : [];
    const q = (state.searchQuery || '').toLowerCase();
    
    if (q) {
        arr = arr.filter(f => (f.name || '').toLowerCase().includes(q));
    }

    const getNaturalSort = (a, b) => {
        return a.name.localeCompare(b.name, undefined, { numeric: true, sensitivity: 'base' });
    };

    const directorySorter = (a, b) => {
        if (a.type === b.type) return 0;
        const isDirsFirst = state.directorySortPriority !== 'files_first';
        if (isDirsFirst) {
            return a.type === 'dir' ? -1 : 1;
        }
        return a.type === 'file' ? -1 : 1;
    };

    const getTypeWeight = (file) => {
        const cat = getFileCategory(file);
        const weights = {
            'image': 1,
            'video': 2,
            'audio': 3,
            'document': 4,
            'archive': 5,
            'folder': 0,
            'code': 6,
            'z_other': 99
        };
        return weights[cat] || 99;
    };

    const by = state.sortBy;

    const sorters = {
        name_asc: (a, b) => {
            const dirCompare = directorySorter(a, b);
            if (dirCompare !== 0) return dirCompare;
            return getNaturalSort(a, b);
        },
        name_desc: (a, b) => {
            const dirCompare = directorySorter(a, b);
            if (dirCompare !== 0) return dirCompare;
            return getNaturalSort(b, a);
        },
        size_desc: (a, b) => {
            const dirCompare = directorySorter(a, b);
            if (dirCompare !== 0) return dirCompare;
            const sizeA = a.size || 0;
            const sizeB = b.size || 0;
            if (sizeA !== sizeB) return sizeB - sizeA;
            return getNaturalSort(a, b);
        },
        size_asc: (a, b) => {
            const dirCompare = directorySorter(a, b);
            if (dirCompare !== 0) return dirCompare;
            const sizeA = a.size || 0;
            const sizeB = b.size || 0;
            if (sizeA !== sizeB) return sizeA - sizeB;
            return getNaturalSort(a, b);
        },
        type_name_asc: (a, b) => {
            const dirCompare = directorySorter(a, b);
            if (dirCompare !== 0) return dirCompare;

            const weightA = getTypeWeight(a);
            const weightB = getTypeWeight(b);
            if (weightA !== weightB) {
                return weightA - weightB;
            }

            if (a.last_modified && b.last_modified) {
                const dateA = new Date(a.last_modified).getTime();
                const dateB = new Date(b.last_modified).getTime();
                if (dateA !== dateB) {
                    return dateB - dateA;
                }
            }

            return getNaturalSort(a, b);
        }
    };

    const sortFn = sorters[by] || sorters.type_name_asc;
    arr.sort(sortFn);
    
    state.displayFiles = arr;
}




let editingAccountId = null; 

function saveAccounts() {
    localStorage.setItem('github_accounts', JSON.stringify(state.accounts));
}

function setActiveAccount(accountId) {
    state.activeAccountId = accountId;
    localStorage.setItem('active_github_account_id', accountId);
    initializeActiveToken(); 
}

function renderAccountList() {
    const container = el.accountListContainer;
    container.innerHTML = '';

    if (state.accounts.length === 0) {
        el.accountListEmpty.classList.remove('hidden');
        return;
    }
    el.accountListEmpty.classList.add('hidden');

    state.accounts.forEach(account => {
        const item = document.createElement('div');
        item.className = 'account-item';
        item.dataset.id = account.id;
        if (account.id === state.activeAccountId) {
            item.classList.add('active');
        }

        item.innerHTML = `
            <span class="account-name">${escapeHtml(account.name)}</span>
            <div class="account-actions">
                <button class="btn-icon-sm edit-account-btn" title="编辑名称"><i class="fa fa-pencil"></i></button>
                <button class="btn-icon-sm delete-account-btn danger" title="删除账号"><i class="fa-regular fa-trash-can"></i></button>
            </div>
        `;

        
        item.addEventListener('click', () => {
    if (el.app.classList.contains('hidden')) {
        const selectedToken = state.accounts.find(acc => acc.id === account.id).token;
        if (selectedToken) {
            el.tokenInput.value = selectedToken;
            showToast(`已选择账号: ${account.name}，正在自动登录...`);
            closeAccountManagerModal();
            el.authBtn.click();
        }
    } else {
        if (account.id === state.activeAccountId) {
            closeAccountManagerModal();
            return;
        }
        switchAccount(account.id);
    }
});
        
        item.querySelector('.edit-account-btn').addEventListener('click', (e) => {
            e.stopPropagation();
            showAddEditAccountModal(account.id);
        });

        item.querySelector('.delete-account-btn').addEventListener('click', (e) => {
            e.stopPropagation();
            showDeleteModal(null, false, '确认删除账号', `确定要删除账号 "${escapeHtml(account.name)}" 吗？`, async () => {
                state.accounts = state.accounts.filter(acc => acc.id !== account.id);
                if (state.activeAccountId === account.id) {
                    setActiveAccount(null); 
                }
                saveAccounts();
                renderAccountList();
                showToast('账号已删除');
            });
        });

        container.appendChild(item);
    });
}

async function switchAccount(accountId) {
    closeAccountManagerModal();
    hideMainMenuPopup();
    el.mainLoader.classList.remove('hidden');
    showToast('正在切换账号...');

    setActiveAccount(accountId);

    state.currentRepo = null;
    state.repos = [];
    state.starredRepos = [];
    state.myRepos = [];
    state.fileCache.clear();
    state.currentView = 'own_repos';

    const viewStarredBtn = document.getElementById('viewStarredBtn');
    if (viewStarredBtn) {
        const icon = viewStarredBtn.querySelector('i');
        icon.className = 'fa-regular fa-star';
        viewStarredBtn.title = '查看星标仓库';
    }

    try {
        state.shouldAnimateList = true;
        
        await Promise.all([
            fetchUserInfo(),
            fetchRepos(true, false),
            fetchStarredRepos(true, false)
        ]);
        
        state.myRepos = [...state.repos];
        showRepoListView();
        renderRepoList();

        const res = await fetch('https://api.github.com/user', { headers: { Authorization: `token ${state.token}` } });
        if (res.ok) {
            const scopesHeader = res.headers.get('x-oauth-scopes') || '';
            if (!scopesHeader.includes('repo')) {
                showToast('此令牌无权限，大部分功能将无法使用。', 'error', 5000);
            }
        }

    } catch (error) {
        showToast(`切换失败: ${error.message}`, 'error');
        showAuth();
    } finally {
        el.mainLoader.classList.add('hidden');
        renderPublishManagerLists();
    }
}

function updateFileListViewMode() {
    if (!el.fileList) return;
    if (state.viewMode === 'grid') {
        el.fileList.classList.add('grid');
        el.viewToggleBtn && el.viewToggleBtn.classList.add('active');
        if (el.viewToggleBtn) {
            el.viewToggleBtn.title = '切换为列表视图';
            el.viewToggleBtn.innerHTML = '<i class="fa fa-align-justify"></i>';
        }
    } else {
        el.fileList.classList.remove('grid');
        el.viewToggleBtn && el.viewToggleBtn.classList.remove('active');
        if (el.viewToggleBtn) {
            el.viewToggleBtn.title = '切换为网格视图';
            el.viewToggleBtn.innerHTML = '<i class="fa-regular fa-chart-bar"></i>';
        }
    }
}



function updateAllProxySwitchUI() {
    const isEnabled = !!state.proxyGlobalEnable;
    const currentProxy = state.proxies[state.activeProxyIndex];
    const title = isEnabled && currentProxy ? `代理已开启 (${currentProxy.url})` : '代理已关闭';
    if (el.proxyQuickToggle) {
        el.proxyQuickToggle.classList.toggle('active', isEnabled);
        el.proxyQuickToggle.title = title;
    }
    if (el.proxyGlobalEnableToggle) {
        el.proxyGlobalEnableToggle.checked = isEnabled;
        const label = el.proxyGlobalEnableToggle.parentElement;
        if (label) {
            label.title = isEnabled ? '点击关闭全局代理' : '点击开启全局代理';
        }
    }
}

function updateProxyUI() {
    updateAllProxySwitchUI();
}

function preloadRepoImages() {
    if (!state.repoTreeCache || !state.currentRepo || !state.currentBranch) return;
    
    if (!state.loadedImageMap) state.loadedImageMap = new Map();

    const [owner, repo] = state.currentRepo.split('/');
    const currentBranchRef = state.currentBranch;
    
    const images = state.repoTreeCache.filter(item => {
        if (item.type !== 'blob') return false;
        const ext = item.path.split('.').pop().toLowerCase();
        return IMAGE_EXTS.includes(ext);
    });

    if (images.length === 0) return;

    let index = 0;
    const batchSize = 6;

    const runPreload = () => {
        if (state.currentRepo !== `${owner}/${repo}`) return;

        for (let i = 0; i < batchSize && index < images.length; i++) {
            const item = images[index++];
            
            // 如果这个路径已经在 Map 里了（说明之前某个代理已经加载成功），跳过预加载
            if (state.loadedImageMap.has(item.path)) continue;

            const encodedPath = item.path.split('/').map(p => encodeURIComponent(p)).join('/');
            const rawUrl = `https://raw.githubusercontent.com/${owner}/${repo}/${currentBranchRef}/${encodedPath}`;
            
            // 获取最新代理URL
            const proxiedUrl = getProxiedUrl(rawUrl);
            
            const img = new Image();
            img.onload = () => {
                // 加载成功，存入 Map
                state.loadedImageMap.set(item.path, proxiedUrl);
                
                // 尝试刷新UI上的 loading 状态
                const thumbContainer = document.querySelector(`.file-item[data-file-path="${CSS.escape(item.path)}"] .file-thumbnail-container.loading`);
                if (thumbContainer) {
                    loadThumbnailImage(thumbContainer);
                }
            };
            img.src = proxiedUrl;
        }

        if (index < images.length) {
            if ('requestIdleCallback' in window) {
                requestIdleCallback(runPreload);
            } else {
                setTimeout(runPreload, 200);
            }
        }
    };
    runPreload();
}

function setActiveProxy(index, showNotification = true) {
    if (index < 0 || index >= state.proxies.length) return;
    
    const previousIndex = state.activeProxyIndex;
    state.proxyGlobalEnable = true;
    state.activeProxyIndex = index;
    
    saveProxyConfig();
    renderProxyList();
    
    if (showNotification && previousIndex !== index) {
        showToast(`已切换全局代理`);
    }

    if (state.currentRepo) {
        state.shouldAnimateList = false;
        renderFileList();
        preloadRepoImages();
    }
}

async function setProxyGlobalState(isEnabled, shouldRefreshFiles = false) {
    if (state.proxyGlobalEnable === isEnabled) {
        return;
    }
    state.proxyGlobalEnable = isEnabled;
    localStorage.setItem('proxy_global_enable', JSON.stringify(isEnabled));
    updateAllProxySwitchUI();
    showToast(isEnabled ? '全局代理已开启' : '全局代理已关闭');
    
    if (shouldRefreshFiles && state.currentRepo && !el.fileList.classList.contains('hidden')) {
        renderFileList();
        if (isEnabled) {
            preloadRepoImages();
        }
    }
}

function toggleView(showRepoList) {
    const viewStarredBtn = document.getElementById('viewStarredBtn');
    const globalSearchToggleBtn = document.getElementById('globalSearchToggleBtn');
    const globalSearchContainer = document.getElementById('globalSearchContainer');

    if (showRepoList) {
        el.main.classList.remove('has-toolbar');
        el.repoList.classList.remove('hidden');
        el.fileList.classList.add('hidden');
        el.toolbar.classList.add('hidden');
        el.pathNavContainer.classList.add('hidden');
        el.branchSwitcherContainer.classList.add('hidden');
        
        if (viewStarredBtn) viewStarredBtn.classList.remove('hidden');
    } else {
        el.main.classList.add('has-toolbar');
        el.repoList.classList.add('hidden');
        el.fileList.classList.remove('hidden');
        el.toolbar.classList.remove('hidden');
        el.pathNavContainer.classList.remove('hidden');
        el.branchSwitcherContainer.classList.remove('hidden');
        
        updateFileListViewMode();
        if (viewStarredBtn) viewStarredBtn.classList.remove('hidden');
        
        if (globalSearchToggleBtn && globalSearchToggleBtn.classList.contains('active')) {
            globalSearchToggleBtn.classList.remove('active');
            globalSearchContainer.classList.add('hidden');
        }
    }
}
function showAuth() {
    el.authScreen.classList.remove('hidden');
    el.app.classList.add('hidden');
    document.documentElement.classList.remove('app-visible-loading');
    document.documentElement.classList.add('auth-visible-loading');
}

function showApp() {
    el.authScreen.classList.add('hidden');
    el.app.classList.remove('hidden');
    document.documentElement.classList.remove('auth-visible-loading');
    document.documentElement.classList.add('app-visible-loading');
    document.body.classList.remove('app-visible-loading');
}

function showEditorScaleHintOnce() {
    const hintKey = 'editor_scale_hint_shown';
    try {
        if (localStorage.getItem(hintKey)) {
            return;
        }
        const hintElement = el.editorScaleHint;
        if (!hintElement) {
            return;
        }
        
        hintElement.classList.remove('hidden');
        
        setTimeout(() => {
            hintElement.style.transition = 'opacity 0.5s ease-out';
            hintElement.style.opacity = '0';
            setTimeout(() => {
                hintElement.classList.add('hidden');
                hintElement.style.opacity = '';
                hintElement.style.transition = '';
            }, 500);
        }, 3000);

        localStorage.setItem(hintKey, 'true');
    } catch (e) {
        console.error("Could not show editor scale hint:", e);
    }
}


let toastTimer = null;

function showToast(message, type = 'info', duration = 2500) {
    const toastEl = document.getElementById('toast');
    if (!toastEl) return;

    if (toastTimer) {
        clearTimeout(toastTimer);
        toastTimer = null;
    }

    let iconHtml = '';
    if (type === 'success') iconHtml = '<i class="fa-solid fa-circle-check" style="color:#34d399"></i>';
    else if (type === 'error') iconHtml = '<i class="fa-solid fa-circle-xmark" style="color:#f87171"></i>';
    else if (type === 'loading') iconHtml = '<i class="fa fa-spinner fa-spin"></i>';
    else iconHtml = '<i class="fa-solid fa-circle-info" style="color:#60a5fa"></i>';

    toastEl.innerHTML = `${iconHtml}<span>${message}</span>`;
    
    if (!toastEl.classList.contains('show')) {
        toastEl.className = `show toast-${type}`;
        void toastEl.offsetWidth; 
    } else {
        toastEl.className = `show toast-${type}`;
    }

    if (duration > 0) {
        toastTimer = setTimeout(() => {
            hideToast();
        }, duration);
    }
}

function hideToast() {
    const toastEl = document.getElementById('toast');
    if (toastEl) {
        toastEl.classList.remove('show');
        if (toastTimer) {
            clearTimeout(toastTimer);
            toastTimer = null;
        }
    }
}



function showSaveNotification() {
    el.saveNotification.classList.add('show');
    setTimeout(() => el.saveNotification.classList.remove('show'), 3000);
}

async function fetchUserInfo() {
    try {
        const res = await fetch('https://api.github.com/user', {
            headers: {
                Authorization: `token ${state.token}`,
                'User-Agent': 'Mozilla/5.0'
            }
        });
        if (res.ok) {
            state.user = await res.json();
            localStorage.setItem('cached_user_login', state.user.login);
            updateUserUI();
        }
    } catch (e) {
        console.error("Failed to fetch user info", e);
    }
}






function updateUserUI() {
    el.userName.textContent = state.user ? state.user.login : 'User';
    if (state.user && state.user.avatar_url) {
        const url = state.user.avatar_url;
        const ownerLogin = state.user.login;
        el.userAvatar.src = ''; 
        el.userAvatar.classList.remove('hidden');
        el.userAvatarPlaceholder.classList.add('hidden');
        AvatarManager.loadAvatar(el.userAvatar, url, ownerLogin);
    } else {
        el.userAvatar.classList.add('hidden');
        el.userAvatarPlaceholder.classList.remove('hidden');
    }
}

async function loadAndCacheUserAvatar() {
    const avatarUrl = state.user.avatar_url;
    if (!avatarUrl) return;

    try {
        const blob = await getAvatarFromDB('user_avatar', state.user.login);
        if (blob) {
            const url = URL.createObjectURL(blob);
            state.localAvatar = url;
            el.userAvatar.src = url;
            el.userAvatar.classList.remove('hidden');
            el.userAvatarPlaceholder.classList.add('hidden');
            return;
        }
    } catch (e) {}

    const tempImg = new Image();
    tempImg.crossOrigin = "Anonymous"; 
    tempImg.src = avatarUrl;
    
    tempImg.onload = async () => {
        try {
            const response = await fetch(avatarUrl);
            const blob = await response.blob();
            
            await saveAvatarToDB('user_avatar', blob);
            
            const objectUrl = URL.createObjectURL(blob);
            state.localAvatar = objectUrl;
            
            el.userAvatar.src = objectUrl;
            el.userAvatar.classList.remove('hidden');
            el.userAvatarPlaceholder.classList.add('hidden');
        } catch (e) {
            el.userAvatar.src = avatarUrl;
            el.userAvatar.classList.remove('hidden');
            el.userAvatarPlaceholder.classList.add('hidden');
        }
    };
    
    tempImg.onerror = () => {
        el.userAvatar.classList.add('hidden');
        el.userAvatarPlaceholder.classList.remove('hidden');
    };
}







async function fetchRepos(forceRefresh = false, updateView = true) {
    const cacheKey = 'cached_repos';
    
    if (!forceRefresh) {
        try {
            const cachedData = await SimpleDB.get(cacheKey);
            if (cachedData) {
                state.repos = cachedData;
                state.myRepos = [...state.repos];
                if (updateView) {
                    state.shouldAnimateList = true;
                    renderRepoList(state.repos);
                    showRepoListView();
                }
            }
        } catch (e) {
            console.error(e);
        }
    }

    try {
        const res = await fetch('https://api.github.com/user/repos?per_page=100&sort=updated', {
            headers: { Authorization: `token ${state.token}`, 'User-Agent': 'Mozilla/5.0' },
            cache: 'no-store'
        });
        
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        
        const repos = await res.json();
        const oldJson = JSON.stringify(state.repos || []);
        const newJson = JSON.stringify(repos);
        
        if (oldJson !== newJson) {
            state.repos = repos;
            state.myRepos = [...state.repos];
            await SimpleDB.set(cacheKey, state.repos);
            
            if (updateView) {
                const currentScroll = el.main.scrollTop;
                
                state.shouldAnimateList = false;
                
                renderRepoList();
                showRepoListView();
                
                requestAnimationFrame(() => {
                    el.main.scrollTop = currentScroll;
                });
            }
        }
    } catch (err) {
        if (updateView && (!state.repos || state.repos.length === 0)) {
            showToast(`加载失败: ${err.message}`);
            el.repoList.innerHTML = `<div class="empty-state"><p>加载失败</p></div>`;
        }
    }
}




const AvatarManager = {
    DB_NAME: 'GithubAvatarDB',
    STORE_NAME: 'avatars',
    dbPromise: null,
    
    init() {
        if (!this.dbPromise) {
            this.dbPromise = new Promise((resolve, reject) => {
                const request = indexedDB.open(this.DB_NAME, 1);
                request.onupgradeneeded = (e) => {
                    const db = e.target.result;
                    if (!db.objectStoreNames.contains(this.STORE_NAME)) {
                        db.createObjectStore(this.STORE_NAME, { keyPath: 'key' });
                    }
                };
                request.onsuccess = (e) => resolve(e.target.result);
                request.onerror = (e) => reject(e);
            });
        }
        return this.dbPromise;
    },

    async get(key) {
        const db = await this.init();
        return new Promise((resolve) => {
            const tx = db.transaction(this.STORE_NAME, 'readonly');
            const req = tx.objectStore(this.STORE_NAME).get(key);
            req.onsuccess = () => resolve(req.result);
            req.onerror = () => resolve(null);
        });
    },

    async put(key, blob) {
        const db = await this.init();
        return new Promise((resolve, reject) => {
            const tx = db.transaction(this.STORE_NAME, 'readwrite');
            const record = { key, blob };
            tx.objectStore(this.STORE_NAME).put(record);
            tx.oncomplete = () => resolve(record);
            tx.onerror = (e) => reject(e);
        });
    },

    async loadAvatar(imgElement, url, ownerLogin) {
        if (!url || !imgElement) return;
        
        imgElement._targetUrl = url;
        
        const key = `avatar_${ownerLogin}`;
        
        try {
            const cachedRecord = await this.get(key);
            
            if (imgElement._targetUrl !== url) return;

            if (cachedRecord && cachedRecord.blob) {
                const localUrl = URL.createObjectURL(cachedRecord.blob);
                imgElement.src = localUrl;
                imgElement.classList.add('loaded');
                return;
            }
            
            const res = await fetch(url, { cache: 'no-store' });
            if (!res.ok) throw new Error('Download failed');
            const newBlob = await res.blob();
            
            if (imgElement._targetUrl !== url) return;

            await this.put(key, newBlob);
            
            const newUrl = URL.createObjectURL(newBlob);
            imgElement.src = newUrl;
            imgElement.classList.add('loaded');
            
        } catch (e) {
            if (imgElement._targetUrl === url && !imgElement.classList.contains('loaded')) {
                const parent = imgElement.parentElement;
                if(parent) parent.removeAttribute('data-avatar-url');
            }
        }
    }
};




async function fetchStarredRepos(forceRefresh = false, updateView = true, showMainLoader = true) {
    const cacheKey = 'cached_starred_repos';
    if (!forceRefresh) {
        try {
            const cachedData = await SimpleDB.get(cacheKey);
            if (cachedData) {
                state.starredRepos = cachedData;
                if (updateView) {
                    renderRepoList(state.starredRepos);
                }
            }
        } catch (e) {
            console.error(e);
        }
    }
    if (updateView && showMainLoader && (!state.starredRepos || state.starredRepos.length === 0)) {
        el.repoList.innerHTML = '<div class="loading-spinner"><div class="spinner"></div></div>';
    }
    try {
        let allStarredRepos = [];
        let page = 1;
        const perPage = 100;
        while (true) {
            const res = await fetch(`https://api.github.com/user/starred?per_page=${perPage}&page=${page}`, {
                headers: { Authorization: `token ${state.token}`, 'User-Agent': 'Mozilla/5.0' },
                cache: 'no-store'
            });
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const data = await res.json();
            if (!Array.isArray(data)) break;
            allStarredRepos = allStarredRepos.concat(data);
            if (data.length < perPage) break;
            page++;
        }
        const reposToCache = allStarredRepos.map(repo => ({
            id: repo.id,
            full_name: repo.full_name,
            name: repo.name,
            owner: {
                login: repo.owner.login,
                avatar_url: repo.owner.avatar_url
            },
            description: repo.description,
            private: repo.private,
            size: repo.size,
            updated_at: repo.updated_at,
            default_branch: repo.default_branch,
            has_pages: repo.has_pages,
            html_url: repo.html_url
        }));
        const oldJson = JSON.stringify(state.starredRepos || []);
        const newJson = JSON.stringify(reposToCache);
        if (oldJson !== newJson) {
            state.starredRepos = reposToCache;
            await SimpleDB.set(cacheKey, reposToCache);
            if (updateView) {
                state.starredReposPage = 1;
                renderRepoList(state.starredRepos);
            }
        }
    } catch (err) {
        if (updateView && (!state.starredRepos || state.starredRepos.length === 0)) {
            showToast(err.message, 'error');
            el.repoList.innerHTML = `<div class="empty-state"><i class="fa fa-exclamation-circle"></i><p>${err.message}</p></div>`;
        }
    }
}



function invalidateCacheForPathAndParents(path) {
    if (typeof path !== 'string') return;
    let currentPath = path;
    while (true) {
        const cacheKey = `${state.currentRepo}:${state.currentBranch}:${currentPath}`;
        state.fileCache.delete(cacheKey);
        if (currentPath === '') {
            break;
        }
        let tempPath = currentPath.endsWith('/') ? currentPath.slice(0, -1) : currentPath;
        let lastSlashIndex = tempPath.lastIndexOf('/');
        if (lastSlashIndex === -1) {
            currentPath = '';
        } else {
            currentPath = tempPath.substring(0, lastSlashIndex) + '/';
        }
    }
}


async function invalidateCacheForPath(path) {
    const cacheKey = `${state.currentRepo}:${state.currentBranch}:${path}`;
    state.fileCache.delete(cacheKey);
    await SimpleDB.del(cacheKey);
    
    let parentPath = '';
    if (path.includes('/')) {
        let cleanPath = path.endsWith('/') ? path.slice(0, -1) : path;
        parentPath = cleanPath.substring(0, cleanPath.lastIndexOf('/')) + '/';
    }
    
    const parentCacheKey = `${state.currentRepo}:${state.currentBranch}:${parentPath}`;
    state.fileCache.delete(parentCacheKey);
    await SimpleDB.del(parentCacheKey);
    
    const treeKey = `full_tree_cache:${state.currentRepo}:${state.currentBranch}`;
    await SimpleDB.del(treeKey);
    state.repoTreeCache = null;
    
    if (parentPath !== path) {
        invalidateCacheForPathAndParents(parentPath);
    }
}

function renderRepoList(reposSource) {
    if (reposSource === undefined) {
        reposSource = state.currentView === 'starred_repos' ? state.starredRepos :
            state.currentView === 'other_user_repos' ? state.currentRepoList : state.repos;
    }
    const pinnedRepoIds = JSON.parse(localStorage.getItem('pinned_repos') || '[]');
    let allRepos = [...(reposSource || [])];
    const pinnedRepos = allRepos.filter(r => pinnedRepoIds.includes(r.id)).sort((a, b) => new Date(b.updated_at) - new Date(a.updated_at));
    const unpinnedRepos = allRepos.filter(r => !pinnedRepoIds.includes(r.id)).sort((a, b) => new Date(b.updated_at) - new Date(a.updated_at));
    
    allRepos = [...pinnedRepos, ...unpinnedRepos];
    state.currentRepoList = allRepos;

    let currentPage = 1;
    switch (state.currentView) {
        case 'own_repos':
            currentPage = state.myReposPage;
            break;
        case 'starred_repos':
            currentPage = state.starredReposPage;
            break;
        case 'other_user_repos':
            currentPage = state.userReposPage;
            break;
        case 'public_search_results':
            currentPage = state.publicSearchPage;
            break;
    }

    let reposToRender;
    if (state.currentView === 'public_search_results') {
        reposToRender = allRepos;
    } else {
        const startIndex = (currentPage - 1) * state.REPOS_PER_PAGE;
        const endIndex = startIndex + state.REPOS_PER_PAGE;
        reposToRender = allRepos.slice(startIndex, endIndex);
    }

    const container = el.repoList;
    if (reposToRender.length === 0) {
        const message = state.currentView === 'starred_repos' ? '当前还未关注仓库' : '没有找到仓库';
        container.innerHTML = `<div class="empty-state"><i class="fa-brands fa-github"></i><p>${message}</p></div>`;
        return;
    }

    const starredRepoFullNames = new Set((state.starredRepos || []).map(r => r.full_name));
    const cachedLogin = localStorage.getItem('cached_user_login');
    const currentUserLogin = state.user ? state.user.login : cachedLogin;
    const isOwnReposView = state.currentView === 'own_repos' || !state.currentView;

    const newNodes = reposToRender.map((repo, index) => {
        const repoId = String(repo.id);
        const displayName = repo.name;
        
        let iconContainerClass = 'file-icon';
        const avatarUrl = repo.owner ? repo.owner.avatar_url : '';
        const iconDataAttr = avatarUrl ? `data-avatar-url="${escapeHtml(avatarUrl)}"` : '';
        const iconHTML = `<div class="${iconContainerClass}" ${iconDataAttr}><i class="fa-brands fa-github"></i></div>`;
        let starButtonHTML = '';
        let releasesButtonHTML = '';
        
        const isOwnRepo = isOwnReposView || (currentUserLogin && repo.owner && repo.owner.login === currentUserLogin);
        const isNotOwnRepo = !isOwnRepo;

        if (isNotOwnRepo || state.currentView === 'starred_repos') {
            releasesButtonHTML = `<button class="star-text-btn js-view-releases-btn" title="查看版本" data-repo-fullname="${escapeHtml(repo.full_name)}">版本</button>`;
            const isStarred = starredRepoFullNames.has(repo.full_name);
            const buttonText = isStarred ? '取消关注' : '关注';
            const buttonClass = isStarred ? 'star-text-btn starred' : 'star-text-btn';
            starButtonHTML = `<button class="${buttonClass}" data-repo-fullname="${escapeHtml(repo.full_name)}">${buttonText}</button>`;
        }

        const item = document.createElement('div');
        item.className = 'file-item';
        if (pinnedRepoIds.includes(repo.id)) {
            item.classList.add('pinned-repo');
        }
        if (isOwnRepo) {
            item.classList.add('is-own-repo');
        }
        item.dataset.repoId = repoId;
        item.dataset.owner = repo.owner ? repo.owner.login : '';
        
        item.innerHTML = `
            ${iconHTML}
            <div class="file-info">
                <div class="repo-name-header">
                    <p class="file-name">${displayName}</p>
                    <div class="repo-item-actions">
                        ${releasesButtonHTML}
                        ${starButtonHTML}
                    </div>
                </div>
                <p class="file-meta">
                    ${repo.private ? '私有' : '公开'} ${repo.size || repo.updated_at ? ' · ' : ''}
                    ${repo.size ? formatSize(repo.size * 1024) : ''}
                    ${repo.size && repo.updated_at ? ' · ' : ''}
                    ${formatRelativeTime(new Date(repo.updated_at))}
                </p>
                <p class="file-meta repo-description">${repo.description || ''}</p>
            </div>`;
            
        let pressTimer = null;
        let isLongPress = false;
        
        item.addEventListener('touchstart', (e) => {
            isLongPress = false;
            pressTimer = setTimeout(() => {
                isLongPress = true;
            }, 500);
        }, { passive: true });
        
        item.addEventListener('touchmove', () => clearTimeout(pressTimer));
        item.addEventListener('touchend', () => clearTimeout(pressTimer));
        
        item.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            clearTimeout(pressTimer);
            isLongPress = true;
            state.selectedRepo = repo;
            showRepoContextMenu(e, repo);
        });

        if (state.shouldAnimateList) {
            item.classList.add('file-item-enter');
            item.style.animationDelay = `${index * 30}ms`;
        } else {
            item.style.opacity = 1;
        }
        return item;
    });

    container.innerHTML = '';
    newNodes.forEach(node => container.appendChild(node));
    setTimeout(processRepoAvatars, 0);
    
    if (state.shouldAnimateList) {
        state.shouldAnimateList = false;
    }
    updatePaginationUI();
}




function handleNextRepoPage() {
    let pageStateKey, repoSource;

    switch (state.currentView) {
        case 'own_repos':
            pageStateKey = 'myReposPage';
            repoSource = state.repos;
            break;
        case 'starred_repos':
            pageStateKey = 'starredReposPage';
            repoSource = state.starredRepos;
            break;
        case 'other_user_repos':
            pageStateKey = 'userReposPage';
            repoSource = state.currentRepoList;
            break;
        default:
            return;
    }

    if (!repoSource || repoSource.length === 0) return;

    const totalPages = Math.ceil(repoSource.length / state.REPOS_PER_PAGE);
    let currentPage = state[pageStateKey];

    if (totalPages <= 1) {
        showToast('仓库列表没有超过20个，没有下一页。');
        return;
    }

    if (currentPage >= totalPages) {
        showToast('已经是最后一页了');
        return;
    }

    currentPage++;
    state[pageStateKey] = currentPage;
    renderRepoList();
    updatePaginationUI();
}



function handlePrevRepoPage() {
    let pageStateKey, repoSource;

    switch (state.currentView) {
        case 'own_repos':
            pageStateKey = 'myReposPage';
            repoSource = state.repos;
            break;
        case 'starred_repos':
            pageStateKey = 'starredReposPage';
            repoSource = state.starredRepos;
            break;
        case 'other_user_repos':
            pageStateKey = 'userReposPage';
            repoSource = state.currentRepoList;
            break;
        default:
            return;
    }

    if (!repoSource || repoSource.length === 0) return;

    const totalPages = Math.ceil(repoSource.length / state.REPOS_PER_PAGE);
    let currentPage = state[pageStateKey];

    if (totalPages <= 1) {
        showToast('仓库列表没有超过20个，没有上一页。');
        return;
    }
    
    if (currentPage <= 1) {
        showToast('已经是第一页了');
        return;
    }

    currentPage--;
    state[pageStateKey] = currentPage;
    renderRepoList();
    updatePaginationUI();
}

async function processRepoAvatars() {
    const iconsToProcess = document.querySelectorAll('#repoList .file-icon[data-avatar-url]');
    for (const iconContainer of iconsToProcess) {
        if (iconContainer.querySelector('.repo-avatar')) continue;
        const url = iconContainer.dataset.avatarUrl;
        const ownerLogin = iconContainer.closest('.file-item')?.dataset.owner || 'unknown';
        if (!url) continue;
        const avatarImg = new Image();
        avatarImg.className = 'repo-avatar';
        avatarImg.alt = ownerLogin;
        iconContainer.appendChild(avatarImg);
        AvatarManager.loadAvatar(avatarImg, url, ownerLogin);
    }
}



/**
 * [新增] 获取并显示指定仓库的版本列表
 * @param {string} repoFullName - 仓库全名 (e.g., "owner/repo")
 * @param {boolean} updateHistory - 是否更新浏览器历史记录
 */
async function fetchAndDisplayReleases(repoFullName, updateHistory = true) {
    state.viewingReleasesForRepo = repoFullName;
    state.currentView = 'releases_list'; // 设置新的视图状态
    
    // 更新UI
    el.repoList.innerHTML = '<div class="loading-spinner"><div class="spinner"></div></div>';
    el.currentRepo.textContent = `版本 - ${repoFullName.split('/')[1]}`;
    updateHomeStarredButtonState(); // 更新顶部按钮状态
    updatePaginationUI(); 
    
    if (updateHistory) {
        history.pushState({ view: 'releases_list', repo: repoFullName }, '', window.location.pathname);
    }

    try {
        const res = await fetch(`https://api.github.com/repos/${repoFullName}/releases`, {
            headers: { Authorization: `token ${state.token}` }
        });
        if (!res.ok) throw new Error(`获取版本列表失败 (HTTP ${res.status})`);
        
        const releases = await res.json();
        state.releases = releases; // 存储到 state
        renderReleasesList(releases);

    } catch (error) {
        showToast(error.message, 'error');
        el.repoList.innerHTML = `<div class="empty-state"><p>${error.message}</p></div>`;
    }
}

function renderReleasesList(releases) {
    el.repoList.innerHTML = '';
    
    const [owner] = state.viewingReleasesForRepo.split('/');
    const isOwner = state.user && owner === state.user.login;

    if (releases.length === 0) {
        const empty = document.createElement('div');
        empty.className = 'empty-state';
        empty.innerHTML = '<p>该仓库没有发布任何版本</p>';
        el.repoList.appendChild(empty);
        return;
    }

    const fragment = document.createDocumentFragment();
    releases.forEach(release => {
        const item = document.createElement('div');
        item.className = 'file-item';
        
        const deleteBtnHTML = isOwner ? 
            `<button class="btn-icon-sm danger delete-release-btn" style="margin-left:auto; z-index:2; flex-shrink:0;" title="删除">
                <i class="fa fa-trash"></i>
             </button>` : '';

        item.innerHTML = `
            <div class="file-icon"><i class="fa fa-folder"></i></div>
            <div class="file-info">
                <p class="file-name">
                    ${escapeHtml(release.name || release.tag_name)}
                    ${release.prerelease ? '<span class="label-prerelease" style="font-size:0.6em; background:#f59e0b; color:white; padding:1px 3px; border-radius:2px; margin-left:5px;">Pre</span>' : ''}
                </p>
                <p class="file-meta">
                    ${formatRelativeTime(new Date(release.published_at))} · ${release.assets.length} 文件
                </p>
            </div>
            ${deleteBtnHTML}
        `;
        
        item.addEventListener('click', (e) => {
            if (e.target.closest('.delete-release-btn')) return;
            fetchAndDisplayAssets(release);
        });

        if (isOwner) {
            const delBtn = item.querySelector('.delete-release-btn');
            delBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                showDeleteModal(null, false, '删除版本', `确定删除版本 <strong>${release.tag_name}</strong> 吗？此操作不可撤销。`, async () => {
                    await deleteReleaseInMainView(release.id, state.viewingReleasesForRepo);
                }, '删除', 'btn-danger');
            });
        }

        fragment.appendChild(item);
    });
    el.repoList.appendChild(fragment);
    updatePaginationUI();
}
async function createRelease() {
    const tagName = document.getElementById('releaseTagNameInput').value.trim();
    const name = document.getElementById('releaseNameInput').value.trim();
    const body = document.getElementById('releaseBodyInput').value.trim();
    const prerelease = document.getElementById('releasePrerelease').checked;
    const btn = document.getElementById('submitReleaseBtn');
    
    // 安全检查
    if (!currentManagingRepo) {
        showToast('操作上下文丢失，请重新点击底部加号按钮', 'error');
        hideReleaseManagerModal();
        return;
    }

    if (!tagName) {
        showToast('版本号不能为空', 'error');
        return;
    }
    
    let repoFullName = currentManagingRepo.full_name;
    if (!repoFullName && currentManagingRepo.owner && currentManagingRepo.name) {
        repoFullName = `${currentManagingRepo.owner.login}/${currentManagingRepo.name}`;
    }

    btn.disabled = true;
    btn.innerHTML = '发布中... <i class="fa fa-spinner fa-spin"></i>';
    
    try {
        const payload = {
            tag_name: tagName,
            target_commitish: currentManagingRepo.default_branch || 'main',
            name: name || tagName,
            body: body,
            draft: false,
            prerelease: prerelease
        };
        
        const res = await fetch(`https://api.github.com/repos/${repoFullName}/releases`, {
            method: 'POST',
            headers: { 
                'Authorization': `token ${state.token}`,
                'Content-Type': 'application/json',
                'Accept': 'application/vnd.github.v3+json'
            },
            body: JSON.stringify(payload)
        });
        
        if (!res.ok) {
            const err = await res.json().catch(() => ({}));
            throw new Error(err.message || '发布失败');
        }
        
        showToast('版本发布成功！', 'success');
        
        hideReleaseManagerModal();
        
        // 如果当前正好在版本列表页面，立即刷新列表
        if (state.currentView === 'releases_list' && state.viewingReleasesForRepo === repoFullName) {
            fetchAndDisplayReleases(repoFullName, false);
        }
        
    } catch (e) {
        showToast(`发布失败: ${e.message}`, 'error');
    } finally {
        btn.disabled = false;
        btn.textContent = '发布版本';
    }
}

async function deleteReleaseInMainView(releaseId, repoFullName) {
    try {
        const res = await fetch(`https://api.github.com/repos/${repoFullName}/releases/${releaseId}`, {
            method: 'DELETE',
            headers: { 
                'Authorization': `token ${state.token}`
            }
        });
        
        if (!res.ok && res.status !== 404) throw new Error('删除失败');
        
        showToast('版本已删除');
        hideDeleteModal();
        fetchAndDisplayReleases(repoFullName, false);
        
    } catch (e) {
        showToast(e.message, 'error');
    }
}
function hideReleaseManagerModal() {
    if (el.releaseManagerModal) {
        el.releaseManagerModal.classList.add('hidden');
        // 清理 UI 栈（如果使用了 uiStateStack）
        const index = uiStateStack.indexOf(hideReleaseManagerModal);
        if (index > -1) uiStateStack.splice(index, 1);
    }
}


function showReleaseManagerModal(repo, autoOpenForm = false) {
    currentManagingRepo = repo; // 关键：保存当前操作的仓库上下文
    
    // 1. 重置输入框
    document.getElementById('releaseTagNameInput').value = '';
    document.getElementById('releaseNameInput').value = '';
    document.getElementById('releaseBodyInput').value = '';
    document.getElementById('releasePrerelease').checked = false;
    
    // 2. 处理表单显示状态
    const form = document.getElementById('createReleaseForm');
    const icon = document.querySelector('#toggleCreateReleaseFormBtn i');
    const listSection = document.getElementById('releaseManagerList');

    if (autoOpenForm) {
        // 如果是从底部按钮点击进来的，强制展开表单，并隐藏列表（因为主界面已经是列表了）
        form.classList.remove('hidden');
        icon.className = 'fa fa-chevron-up';
        if (listSection) listSection.style.display = 'none';
    } else {
        // 默认状态（如从其他地方进入）：折叠表单，显示列表
        form.classList.add('hidden');
        icon.className = 'fa fa-chevron-down';
        if (listSection) listSection.style.display = 'block';
    }

    // 3. 显示模态框
    document.getElementById('releaseCountBadge').textContent = '0';
    el.releaseManagerModal.classList.remove('hidden');
    uiStateStack.push(hideReleaseManagerModal);
}

/**
 * [新增] 显示指定版本的资源列表 (无需API请求)
 * @param {object} release - 单个版本对象
 * @param {boolean} updateHistory - 是否更新浏览器历史记录
 */
function fetchAndDisplayAssets(release, updateHistory = true) {
    state.currentRelease = release;
    state.currentView = 'assets_list'; // 更新视图状态
    
    // 更新UI
    el.currentRepo.textContent = `文件 - ${release.name || release.tag_name}`;
    if (updateHistory) {
        history.pushState({ view: 'assets_list', repo: state.viewingReleasesForRepo, releaseId: release.id }, '', window.location.pathname);
    }
    
    renderAssetsList(release.assets);
}

function renderAssetsList(assets) {
    // 1. 强制标记当前视图为“版本详情”
    state.currentView = 'assets_list'; 
    
    el.repoList.innerHTML = '';
    
    // 2. 更新底部按钮（变成上传图标）
    updatePaginationUI();

    if (assets.length === 0) {
        const empty = document.createElement('div');
        empty.className = 'empty-state';
        empty.innerHTML = '<p>此版本暂无文件</p>';
        el.repoList.appendChild(empty);
        return;
    }

    const fragment = document.createDocumentFragment();
    assets.forEach(asset => {
        const item = document.createElement('div');
        item.className = 'file-item';
        item.innerHTML = `
            <div class="file-icon"><i class="fa ${getFileIcon(asset.name)}"></i></div>
            <div class="file-info">
                <p class="file-name">${escapeHtml(asset.name)}</p>
                <p class="file-meta">
                    ${formatSize(asset.size)} · ${asset.download_count} 次下载
                </p>
            </div>
        `;
        
        item.addEventListener('click', () => {
            downloadReleaseAsset(asset);
        });
        fragment.appendChild(item);
    });
    el.repoList.appendChild(fragment);
}




async function refreshAssetsList() {
    if (!state.currentRelease || !state.viewingReleasesForRepo) return;
    showToast('正在刷新版本信息...');
    try {
        const res = await fetch(`https://api.github.com/repos/${state.viewingReleasesForRepo}/releases`, {
            headers: { Authorization: `token ${state.token}` }
        });
        if (!res.ok) throw new Error('刷新失败');
        const releases = await res.json();
        state.releases = releases;
        const updatedRelease = releases.find(r => r.id === state.currentRelease.id);
        if (updatedRelease) {
            fetchAndDisplayAssets(updatedRelease, false); // 找到更新后的版本并重新渲染
        } else {
            showToast('此版本可能已被删除，返回上一页', 'error');
            goUp(); // 如果版本找不到了，自动返回
        }
    } catch(e) {
        showToast(e.message, 'error');
    }
}





function showRepoListView() {
    state.isSearchResultsView = false;
    el.searchToggleBtn.classList.remove('hidden');
    el.multiSelectToggleBtn.classList.remove('hidden');
    el.sortToggleBtn.classList.remove('hidden');
    state.shouldAnimateList = true;
    el.repoList.classList.remove('hidden');
    el.fileList.classList.add('hidden');
    el.pathNavContainer.classList.add('hidden');
    el.branchSwitcherContainer.classList.add('hidden');

    const globalSearchContainer = document.getElementById('globalSearchContainer');
    const globalSearchToggleBtn = document.getElementById('globalSearchToggleBtn');
    if (globalSearchContainer && !globalSearchContainer.classList.contains('hidden')) {
        globalSearchContainer.classList.add('hidden');
        globalSearchToggleBtn.classList.remove('active');
    }
    
    if (state.currentView === 'own_repos') {
        el.currentRepo.textContent = '选择仓库';
    } else if (state.currentView === 'starred_repos') {
        el.currentRepo.textContent = '星标仓库';
    } else if (state.currentView === 'other_user_repos') {
        el.currentRepo.textContent = `${state.viewingOwner} 的仓库`;
    }

    toggleView(true);
    state.currentRepo = null;
    state.currentPath = '';
    state.currentBranch = null;
    state.branches = [];
    
    updateGlobalSearchVisibility();
   
    setTimeout(() => { el.main.scrollTop = state.repoListScrollPosition; }, 0);
}

async function fetchBranches(repo) {
    try {
        const res = await fetch(`https://api.github.com/repos/${repo.full_name}/branches`, {
            headers: {
                Authorization: `token ${state.token}`,
                'User-Agent': 'Mozilla/5.0'
            }
        });
        if (res.ok) {
            state.branches = await res.json();
            state.branches.reverse();
        } else {
            state.branches = [];
            showToast('获取分支列表失败');
        }
    } catch (e) {
        state.branches = [];
        showToast('获取分支列表失败');
        console.error(e);
    }
}

function renderBranchSwitcher() {
    const container = el.branchSwitcherContainer;
    container.innerHTML = '';
    if (!state.branches || state.branches.length === 0) {
        container.classList.add('hidden');
        return;
    }
    const wrapper = document.createElement('div');
    wrapper.className = 'custom-branch-select-wrapper';
    const trigger = document.createElement('button');
    trigger.className = 'custom-branch-select-trigger';
    trigger.innerHTML = `
        <span>${escapeHtml(state.currentBranch)}</span>
        <i class="fa fa-chevron-down"></i>
    `;
    const optionsPanel = document.createElement('div');
    optionsPanel.className = 'custom-branch-select-options';
    state.branches.forEach(branch => {
        const option = document.createElement('div');
        option.className = 'custom-branch-select-option';
        if (branch.name === state.currentBranch) {
            option.classList.add('selected');
        }
        option.textContent = branch.name;
        option.dataset.branchName = branch.name;
        option.addEventListener('click', () => {
            const selectedBranch = option.dataset.branchName;
            if (selectedBranch === state.currentBranch) {
                wrapper.classList.remove('open');
                return;
            }
            state.shouldAnimateList = true;
            const previouslySelected = optionsPanel.querySelector('.custom-branch-select-option.selected');
            if (previouslySelected) {
                previouslySelected.classList.remove('selected');
            }
            option.classList.add('selected');
            state.currentBranch = selectedBranch;
            state.currentPath = '';
            localStorage.setItem(`last_branch_${state.currentRepo}`, state.currentBranch);
            el.fileList.innerHTML = '<div class="loading-spinner"><div class="spinner"></div></div>';
            const newState = { repo: state.currentRepo, path: '', branch: state.currentBranch };
            history.replaceState(newState, '', `#/${state.currentRepo}/`);
            renderPathNav();
            fetchFiles(true);
            trigger.querySelector('span').textContent = selectedBranch;
            wrapper.classList.remove('open');
        });
        optionsPanel.appendChild(option);
    });
    wrapper.appendChild(trigger);
    wrapper.appendChild(optionsPanel);
    container.appendChild(wrapper);
    container.classList.remove('hidden');
    trigger.addEventListener('click', (e) => {
        e.stopPropagation();
        wrapper.classList.toggle('open');
    });
    document.addEventListener('click', (e) => {
        if (!wrapper.contains(e.target)) {
            wrapper.classList.remove('open');
        }
    });
}

function preloadSubdirectories(files) {
    const dirs = files.filter(f => f.type === 'dir').slice(0, 15);
    if (dirs.length === 0) return;

    const run = () => {
        dirs.forEach(dir => {
            const cacheKey = `${state.currentRepo}:${state.currentBranch}:${dir.path}`;
            if (state.fileCache.has(cacheKey)) return;

            fetch(`https://api.github.com/repos/${state.currentRepo}/contents/${dir.path}?ref=${state.currentBranch}`, {
                headers: {
                    Authorization: `token ${state.token}`,
                    'User-Agent': 'Mozilla/5.0'
                }
            })
            .then(res => {
                if (res.ok) return res.json();
                throw new Error('Preload failed');
            })
            .then(data => {
                if (Array.isArray(data)) {
                    let fetchedFiles = data.map(file => {
                        const isImage = IMAGE_EXTS.includes(file.name.split('.').pop()?.toLowerCase());
                        if (isImage) {
                            return { ...file, isImageLoaded: false };
                        }
                        return file;
                    });
                    fetchedFiles.sort((a, b) => a.type === 'dir' && b.type !== 'dir' ? -1 : a.type !== 'dir' && b.type === 'dir' ? 1 : a.name.localeCompare(b.name));
                    state.fileCache.set(cacheKey, fetchedFiles);
                }
            })
            .catch(() => {});
        });
    };

    if ('requestIdleCallback' in window) {
        requestIdleCallback(run);
    } else {
        setTimeout(run, 500);
    }
}


function getFilesFromLocalTree(path) {
    if (!state.repoTreeCache) return null;
    const targetPath = path ? (path.endsWith('/') ? path : path + '/') : '';
    const files = [];
    for (const item of state.repoTreeCache) {
        if (!item.path.startsWith(targetPath)) continue;
        const relativePath = item.path.slice(targetPath.length);
        if (!relativePath) continue;
        if (relativePath.indexOf('/') !== -1) continue;
        
        files.push({
            name: relativePath,
            path: item.path,
            sha: item.sha,
            size: item.size,
            type: item.type === 'tree' ? 'dir' : 'file',
            html_url: `https://github.com/${state.currentRepo}/${item.type === 'tree' ? 'tree' : 'blob'}/${state.currentBranch}/${item.path}`
        });
    }
    return files;
}
async function loadRecursiveRepoTree() {
    try {
        const [owner, repo] = state.currentRepo.split('/');
        const currentBranchRef = state.currentBranch; 
        // 记录发起请求时的仓库ID，用于比对
        const requestingRepo = state.currentRepo; 

        const url = `https://api.github.com/repos/${owner}/${repo}/git/trees/${currentBranchRef}?recursive=1`;
        const res = await fetch(url, {
            headers: {
                Authorization: `token ${state.token}`
            }
        });
        
        if (res.ok) {
            // 关键检查：如果请求回来时，用户已经切换了仓库，则丢弃数据
            if (state.currentRepo !== requestingRepo) return;

            const data = await res.json();
            if (data.truncated) {
                showToast('仓库文件过多，部分深度目录可能需要单独加载', 'info');
            }
            state.repoTreeCache = data.tree;

            // === 新增：保存到 IndexedDB，供下次秒开 ===
            // 使用与预加载相同的 Key 格式
            if (!data.truncated) {
                const cacheKey = `full_tree_cache:${state.currentRepo}:${state.currentBranch}`;
                SimpleDB.set(cacheKey, {
                    tree: data.tree,
                    timestamp: Date.now()
                });
            }
            // ========================================

            // 如果当前还在 loading 状态（例如 fetchFiles 失败了），尝试用 Tree 数据刷新列表
            if (document.querySelector('#fileList .spinner')) {
                 const localFiles = getFilesFromLocalTree(state.currentPath);
                 if (localFiles) {
                     state.files = localFiles;
                     applyFiltersAndSort();
                     renderFileList();
                 }
            }
            
            // 触发图片预加载（如果需要）
            preloadRepoImages();
        }
    } catch (e) {
        console.error("后台树加载失败", e);
    }
}
async function uploadFilesInSequence(files, index) {
    if (index >= files.length) {
        setTimeout(() => {
            el.uploadPanel.classList.add('hidden');
        }, 500);
        invalidateCacheForPathAndParents(state.currentPath);
        await fetchFiles(true); 
        return;
    }

    const file = files[index];
    const statusElement = document.querySelector(`.upload-status[data-index="${index}"]`);
    const existingFile = state.files.find(f => f.name === file.name);
    let shouldUpload = true;

    if (existingFile) {
        const userAction = await new Promise((resolve) => {
            showDeleteModal(
                null,
                false,
                '文件冲突',
                `文件 "${escapeHtml(file.name)}" 已存在，是否覆盖？
                <br><br>注意：覆盖后的文件生效时间较久，你马上操作的话还是原先的文件`,
                () => {
                    hideDeleteModal();
                    resolve('overwrite');
                },
                '覆盖',
                'btn-primary',
                () => {
                    hideDeleteModal();
                    resolve('skip');
                }
            );
        });

        if (userAction === 'skip') {
            shouldUpload = false;
            if (statusElement) {
                statusElement.textContent = '已跳过';
                statusElement.className = 'upload-status';
                statusElement.style.color = '#9ca3af';
            }
        }
    }

    if (shouldUpload) {
        try {
            await uploadSingleFile(file, index);
        } catch (error) {
            console.error(error);
        }
    }
    
    await uploadFilesInSequence(files, index + 1);
}

async function uploadSingleFile(file, index) {
    const MAX_FILE_SIZE_BYTES = 100 * 1024 * 1024;
    return new Promise(async (resolve, reject) => {
        const progressBar = document.querySelector(`.upload-progress[data-index="${index}"]`);
        const statusElement = document.querySelector(`.upload-status[data-index="${index}"]`);
        const percentTextEl = progressBar ? progressBar.querySelector(`.percent-text[data-index="${index}"]`) : null;
        
        if (file.size > MAX_FILE_SIZE_BYTES) {
            if (statusElement) {
                statusElement.textContent = `文件过大`;
                statusElement.className = 'upload-status error';
            }
            reject(new Error('文件过大'));
            return;
        }
        
        if (statusElement) statusElement.textContent = '准备中...';
        
        const reader = new FileReader();
        reader.readAsArrayBuffer(file);
        
        reader.onload = async (e) => {
            let progress = 0;
            let progressInterval = null;
            const [owner, repo] = state.currentRepo.split('/');
            const fileName = file.name;
            const currentDir = state.currentPath || '';
            const filePath = currentDir ? `${currentDir}${fileName}` : fileName;
            const parentPathForCache = currentDir;

            try {
                progressInterval = setInterval(() => {
                    if (progress < 95) {
                        progress += 1;
                        if (progressBar) progressBar.style.width = `${progress}%`;
                        if (percentTextEl) percentTextEl.textContent = `${progress}%`;
                    }
                }, 100);

                const base64String = arrayBufferToBase64(e.target.result);
                
                let existingFileSha = null;
                try {
                    const checkUrl = `https://api.github.com/repos/${owner}/${repo}/contents/${filePath}?ref=${state.currentBranch}`;
                    const checkRes = await fetch(checkUrl, { headers: { 'Authorization': `token ${state.token}`, 'User-Agent': 'Mozilla/5.0' } });
                    if (checkRes.ok) existingFileSha = (await checkRes.json()).sha;
                } catch (e) {}

                const requestBody = {
                    message: `Upload ${fileName}`,
                    content: base64String,
                    branch: state.currentBranch
                };
                if (existingFileSha) requestBody.sha = existingFileSha;

                const response = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${filePath}`, {
                    method: 'PUT',
                    headers: { 'Authorization': `token ${state.token}`, 'Content-Type': 'application/json', 'User-Agent': 'Mozilla/5.0' },
                    body: JSON.stringify(requestBody),
                    signal: AbortSignal.timeout(300000)
                });

                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                const responseData = await response.json();

                await updateGlobalCacheState('add', {
                    path: filePath,
                    type: 'blob',
                    sha: responseData.content ? responseData.content.sha : null,
                    size: responseData.content ? responseData.content.size : file.size,
                    parentPath: parentPathForCache 
                });

                clearInterval(progressInterval);
                if (progressBar) progressBar.style.width = '100%';
                if (percentTextEl) percentTextEl.textContent = '100%';
                if (statusElement) {
                    statusElement.textContent = '上传成功';
                    statusElement.className = 'upload-status success';
                }
                resolve();

            } catch (error) {
                if (statusElement) {
                    statusElement.textContent = '上传失败';
                    statusElement.className = 'upload-status error';
                }
                reject(error);
            } finally {
                if (progressInterval) clearInterval(progressInterval);
                const itemContainer = statusElement ? statusElement.closest('.upload-item') : null;
                if (itemContainer && statusElement.classList.contains('success')) {
                    setTimeout(() => {
                        itemContainer.style.opacity = '0';
                        setTimeout(() => itemContainer.remove(), 500);
                    }, 1500);
                }
            }
        };
        reader.onerror = () => reject(new Error('Read error'));
    });
}

async function navigateToRepo(repoData, branch, path = '', updateHistory = true) {
    if (currentFetchController) {
        currentFetchController.abort();
        currentFetchController = null;
    }
    state.currentView = 'file_list';
    state.isSearchResultsView = false;
    if (state.currentRepo !== repoData.full_name || state.currentBranch !== branch) {
        state.repoTreeCache = null;
    }
    state.currentRepo = repoData.full_name;
    state.currentPath = path;
    state.currentBranch = branch;
    state.shouldAnimateList = true;
    if (updateHistory) {
        const newState = {
            view: 'file_list',
            repo: repoData.full_name,
            path: path,
            branch: branch
        };
        history.pushState(newState, '', `#/${repoData.full_name}/${path}`);
    }
    let displayName = repoData.name || repoData.full_name;
    if (displayName && displayName.includes('/')) {
        displayName = displayName.split('/').pop();
    }
    el.currentRepo.textContent = displayName;
    toggleView(false);
    el.searchToggleBtn.classList.remove('hidden');
    el.multiSelectToggleBtn.classList.remove('hidden');
    el.sortToggleBtn.classList.remove('hidden');
    updateGlobalSearchVisibility();
    el.fileList.innerHTML = '<div class="loading-spinner"><div class="spinner"></div></div>';
    renderPathNav();
    fetchBranches(repoData).then(renderBranchSwitcher);
    const cacheKey = `full_tree_cache:${repoData.full_name}:${branch}`;
    let loadedFromCache = false;
    try {
        const cachedData = await SimpleDB.get(cacheKey);
        if (cachedData && cachedData.tree) {
            state.repoTreeCache = cachedData.tree;
            const localFiles = getFilesFromLocalTree(path);
            if (localFiles) {
                state.files = localFiles;
                applyFiltersAndSort();
                renderFileList();
                loadedFromCache = true;
                updatePaginationUI();
                return;
            }
        }
    } catch (e) {}
    if (!loadedFromCache) {
        fetchFiles(false, false);
        if (!state.repoTreeCache) {
            loadRecursiveRepoTree();
        }
    }
    updatePaginationUI();
}

async function fetchFiles(forceRefresh = false, showLoader = true) {
    if (!state.currentRepo || !state.currentBranch) return;
    const pathForFetch = state.currentPath;
    let hasRenderedCache = false;
    
    if (forceRefresh && typeof recentlySavedCache !== 'undefined') {
        recentlySavedCache.clear();
    }

    if (!forceRefresh) {
        const cacheKey = `${state.currentRepo}:${state.currentBranch}:${pathForFetch}`;
        
        // 1. 检查内存
        if (state.fileCache.has(cacheKey)) {
            let files = state.fileCache.get(cacheKey);
            // 双重保险：读取缓存时必须再次应用补丁
            files = ConsistencyManager.apply(files);
            state.files = files;
            applyFiltersAndSort();
            renderFileList();
            hasRenderedCache = true;
        } else {
            // 2. 检查 DB
            try {
                const cachedData = await SimpleDB.get(cacheKey);
                if (cachedData && Array.isArray(cachedData.data)) {
                    let files = ConsistencyManager.apply(cachedData.data); // 应用补丁
                    state.files = files;
                    // 回填内存
                    state.fileCache.set(cacheKey, files);
                    applyFiltersAndSort();
                    renderFileList();
                    hasRenderedCache = true;
                } else if (state.repoTreeCache) {
                    // 3. 检查 Tree
                    const localFiles = getFilesFromLocalTree(pathForFetch);
                    if (localFiles) {
                        state.files = ConsistencyManager.apply(localFiles); // 应用补丁
                        applyFiltersAndSort();
                        renderFileList();
                        hasRenderedCache = true;
                    }
                }
            } catch (e) {}
        }
    }
    
    if (showLoader && !hasRenderedCache) {
        el.fileList.innerHTML = '<div class="loading-spinner"><div class="spinner"></div></div>';
    }
    
    await fetchFilesFromNetwork(false, pathForFetch, hasRenderedCache);
}


function areFileListsEqual(listA, listB) {
    if (!listA || !listB) return false;
    if (listA.length !== listB.length) return false;
    
    const mapA = new Map();
    for (const f of listA) {
        mapA.set(f.path, f.sha);
    }

    for (const fileB of listB) {
        const shaA = mapA.get(fileB.path);
        if (shaA !== fileB.sha) {
            return false;
        }
    }
    return true;
}


async function fetchFilesFromNetwork(isInitialLoad = false, pathForFetch, isSilentUpdate = false) {
    if (currentFetchController) {
        currentFetchController.abort();
    }
    currentFetchController = new AbortController();
    const signal = currentFetchController.signal;

    // 确保读取到最新的本地操作记录
    ConsistencyManager.load();

    try {
        const [owner, repo] = state.currentRepo.split('/');
        const timestamp = Date.now();
        const url = `https://api.github.com/repos/${owner}/${repo}/contents/${pathForFetch}?ref=${state.currentBranch}&t=${timestamp}`;
        const cacheKey = `${state.currentRepo}:${state.currentBranch}:${pathForFetch}`;
        
        let etag = null;
        // 如果有本地未同步的操作，不使用 ETag，强制拉取新数据进行合并
        if (ConsistencyManager.buffer.length === 0) { 
            try {
                const cachedRecord = await SimpleDB.get(cacheKey);
                if (cachedRecord && cachedRecord.etag) etag = cachedRecord.etag;
            } catch (e) {}
        }

        const headers = {
            'Authorization': `token ${state.token}`,
            'User-Agent': 'Mozilla/5.0'
        };
        if (etag) headers['If-None-Match'] = etag;

        const res = await fetch(url, {
            headers: headers,
            cache: 'no-store', // 强制网络请求
            signal: signal
        });

        if (res.status === 304) {
            // 即使 304，也要检查是否有本地补丁需要应用
            if (state.files) {
                const patchedFiles = ConsistencyManager.apply(state.files);
                if (JSON.stringify(patchedFiles) !== JSON.stringify(state.files)) {
                    state.files = patchedFiles;
                    applyFiltersAndSort();
                    renderFileList();
                }
            }
            return;
        }

        if (!res.ok) {
            if (res.status === 404) {
                // 处理空文件夹刚创建的情况
                let patchedFiles = ConsistencyManager.apply([]); 
                if (patchedFiles.length > 0 && pathForFetch === state.currentPath) {
                    state.files = patchedFiles;
                    applyFiltersAndSort();
                    renderFileList();
                    return;
                }
                if (pathForFetch === state.currentPath) {
                    state.files = [];
                    applyFiltersAndSort();
                    renderFileList();
                }
                return;
            }
            if (!isSilentUpdate) throw new Error('加载文件失败');
            return;
        }

        const newEtag = res.headers.get('ETag');
        const rawData = await res.json();
        
        let fetchedFiles = Array.isArray(rawData) ? rawData : [];
        
        // 【核心】: 无论 GitHub 返回什么，强制合并本地的“真理”数据
        fetchedFiles = ConsistencyManager.apply(fetchedFiles);

        // 图片预处理
        fetchedFiles = fetchedFiles.map(file => {
            const isImage = IMAGE_EXTS.includes(file.name.split('.').pop()?.toLowerCase());
            if (isImage) return { ...file, isImageLoaded: false };
            return file;
        });

        // 存入内存
        state.fileCache.set(cacheKey, [...fetchedFiles]);
        
        // 存入 DB
        try {
            await SimpleDB.set(cacheKey, {
                data: [...fetchedFiles],
                etag: newEtag,
                timestamp: Date.now()
            });
        } catch (e) {}

        if (pathForFetch === state.currentPath) {
            state.files = fetchedFiles;
            if (typeof recentlySavedCache !== 'undefined') {
                for (const file of fetchedFiles) {
                    const cached = recentlySavedCache.get(file.path);
                    if (cached && cached.sha !== file.sha) recentlySavedCache.delete(file.path);
                }
            }
            applyFiltersAndSort();
            renderFileList();
            preloadSubdirectories(fetchedFiles);
        }

    } catch (err) {
        if (err.name === 'AbortError') return;
        if (pathForFetch === state.currentPath && !isSilentUpdate) {
            // 出错时尝试显示本地数据
            const patchedFiles = ConsistencyManager.apply([]);
            if (patchedFiles.length > 0) {
                state.files = patchedFiles;
                applyFiltersAndSort();
                renderFileList();
            } else {
                showToast('加载文件失败: ' + err.message);
            }
        }
    } finally {
        if (currentFetchController && currentFetchController.signal === signal) {
            currentFetchController = null;
        }
        if (pathForFetch === state.currentPath) {
            const spinner = document.querySelector('#fileList .spinner');
            if (spinner) {
                if (!state.files) state.files = [];
                renderFileList();
            }
        }
    }
}





let fileListObserver = null;

function renderFileList() {
    if (!state.loadedImageMap) state.loadedImageMap = new Map();
    const list = (state.displayFiles && state.displayFiles.length >= 0) ? state.displayFiles : state.files;
    el.fileList.innerHTML = '';
    if (!list || list.length === 0) {
        const emptyState = document.createElement('div');
        emptyState.className = 'empty-state';
        const emptyMessage = state.currentPath ? '文件夹为空' : '此分支为空';
        emptyState.innerHTML = `<i class="fa-brands fa-github"></i><p>${emptyMessage}</p>`;
        el.fileList.appendChild(emptyState);
        updateActionBar();
        return;
    }
    const BATCH_SIZE = 50;
    let renderedCount = 0;
    const isGridView = state.viewMode === 'grid';
    const imageExtensions = ['png', 'jpg', 'jpeg', 'ico', 'gif', 'webp', 'bmp', 'svg'];
    const renderBatch = () => {
        const fragment = document.createDocumentFragment();
        const limit = Math.min(renderedCount + BATCH_SIZE, list.length);
        for (let i = renderedCount; i < limit; i++) {
            const file = list[i];
            const isDir = file.type === 'dir';
            const icon = isDir ? 'fa-folder' : getFileIcon(file.name);
            const item = document.createElement('div');
            const fileExtension = file.name.split('.').pop()?.toLowerCase();
            const isImage = !isDir && imageExtensions.includes(fileExtension);
            item.className = 'file-item';
            item.dataset.filePath = file.path;
            if (renderedCount < 20 && state.shouldAnimateList) {
                item.classList.add('file-item-enter');
                item.style.animationDelay = `${(i - renderedCount) * 15}ms`;
            } else {
                item.style.opacity = 1;
            }
            if (state.selectedItems.has(file.path)) {
                item.classList.add('selected');
            }
            if (isGridView && isImage) {
                item.classList.add('is-image-grid');
            }
            const checkboxHTML = `
                <div class="select-checkbox-wrapper">
                    <div class="select-checkbox-bg"></div>
                    <i class="fa fa-check"></i>
                </div>
            `;
            let innerHTML = '';
            let fileMetaHTML;
            if (state.isLocalSearchResultsView) {
                fileMetaHTML = `<p class="file-meta">${isDir ? '文件夹' : formatSize(file.size)}</p>`;
            } else {
                fileMetaHTML = `
                    <p class="file-meta">
                        ${isDir ? '文件夹' : formatSize(file.size)}
                        ${(isDir || file.size) && file.last_modified ? ' · ' : ''}
                        ${file.last_modified ? formatRelativeTime(new Date(file.last_modified)) : ''}
                    </p>
                `;
            }
            const rawUrlForThumb = file.download_url || (file.html_url ? file.html_url.replace('github.com', 'raw.githubusercontent.com').replace('/blob/', '/') : '');
            const cachedUrlForThumb = state.loadedImageMap.get(file.path);
            const imageUrlForThumb = cachedUrlForThumb || getProxiedUrl(rawUrlForThumb);
            const shaAttr = file.sha ? `data-image-sha="${file.sha}"` : '';
            const imgStyle = 'pointer-events: none; -webkit-touch-callout: none; user-select: none;';
            if (isGridView) {
                let gridContentHTML = '';
                if (isImage) {
                    let thumbnailHTML;
                    if (cachedUrlForThumb) {
                        thumbnailHTML = `
                            <div class="file-thumbnail-container loaded" 
                                 data-image-url="${escapeHtml(imageUrlForThumb)}" 
                                 data-image-name="${escapeHtml(file.name)}"
                                 ${shaAttr}>
                                 <img class="file-thumbnail" src="${escapeHtml(cachedUrlForThumb)}" alt="${escapeHtml(file.name)}" style="${imgStyle}">
                            </div>`;
                    } else {
                        thumbnailHTML = `
                            <div class="file-thumbnail-container loading" 
                                 data-image-url="${escapeHtml(imageUrlForThumb)}" 
                                 data-image-name="${escapeHtml(file.name)}"
                                 ${shaAttr}> 
                                 <i class="fa fa-spinner fa-spin thumbnail-loader-icon"></i>
                                 <div class="thumbnail-error retry-trigger" title="点击重试"><i class="fa fa-repeat"></i></div>
                            </div>`;
                    }
                    gridContentHTML = `
                        ${thumbnailHTML}
                        <div class="file-info">
                            <p class="file-name">${escapeHtml(file.name)}</p>
                            ${fileMetaHTML}
                        </div>
                    `;
                } else {
                    gridContentHTML = `
                        <div class="file-icon"><i class="fa ${icon}"></i></div>
                        <div class="file-info">
                            <p class="file-name">${escapeHtml(file.name)}</p>
                            ${fileMetaHTML}
                        </div>
                    `;
                }
                innerHTML = checkboxHTML + gridContentHTML;
            } else {
                let listContentHTML = '';
                if (isImage) {
                    if (cachedUrlForThumb) {
                        listContentHTML = `
                            <div class="file-thumbnail-container loaded" 
                                 data-image-url="${escapeHtml(imageUrlForThumb)}" 
                                 data-image-name="${escapeHtml(file.name)}"
                                 ${shaAttr}>
                               <img class="file-thumbnail" src="${escapeHtml(cachedUrlForThumb)}" alt="${escapeHtml(file.name)}" style="${imgStyle}">
                            </div>
                         `;
                    } else {
                        listContentHTML = `
                            <div class="file-thumbnail-container loading" 
                                 data-image-url="${escapeHtml(imageUrlForThumb)}" 
                                 data-image-name="${escapeHtml(file.name)}"
                                 ${shaAttr}>
                               <i class="fa fa-spinner fa-spin thumbnail-loader-icon"></i>
                               <div class="thumbnail-error retry-trigger" title="点击重试"><i class="fa fa-repeat"></i></div>
                            </div>
                         `;
                    }
                } else {
                    listContentHTML = `<div class="file-icon"><i class="fa ${icon}"></i></div>`;
                }
                listContentHTML += `
                    <div class="file-info">
                        <p class="file-name">${escapeHtml(file.name)}</p>
                        ${fileMetaHTML}
                    </div>
                `;
                innerHTML = checkboxHTML + listContentHTML;
            }
            item.innerHTML = innerHTML;
            fragment.appendChild(item);
        }
        el.fileList.appendChild(fragment);
        renderedCount = limit;
        if (!state.isSearchResultsView) {
            processImagePlaceholders();
        }
    };
    renderBatch();
    if (renderedCount < list.length) {
        const sentinel = document.createElement('div');
        sentinel.style.height = '20px';
        sentinel.style.width = '100%';
        el.fileList.appendChild(sentinel);
        if (fileListObserver) fileListObserver.disconnect();
        fileListObserver = new IntersectionObserver((entries) => {
            if (entries[0].isIntersecting) {
                sentinel.remove();
                renderBatch();
                if (renderedCount < list.length) {
                    el.fileList.appendChild(sentinel);
                }
            }
        }, { rootMargin: '200px' });
        fileListObserver.observe(sentinel);
    }
    updateActionBar();
    if (state.shouldAnimateList) state.shouldAnimateList = false;
}






window.pendingImageRequests = new Map();

async function loadThumbnailImage(container) {
    if (container.classList.contains('loaded')) return;
    const imageUrl = container.dataset.imageUrl;
    const imageName = container.dataset.imageName;
    const sha = container.dataset.imageSha;
    if (!imageUrl) return;
    const getContainerFilePath = () => {
        const item = container.closest('.file-item');
        return item ? item.dataset.filePath : null;
    };
    const displayImage = (blobUrl) => {
        const img = new Image();
        img.className = 'file-thumbnail';
        img.alt = imageName;
        img.src = blobUrl;
        img.style.pointerEvents = 'none';
        img.style.webkitTouchCallout = 'none';
        img.style.userSelect = 'none';
        img.onload = () => {
            const filePath = getContainerFilePath();
            if (filePath && !state.loadedImageMap.has(filePath)) {
                state.loadedImageMap.set(filePath, blobUrl);
            }
            if (!document.body.contains(container)) {
                return;
            }
            container.innerHTML = '';
            container.appendChild(img);
            container.classList.remove('loading', 'error');
            container.classList.add('loaded');
        };
        img.onerror = () => {
             if (document.body.contains(container)) {
                container.classList.remove('loading');
                container.classList.add('error');
            }
        };
    };
    if (sha) {
        try {
            const cachedBlob = await ImagePersistence.get(sha);
            if (cachedBlob) {
                const blobUrl = URL.createObjectURL(cachedBlob);
                const filePath = getContainerFilePath();
                if (filePath) state.loadedImageMap.set(filePath, blobUrl);
                displayImage(blobUrl);
                return;
            }
        } catch (e) {}
    }
    if (window.pendingImageRequests.has(imageUrl)) {
        try {
            const blob = await window.pendingImageRequests.get(imageUrl);
            const blobUrl = URL.createObjectURL(blob);
            displayImage(blobUrl);
        } catch (e) {
            if (document.body.contains(container)) {
                container.classList.remove('loading');
                container.classList.add('error');
            }
        }
        return;
    }
    const fetchPromise = fetch(imageUrl)
        .then(async (response) => {
            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            return response.blob();
        })
        .then(async (blob) => {
            if (sha) {
                await ImagePersistence.put(sha, blob);
            }
            return blob;
        })
        .finally(() => {
            window.pendingImageRequests.delete(imageUrl);
        });
    window.pendingImageRequests.set(imageUrl, fetchPromise);
    fetchPromise
        .then((blob) => {
            const blobUrl = URL.createObjectURL(blob);
            displayImage(blobUrl);
        })
        .catch(() => {
            if (document.body.contains(container)) {
                container.classList.remove('loading');
                container.classList.add('error');
            }
        });
}


function renderImageToContainer(container, url, name, imgElement = null) {
    if (!imgElement) {
        imgElement = new Image();
        imgElement.className = 'file-thumbnail';
        imgElement.src = url;
        const lastDotIndex = name.lastIndexOf('.');
        imgElement.alt = lastDotIndex > 0 ? name.substring(0, lastDotIndex) : name;
    }
    
    container.innerHTML = '';
    container.appendChild(imgElement);
    container.classList.remove('loading', 'error');
    container.classList.add('loaded');
}

function processImagePlaceholders() {
    const placeholders = document.querySelectorAll('.file-thumbnail-container.loading');
    placeholders.forEach(container => {
        loadThumbnailImage(container);
    });
}

function renderPathNav() {
    const navContainer = el.pathNavContainer;
    navContainer.innerHTML = '';
    navContainer.style.fontSize = '0.6rem';

    const parts = state.currentPath.split('/').filter(p => p);
    let currentPathAccumulator = '';

    parts.forEach((part, index) => {
        if (index > 0) {
            const separator = document.createElement('span');
            separator.className = 'path-separator';
            separator.textContent = '/';
            navContainer.appendChild(separator);
        }
        
        currentPathAccumulator += part + '/';
        const item = document.createElement('span');
        item.className = 'path-item';
        item.textContent = part;
        item.dataset.path = currentPathAccumulator;
        item.addEventListener('click', (e) => {
            navigateToPath(e.currentTarget.dataset.path);
        });
        navContainer.appendChild(item);
    });
}

function navigateToDir(dirName) {
state.isSearchResultsView = false;
    const newPath = state.currentPath ? `${state.currentPath}${dirName}/` : `${dirName}/`;
    navigateToPath(newPath);
}

function navigateToPath(path, updateHistory = true) {
    state.shouldAnimateList = true; 
    state.currentPath = path;
    if (updateHistory) {
        const newState = {
    view: 'file_list',
    repo: state.currentRepo,
    path: path,
    branch: state.currentBranch
};
history.pushState(newState, '', `#/${state.currentRepo}/${path}`);
    }
    fetchFiles();
    renderPathNav();
}

function updateSortDropdownUI() {
    const dropdown = el.customSortDropdown;
    if (!dropdown) return;
    Array.from(dropdown.children).forEach(item => {
        const value = item.dataset.value;
        const priority = item.dataset.priority;
        if (value) {
            item.classList.toggle('selected', state.sortBy === value);
        }
        if (priority) {
            item.classList.toggle('active', state.directorySortPriority === priority);
        }
    });
}


function closeSideNav() {
    el.sideNav.classList.remove('open');
    el.mainOverlay.classList.remove('open');
}


function hideSortDropdown() {
    el.customSortDropdown.classList.add('hidden');
    const index = uiStateStack.indexOf(hideSortDropdown);
    if (index > -1) uiStateStack.splice(index, 1);
}

function showSortDropdown() {
    el.customSortDropdown.classList.remove('hidden');
    uiStateStack.push(hideSortDropdown);
}

function showEditModal() {
    el.editModal.classList.remove('hidden');
    el.editModal.classList.add('flex');
    el.editorOverlay.classList.add('show');
    setTimeout(adjustEditorDimensions, 10);
    uiStateStack.push(hideEditModal);
}

function hideEditModal() {
    toggleEditorSearch(false);
    el.editModal.classList.add('hidden');
    el.editModal.classList.remove('flex');
    state.editingFile = state.fileSha = state.originalContent = '';
    el.saveEdit.classList.remove('modified');
    const index = uiStateStack.indexOf(hideEditModal);
    if (index > -1) uiStateStack.splice(index, 1);
}

function showEditStatus(text, type) {
    el.editStatus.textContent = text;
    el.editStatus.className = `edit-status ${type}`;
}

function adjustEditorDimensions() {
    const editModal = document.getElementById('editModal');
    if (!editModal || editModal.classList.contains('hidden')) return;

    const viewportHeight = window.innerHeight;
    const screenHeight = window.screen.height;
    const isKeyboardOpen = viewportHeight < (screenHeight * 0.75);
    const isMaximized = editModal.classList.contains('maximized');
    const modalContent = editModal.querySelector('.modal-content');

    if (isMaximized) {
        modalContent.style.height = '100dvh';
        modalContent.style.width = '100vw';
        modalContent.style.borderRadius = '0';
        modalContent.style.maxHeight = 'none';
        editModal.style.padding = '0';
        editModal.style.alignItems = 'center';
    } else {
        if (isKeyboardOpen) {
            modalContent.style.height = `${viewportHeight}px`;
            modalContent.style.maxHeight = 'none';
            modalContent.style.width = '100%';
            modalContent.style.maxWidth = '100%';
            modalContent.style.borderRadius = '0';
            editModal.style.padding = '0';
            editModal.style.alignItems = 'flex-start';
        } else {
            const targetTotalHeight = viewportHeight * 0.7;
            modalContent.style.height = `${targetTotalHeight}px`;
            modalContent.style.maxHeight = '';
            modalContent.style.width = '';
            modalContent.style.maxWidth = '';
            modalContent.style.borderRadius = '';
            editModal.style.padding = '';
            editModal.style.alignItems = 'center';
        }
    }

    const headerHeight = 46;
    const footerHeight = 47;
    const currentContentHeight = modalContent.getBoundingClientRect().height;
    const editorBodyHeight = currentContentHeight - headerHeight - footerHeight;

    const editorContainer = document.querySelector('.editor-container');
    if (editorContainer) {
        editorContainer.style.height = `${Math.max(0, editorBodyHeight)}px`;
    }

    if (window.aceEditorInstance) {
        window.aceEditorInstance.resize(true);
    }
}

let aceEditorInstance = null;

// 加载 Ace 核心库
async function loadAceLibrary() {
    if (window.ace) return;
    return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.12/ace.js';
        script.onload = resolve;
        script.onerror = reject;
        document.body.appendChild(script);
    });
}

// 初始化编辑器并绑定手势
async function initAceEditor() {
    if (typeof aceEditorInstance !== 'undefined' && aceEditorInstance) {
        return aceEditorInstance;
    }
    await loadAceLibrary();
    const textarea = document.getElementById('fileContent');
    const parent = document.querySelector('.editor-container');
    if (textarea) textarea.style.display = 'none';
    let editorDiv = document.getElementById('aceEditorContainer');
    if (!editorDiv) {
        editorDiv = document.createElement('div');
        editorDiv.id = 'aceEditorContainer';
        if (parent) parent.appendChild(editorDiv);
    }
    const editor = ace.edit('aceEditorContainer');
    aceEditorInstance = editor;
    try {
        window.aceEditorInstance = editor;
    } catch (e) {}
    editor.setTheme('ace/theme/twilight');
    editor.session.setMode('ace/mode/text');
    editor.session.setUseWorker(false);
    editor.setOptions({
        fontFamily: "'Menlo', 'Monaco', 'Consolas', 'Courier New', monospace",
        wrap: true,
        indentedSoftWrap: false,
        showPrintMargin: false,
        showGutter: true,
        highlightActiveLine: true,
        tabSize: 4,
        useSoftTabs: true,
        readOnly: false,
        scrollPastEnd: 0.5,
        autoScrollEditorIntoView: true,
        fixedWidthGutter: false,
        showFoldWidgets: false,
        displayIndentGuides: true,
        animatedScroll: false,
        vScrollBarAlwaysVisible: false,
        hScrollBarAlwaysVisible: false,
        dragEnabled: false
    });
    editor.renderer.setPadding(15);
    editor.renderer.setScrollMargin(15, 15, 0, 0);
    const STORAGE_KEY = 'ace_font_size';
    let currentFontSize = parseInt(localStorage.getItem(STORAGE_KEY) || '13');
    editor.setOption('fontSize', currentFontSize + 'px');
    let initialDistance = 0;
    let startFontSize = 0;
    const container = document.getElementById('aceEditorContainer');
    container.addEventListener('touchstart', function(e) {
        if (e.touches.length === 2) {
            e.preventDefault();
            initialDistance = Math.hypot(
                e.touches[0].pageX - e.touches[1].pageX,
                e.touches[0].pageY - e.touches[1].pageY
            );
            startFontSize = parseInt(editor.getOption('fontSize')) || 13;
        }
    }, {
        passive: false
    });
    container.addEventListener('touchmove', function(e) {
        if (e.touches.length === 2 && initialDistance > 0) {
            e.preventDefault();
            const currentDistance = Math.hypot(
                e.touches[0].pageX - e.touches[1].pageX,
                e.touches[0].pageY - e.touches[1].pageY
            );
            // 1.0 是默认速度，0.5 是半速，2.0 是双倍速度
const sensitivity = 0.9; 
const rawScale = currentDistance / initialDistance;
const scale = 1 + (rawScale - 1) * sensitivity;
            const newSize = Math.max(1, Math.min(20, Math.round(startFontSize * scale)));
            const currentSize = parseInt(editor.getOption('fontSize'));
            if (newSize !== currentSize) {
                const firstRow = editor.renderer.getFirstVisibleRow();
                const lastRow = editor.renderer.getLastVisibleRow();
                const centerRow = (firstRow + lastRow) / 2;
                editor.setOption('fontSize', newSize + 'px');
                editor.renderer.updateFull();
                const newLineHeight = editor.renderer.lineHeight;
                const editorHeight = editor.renderer.getContainerElement().clientHeight;
                const newScrollTop = (centerRow * newLineHeight) - (editorHeight / 2);
                editor.session.setScrollTop(newScrollTop);
                if (typeof showEditorToast === 'function') {
                    showEditorToast(`字体大小: ${newSize}px`);
                }
                if (window.fontSaveTimer) clearTimeout(window.fontSaveTimer);
                window.fontSaveTimer = setTimeout(() => {
                    localStorage.setItem(STORAGE_KEY, newSize);
                }, 500);
            }
        }
    }, {
        passive: false
    });
    setTimeout(() => {
        editor.resize(true);
        editor.renderer.updateFull();
    }, 50);
    return editor;
}

function showEditorToast(text) {
    let toast = document.getElementById('editor-float-toast');
    if (!toast) {
        toast = document.createElement('div');
        toast.id = 'editor-float-toast';
        toast.style.cssText = 'position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); background:rgba(0,0,0,0.7); color:#fff; padding:8px 16px; border-radius:20px; font-size:14px; pointer-events:none; z-index:9999; transition:opacity 0.3s;';
        document.body.appendChild(toast);
    }
    toast.textContent = text;
    toast.style.opacity = '1';
    clearTimeout(window.editorToastTimer);
    window.editorToastTimer = setTimeout(() => {
        toast.style.opacity = '0';
    }, 1000);
}

// 根据文件名获取语言模式
function getAceMode(filename) {
    const ext = filename.split('.').pop().toLowerCase();
    const modeMap = {
        js: 'javascript', json: 'json', html: 'html', css: 'css',
        py: 'python', java: 'java', c: 'c_cpp', cpp: 'c_cpp',
        cs: 'csharp', php: 'php', go: 'golang', rs: 'rust',
        md: 'markdown', xml: 'xml', yaml: 'yaml', sql: 'sql',
        sh: 'sh', txt: 'text'
    };
    return `ace/mode/${modeMap[ext] || 'text'}`;
}

function updateEditorTheme() {
    if (!aceEditorInstance) return;
    const isLight = document.body.classList.contains('light-theme');
    aceEditorInstance.setTheme(isLight ? 'ace/theme/chrome' : 'ace/theme/twilight');
}



async function editFile(fileInput) {
    // 1. 锁定当前文件对象
    let currentFile = fileInput;
    if (state.files && state.files.length > 0) {
        const found = state.files.find(f => f.path === fileInput.path);
        if (found) currentFile = found;
    }

    // 2. 初始化 UI
    state.editingFile = currentFile;
    el.editFileName.textContent = currentFile.name;
    showEditStatus('', '');
    showEditModal();
    
    el.saveEdit.classList.remove('hidden');
    el.revertEditBtn.classList.remove('hidden');
    el.saveEdit.disabled = false;
    el.revertEditBtn.disabled = true;
    el.saveEdit.style.opacity = '0.6';
    el.editorOverlay.classList.add('show');

    try {
        await initAceEditor();
        adjustEditorDimensions();
        updateEditorTheme();
        
        const isOwner = state.user && state.viewingOwner && (state.viewingOwner.toLowerCase() === state.user.login.toLowerCase());
        
        aceEditorInstance.setReadOnly(true);
        aceEditorInstance.setValue('加载中...', -1);

        let content = null;
        let finalSha = currentFile.sha;

        // 3. 【硬核策略】检查 60秒 内的内存缓存
        // 只要路径匹配且未过期，无条件信任此数据
        const recentData = recentlySavedCache.get(currentFile.path);
        if (recentData && (Date.now() - recentData.timestamp < 60000)) {
            content = recentData.content;
            finalSha = recentData.sha;
        }

        // 4. 如果内存没命中，查 IndexedDB (基于 SHA)
        if (content === null && finalSha && window.SimpleDB) {
            try {
                const dbContent = await window.SimpleDB.get(`file_content_${finalSha}`);
                if (typeof dbContent === 'string' && dbContent.length > 0) {
                    content = dbContent;
                }
            } catch (e) {}
        }

        // 5. 还没命中，走网络 (Raw + 代理)
        if (content === null) {
            const [owner, repo] = state.currentRepo.split('/');
            const branch = state.currentBranch || 'main';
            const rawUrl = `https://raw.githubusercontent.com/${owner}/${repo}/${branch}/${currentFile.path}`;
            const fetchUrl = typeof getProxiedUrl === 'function' ? getProxiedUrl(rawUrl) : rawUrl;
            
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 10000);
                
                const res = await fetch(fetchUrl + `?t=${Date.now()}`, { 
                    cache: 'no-store',
                    signal: controller.signal
                });
                clearTimeout(timeoutId);

                if (res.ok) {
                    content = await res.text();
                } else {
                    throw new Error(`HTTP ${res.status}`);
                }
            } catch (err) {
                // 降级：走 API
                const apiRes = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${currentFile.path}?ref=${branch}`, {
                    headers: { 'Authorization': `token ${state.token}` }
                });
                if (!apiRes.ok) throw new Error('网络加载失败');
                const apiData = await apiRes.json();
                content = decodeURIComponent(escape(atob(apiData.content)));
                finalSha = apiData.sha;
            }
        }

        // 6. 渲染内容
        state.originalContent = content || '';
        state.fileSha = finalSha;
        
        const mode = getAceMode(currentFile.name);
        aceEditorInstance.session.setMode(mode);
        aceEditorInstance.setReadOnly(!isOwner);
        aceEditorInstance.setValue(state.originalContent, -1);
        aceEditorInstance.session.getUndoManager().reset();
        
        aceEditorInstance.off('change');
        aceEditorInstance.on('change', checkContentChanges);
        checkContentChanges();

        // 7. 【后台实时同步】
        // 渲染完成后，悄悄去 API 查一下最新状态，确保 SHA 一致
        performSmartSilentUpdate(currentFile, state.originalContent);

    } catch (e) {
        aceEditorInstance.setValue(`加载失败: ${e.message}`, -1);
        showEditStatus('出错', 'error');
    } finally {
        el.editorOverlay.classList.remove('show');
    }
}


async function performSmartSilentUpdate(file, currentEditorContent) {
    try {
        const [owner, repo] = state.currentRepo.split('/');
        const timestamp = Date.now();
        // 直接请求 API (Source of Truth)，不走代理
        const url = `https://api.github.com/repos/${owner}/${repo}/contents/${file.path}?ref=${state.currentBranch}&t=${timestamp}`;
        
        const res = await fetch(url, {
            headers: {
                'Authorization': `token ${state.token}`,
                'Cache-Control': 'no-cache'
            }
        });

        if (!res.ok) return;

        const data = await res.json();
        const cloudContent = decodeURIComponent(escape(atob(data.content)));

        // 场景 A: 云端内容和当前编辑器看到的一样 (最常见)
        if (cloudContent === currentEditorContent) {
            // 仅仅是 SHA 变了 (例如其他元数据变更)，悄悄更新 SHA
            if (data.sha !== state.fileSha) {
                state.fileSha = data.sha;
                // 更新全局注册表，防止下次误报冲突
                UpdatedFilesManager.set(file.path, data.sha);
            }
            return;
        }

        // 场景 B: 云端内容更新了，且用户还没开始编辑
        // 自动刷新编辑器，让用户看到最新的
        if (aceEditorInstance) {
            const currentVal = aceEditorInstance.getValue();
            // 只有当用户还没修改时，才自动覆盖
            if (currentVal === state.originalContent) {
                const cursor = aceEditorInstance.getCursorPosition();
                const scrollY = aceEditorInstance.session.getScrollTop();
                
                aceEditorInstance.setValue(cloudContent, -1);
                aceEditorInstance.moveCursorToPosition(cursor);
                aceEditorInstance.session.setScrollTop(scrollY);
                
                state.originalContent = cloudContent;
                state.fileSha = data.sha;
                
                // 同时更新 60秒 缓存，防止用户关掉重开又变回旧的
                recentlySavedCache.set(file.path, {
                    content: cloudContent,
                    timestamp: Date.now(),
                    sha: data.sha
                });
                
                // 更新 DB
                const cacheKey = `file_content_${data.sha}`;
                if (window.SimpleDB) await SimpleDB.set(cacheKey, cloudContent);

                showToast('已同步云端最新内容', 'success');
            } else {
                // 用户已经改了，弹个提示但不覆盖
                showToast('云端有新版本，因您已编辑而未自动覆盖', 'warning');
            }
        }
    } catch (e) {
        console.warn('Smart update failed', e);
    }
}



async function saveCurrentFileListToCache() {
    if (!state.currentRepo || !state.currentBranch) return;
    const cacheKey = `${state.currentRepo}:${state.currentBranch}:${state.currentPath}`;
    try {
        const existing = await SimpleDB.get(cacheKey);
        const record = {
            data: state.files,
            etag: existing ? existing.etag : null,
            timestamp: Date.now()
        };
        await SimpleDB.set(cacheKey, record);
    } catch (e) {}
}


async function backgroundSilentUpdate(file, currentDisplayedContent) {
    try {
        const [owner, repo] = state.currentRepo.split('/');
        const timestamp = Date.now();
        // 请求 API，获取云端最新状态
        const url = `https://api.github.com/repos/${owner}/${repo}/contents/${file.path}?ref=${state.currentBranch}&t=${timestamp}`;
        
        // 注意：这里去掉了 If-None-Match，为了确保能拿到最新的 content 用于预缓存
        const res = await fetch(url, {
            headers: {
                'Authorization': `token ${state.token}`
            }
        });

        if (res.status === 304) {
            return;
        }

        if (res.ok) {
            const data = await res.json();
            
            // 如果云端 SHA 与 当前编辑器里的 SHA 不一致
            if (data.sha !== state.fileSha) {
                
                const cloudContent = decodeURIComponent(escape(atob(data.content)));
                
                // 只有内容真的不同才处理（排除 SHA 变了但内容没变的情况）
                if (cloudContent !== currentDisplayedContent) {
                    
                    showToast('云端有新版本，下次打开将自动应用', 'info');

                    // 1. 【关键】立即更新文件列表中的元数据
                    // 这样下次点击文件时，editFile 就会拿到新的 SHA
                    if (state.files && state.files.length > 0) {
                        const fileIndex = state.files.findIndex(f => f.path === file.path);
                        if (fileIndex !== -1) {
                            state.files[fileIndex].sha = data.sha;
                            state.files[fileIndex].size = data.size;
                        }
                    }

                    // 2. 【关键】清除 30秒 临时缓存
                    // 确保下次打开时不走“最近保存”的旧逻辑
                    if (typeof recentlySavedCache !== 'undefined') {
                        recentlySavedCache.delete(file.path);
                    }

                    // 3. 【智能化】预先将新内容写入数据库
                    // 下次打开时，直接从 DB 读取这个新 SHA 对应的内容，无需再次请求网络
                    const newCacheKey = `file_content_${data.sha}`;
                    if (window.SimpleDB) {
                        await SimpleDB.set(newCacheKey, cloudContent);
                    }
                }
            }
        }
    } catch (e) {
        console.warn('Silent update check failed', e);
    }
}



function checkContentChanges() {
    if (!aceEditorInstance) return;
    const currentContent = aceEditorInstance.getValue();
    const isModified = currentContent !== state.originalContent;
    el.saveEdit.classList.toggle('modified', isModified);
    el.revertEditBtn.disabled = !isModified;
    el.saveEdit.style.opacity = isModified ? '1' : '0.6';
}

async function saveEditedFile() {
    if (!state.editingFile || !aceEditorInstance) {
        showToast('编辑器未初始化', 'error');
        return;
    }
    const currentContent = aceEditorInstance.getValue();
    const saveBtn = el.saveEdit;
    
    saveBtn.disabled = true;
    saveBtn.innerHTML = '<i class="fa fa-spinner fa-spin"></i>'; 
    
    try {
        const [owner, repo] = state.currentRepo.split('/');
        const encodedContent = btoa(unescape(encodeURIComponent(currentContent)));
        const url = `https://api.github.com/repos/${owner}/${repo}/contents/${state.editingFile.path}`;
        
        // 优先用 注册表 或 内存 SHA
        let shaToUse = UpdatedFilesManager.get(state.editingFile.path) || state.fileSha || state.editingFile.sha;

        const performSave = async (sha) => {
            const body = {
                message: `Update ${state.editingFile.name}`,
                content: encodedContent,
                sha: sha,
                branch: state.currentBranch
            };
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 30000);
            
            try {
                const r = await fetch(url, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `token ${state.token}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(body),
                    signal: controller.signal
                });
                clearTimeout(timeoutId);
                return r;
            } catch (err) {
                clearTimeout(timeoutId);
                throw err;
            }
        };

        let res = await performSave(shaToUse);

        // 409 自动解决
        if (res.status === 409) {
            const getRef = await fetch(url + `?ref=${state.currentBranch}`, {
                headers: { 'Authorization': `token ${state.token}`, 'Cache-Control': 'no-cache' }
            });
            if (getRef.ok) {
                const latest = await getRef.json();
                res = await performSave(latest.sha);
            }
        }

        if (!res.ok) {
            const errJson = await res.json().catch(() => ({}));
            throw new Error(errJson.message || `HTTP ${res.status}`);
        }

        const result = await res.json();
        const newSha = result.content.sha;
        const newSize = result.content.size;

        // 1. 更新内存状态
        state.fileSha = newSha;
        state.originalContent = currentContent;
        state.editingFile.sha = newSha;
        
        // 2. 【写入硬核缓存】 (1分钟内再次打开直接生效)
        recentlySavedCache.set(state.editingFile.path, {
            content: currentContent,
            timestamp: Date.now(),
            sha: newSha
        });

        // 3. 更新智能注册表
        UpdatedFilesManager.set(state.editingFile.path, newSha);

        // 4. 写入 IndexedDB (持久化)
        if (window.SimpleDB) {
            await window.SimpleDB.set(`file_content_${newSha}`, currentContent);
        }

        // 5. 更新列表
        await updateGlobalCacheState('add', {
            path: state.editingFile.path,
            type: 'file',
            sha: newSha,
            size: newSize,
            parentPath: state.currentPath
        });

        checkContentChanges();
        showToast('已保存');

    } catch (e) {
        showToast('保存失败: ' + e.message, 'error');
    } finally {
        saveBtn.disabled = false;
        saveBtn.innerHTML = '<i class="fa-solid fa-check"></i>';
    }
}




async function downloadReleaseAsset(asset) {
    showToast(`正在准备下载: ${asset.name}`);

    let downloadUrl = asset.browser_download_url;

    if (state.proxyGlobalEnable && state.proxies.length > 0 && state.activeProxyIndex !== -1) {
        const activeProxy = state.proxies[state.activeProxyIndex];
        if (activeProxy && activeProxy.url && activeProxy.type === 'prefix') {
            let proxyBase = activeProxy.url;
            if (!proxyBase.endsWith('/')) {
                proxyBase += '/';
            }
            downloadUrl = proxyBase + downloadUrl;
        }
    }

    try {
        const a = document.createElement('a');
        a.href = downloadUrl;
        a.download = asset.name;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);

    } catch (error) {
        showToast(`下载 "${asset.name}" 失败，请检查浏览器设置`, 'error');
        console.error(error);
    }
}




function hideMainMenuPopup() {
    
    const mainMenuPopup = document.getElementById('mainMenuPopup');
    if (mainMenuPopup) {
        mainMenuPopup.classList.add('hidden');
    }
}

async function downloadFile(item) {
    if (item.type === 'dir') {
        return;
    }

    const fileExtension = item.name.split('.').pop()?.toLowerCase();
    
    const previewExtensions = [
        'png', 'jpg', 'jpeg', 'gif', 'webp', 'bmp', 'svg', 'ico',
        'mp4', 'webm', 'mp3', 'ogg', 'wav', 'mov', 'mkv'
    ];
    
    if (previewExtensions.includes(fileExtension)) {
        const raw = item.download_url ? item.download_url : item.html_url.replace('github.com', 'raw.githubusercontent.com').replace('/blob/', '/');
        const url = typeof getProxiedUrl === 'function' ? getProxiedUrl(raw) : raw;

        if (['mp4', 'webm', 'ogg', 'mov', 'avi', 'mkv'].includes(fileExtension)) {
            const preview = document.getElementById('mediaPreview');
            const video = document.getElementById('mediaPreviewVideo');
            const img = document.getElementById('mediaPreviewImg');
            
            if (window.globalAudioManager) window.globalAudioManager.stop();
            
            video.src = url;
            video.style.display = 'block';
            img.style.display = 'none';
            preview.classList.remove('hidden');
            if (window.uiStateStack) window.uiStateStack.push(hideMediaPreview);
            video.load();
            video.play().catch(() => {});
            return;
        }

        if (['mp3', 'wav', 'flac', 'm4a'].includes(fileExtension)) {
            const nameWithoutExt = item.name.substring(0, item.name.lastIndexOf('.'));
            if (window.globalAudioManager) window.globalAudioManager.toggle(url, nameWithoutExt);
            return;
        }

        if (['png', 'jpg', 'jpeg', 'gif', 'webp', 'ico', 'bmp', 'svg'].includes(fileExtension)) {
            const preview = document.getElementById('mediaPreview');
            const img = document.getElementById('mediaPreviewImg');
            const video = document.getElementById('mediaPreviewVideo');
            
            img.src = url;
            img.style.display = 'block';
            video.style.display = 'none';
            preview.classList.remove('hidden');
            if (window.uiStateStack) window.uiStateStack.push(hideMediaPreview);
            return;
        }
    }

    try {
        const rawUrl = (item.download_url) 
            ? item.download_url 
            : item.html_url.replace('github.com', 'raw.githubusercontent.com').replace('/blob/', '/');
        
        const finalUrl = typeof getProxiedUrl === 'function' ? getProxiedUrl(rawUrl) : rawUrl;

        if (typeof showToast === 'function') showToast(`正在请求下载: ${item.name}`);

        const a = document.createElement('a');
        a.href = finalUrl;
        a.download = item.name; 
        a.style.display = 'none';
        document.body.appendChild(a);
        
        a.click();
        
        setTimeout(() => {
            document.body.removeChild(a);
        }, 100);

    } catch (e) {
        if (typeof showToast === 'function') showToast(`下载出错: ${e.message}`, 'error');
        console.error(e);
    }
}
function copyLink(file) {
    const rawUrl = file.download_url || file.html_url.replace('github.com', 'raw.githubusercontent.com').replace('/blob/', '/');
    navigator.clipboard.writeText(rawUrl).then(() => {
        showToast('Raw 链接已复制');
    }).catch(e => {
        showToast(`复制失败: ${e.message || '应用剪切板权限没给'}`);
        console.error(e);
    });
}

function copyProxyLink(file) {
    const rawUrl = file.download_url || 
                   file.html_url.replace('github.com', 'raw.githubusercontent.com').replace('/blob/', '/');

    const activeProxy = (state.proxies && state.activeProxyIndex >= 0 && state.activeProxyIndex < state.proxies.length) 
                        ? state.proxies[state.activeProxyIndex] 
                        : null;

    const isProxyEffective = state.proxyGlobalEnable && activeProxy && activeProxy.url;

    if (isProxyEffective) {
        let proxyBase = activeProxy.url.trim();
        if (!proxyBase.endsWith('/')) {
            proxyBase += '/';
        }
        
        const finalUrl = proxyBase + rawUrl;

        navigator.clipboard.writeText(finalUrl).then(() => {
            let domain = '';
            try {
                domain = new URL(proxyBase).hostname;
            } catch (e) {
                domain = '代理';
            }
            showToast(`已复制代理链接 [节点: ${domain}]`);
        }).catch(e => {
            showToast(`复制失败: ${e.message}`, 'error');
        });
    } else {
        navigator.clipboard.writeText(rawUrl).then(() => {
            showToast('代理未生效，已复制直连链接', 'warning');
        }).catch(e => {
            showToast(`复制失败: ${e.message}`, 'error');
        });
    }
}

function positionContextMenu(e, menuWidth, menuHeight) {
    let clickX, clickY;
    if (e.touches && e.touches.length > 0) {
        clickX = e.touches[0].clientX;
        clickY = e.touches[0].clientY;
    } else {
        clickX = e.clientX;
        clickY = e.clientY;
    }
    const offsetX = 30;
    const offsetY = 30;
    let leftPos = clickX + offsetX;
    let topPos = clickY + offsetY;
    const windowWidth = window.innerWidth;
    const windowHeight = window.innerHeight;
    if (leftPos + menuWidth > windowWidth) {
        leftPos = clickX - menuWidth - offsetX;
    }
    if (topPos + menuHeight > windowHeight) {
        topPos = clickY - menuHeight - offsetY;
    }
    if (leftPos < 0) leftPos = 5;
    if (topPos < 0) topPos = 5;
    return { top: topPos, left: leftPos };
}

function renderContextMenuItems(file) {
    el.contextMenuItems.innerHTML = '';
    const isDir = file.type === 'dir';
    const category = isDir ? 'folder' : 'file';
    const fileExtension = file.name.split('.').pop()?.toLowerCase();

    const currentLogin = state.user ? state.user.login : localStorage.getItem('cached_user_login');
    const [owner, repoName] = state.currentRepo.split('/');
    const isMainSiteRepo = repoName.toLowerCase() === `${owner.toLowerCase()}.github.io`;
    
    // 尝试获取仓库详细信息以判断是否开启了Pages（如果缓存中有）
    const currentRepoObject = state.repos.find(repo => repo.full_name === state.currentRepo);

    const visibleItems = CONTEXT_MENU_DEFINITIONS[category].filter(item => {
        if (item.action === 'goToDirectory' && !state.isSearchResultsView) {
            return false;
        }

        const isOwner = currentLogin && owner.toLowerCase() === currentLogin.toLowerCase();
        if (!isOwner && ['edit', 'rename', 'delete', 'unzip'].includes(item.action)) {
            return false;
        }
        
        if (item.action === 'unzip' && !ZIP_EXTS.includes(fileExtension)) {
            return false;
        }
        
        if (item.action === 'copyPagesLink') {
            // 如果是主站仓库，无条件显示（主站通常都默认开启Pages或者是为了预览）
            if (isMainSiteRepo) return true;
            // 如果是普通仓库，检查是否开启了Pages
            if (currentRepoObject && !currentRepoObject.has_pages) return false;
        }

        if (item.action === 'copyCustomDomainLink') {
            return currentRepoObject && !!currentRepoObject.customDomain;
        }
        
        return state.contextMenuVisibility[category][item.action];
    });

    visibleItems.forEach(({ action, icon, text, className = '' }) => {
        const item = document.createElement('a');
        item.className = `context-menu-item ${className}`;
        item.dataset.action = action;
        
        // --- 核心修改：动态修改按钮文字 ---
        if (action === 'copyPagesLink' && isMainSiteRepo) {
            text = '主站链接';
        }
        // -------------------------------
        
        item.innerHTML = `<i class="fa ${icon} mr-2"></i>${text}`;
        item.addEventListener('click', () => {
            handleContextMenuAction(action, state.selectedFile);
            hideContextMenu();
        });
        el.contextMenuItems.appendChild(item);
    });
}
function showContextMenu(e, file) {
    state.selectedFile = file;
    const menu = el.contextMenu;
    menu.style.opacity = '0';
    menu.style.transform = 'scale(0.8)';
    menu.classList.remove('hidden');
    renderContextMenuItems(file);
    const menuWidth = menu.offsetWidth;
    const menuHeight = menu.offsetHeight;
    const position = positionContextMenu(e, menuWidth, menuHeight);
    menu.style.top = `${position.top}px`;
    menu.style.left = `${position.left}px`;
    let start = null, duration = 150;
    function animate(timestamp) {
        if (!start) start = timestamp;
        const progress = Math.min((timestamp - start) / duration, 1);
        menu.style.opacity = progress.toString();
        menu.style.transform = `scale(${0.8 + 0.2 * progress})`;
        if (progress < 1) requestAnimationFrame(animate);
    }
    requestAnimationFrame(animate);
    uiStateStack.push(hideContextMenu);
}

async function showRepoContextMenu(e, repo) {
    state.selectedRepo = repo;
    const menu = el.contextMenu;
    menu.style.opacity = '0';
    menu.style.transform = 'scale(0.8)';
    menu.classList.remove('hidden');
    await renderRepoContextMenuItems(repo);
    const menuWidth = menu.offsetWidth;
    const menuHeight = menu.offsetHeight;
    const position = positionContextMenu(e, menuWidth, menuHeight);
    menu.style.top = `${position.top}px`;
    menu.style.left = `${position.left}px`;
    let start = null, duration = 150;
    function animate(timestamp) {
        if (!start) start = timestamp;
        const progress = Math.min((timestamp - start) / duration, 1);
        menu.style.opacity = progress.toString();
        menu.style.transform = `scale(${0.8 + 0.2 * progress})`;
        if (progress < 1) requestAnimationFrame(animate);
    }
    requestAnimationFrame(animate);
    uiStateStack.push(hideContextMenu);
}

async function renderRepoContextMenuItems(repo) {
    el.contextMenuItems.innerHTML = '';
    const isMainSiteRepo = state.user && repo.name === `${state.user.login}.github.io`;
    const isPublished = repo.has_pages;
    const pinnedRepos = JSON.parse(localStorage.getItem('pinned_repos') || '[]');
    const isPinned = pinnedRepos.includes(repo.id);
    const isOwner = state.user && repo.owner.login.toLowerCase() === state.user.login.toLowerCase();

    const visibleItems = CONTEXT_MENU_DEFINITIONS.repo.filter(item => {
        if (!state.contextMenuVisibility.repo[item.action]) {
            return false;
        }

        if (isOwner) {
            const disallowedActionsForOwner = ['forkRepo', 'unstarRepo', 'viewUserRepos'];
            if (disallowedActionsForOwner.includes(item.action)) {
                return false;
            }
        } else {
            const disallowedActionsForOthers = ['togglePin', 'renameRepo', 'createBranch', 'deleteRepo'];
            if (disallowedActionsForOthers.includes(item.action)) {
                return false;
            }
        }
        
if (item.action === 'viewUserRepos') {
            
            return !isOwner && state.currentView !== 'other_user_repos';
        }
        
        if (item.action === 'unstarRepo') {
             return state.currentView === 'starred_repos';
        }

        if (item.action === 'copyMainSiteLink') {
            return isMainSiteRepo;
        }
        if (item.action === 'copyProjectSiteLink') {
            return isPublished && !isMainSiteRepo;
        }
        if (item.action === 'copyCustomDomainLink') {
            return !!repo.customDomain;
        }
        return true;
    });

    visibleItems.forEach(({ action, icon, text, className = '' }) => {
        const item = document.createElement('a');
        item.className = `context-menu-item ${className}`;
        item.dataset.action = action;
        
        if (action === 'togglePin') {
            text = isPinned ? '取消置顶' : '置顶';
        }
        
        item.innerHTML = `<i class="fa ${icon} mr-2"></i>${text}`;
        item.addEventListener('click', () => {
            handleRepoContextMenuAction(action, state.selectedRepo);
            hideContextMenu();
        });
        el.contextMenuItems.appendChild(item);
    });
}

const hideContextMenu = () => {
    if (isContextMenuClosing) return; 
    const menu = el.contextMenu;
    if (menu.classList.contains('hidden')) return;

    isContextMenuClosing = true;

    let start = null,
        duration = 150;
    function animate(timestamp) {
        if (!start) start = timestamp;
        const progress = Math.min((timestamp - start) / duration, 1);
        menu.style.opacity = (1 - progress).toString();
        menu.style.transform = `scale(${1 - 0.2 * progress})`;
        if (progress < 1) {
            requestAnimationFrame(animate);
        } else {
            menu.classList.add('hidden');
            state.selectedFile = null;
            state.selectedRepo = null;
            isContextMenuClosing = false; 
        }
    }
    requestAnimationFrame(animate);
    const index = uiStateStack.indexOf(hideContextMenu);
    if (index > -1) uiStateStack.splice(index, 1);
};



async function updateGlobalCacheState(action, itemData) {
    const { path, newPath, type, sha, size, parentPath } = itemData;
    const [owner, repo] = state.currentRepo.split('/');
    const branch = state.currentBranch;
    const now = new Date().toISOString();

    // 辅助构造完整的 Mock 文件对象
    const createMockFile = (filePath, fileType, fileSha, fileSize) => {
        const fileName = filePath.split('/').pop();
        return {
            name: fileName,
            path: filePath,
            type: fileType === 'tree' ? 'dir' : 'file',
            sha: fileSha || 'pending-' + Date.now(), // 临时SHA
            size: fileSize || 0,
            url: `https://api.github.com/repos/${owner}/${repo}/contents/${filePath}?ref=${branch}`,
            html_url: `https://github.com/${owner}/${repo}/blob/${branch}/${filePath}`,
            git_url: `https://api.github.com/repos/${owner}/${repo}/git/blobs/${fileSha}`,
            download_url: `https://raw.githubusercontent.com/${owner}/${repo}/${branch}/${filePath}`,
            last_modified: now // 伪造最后修改时间，方便排序
        };
    };

    if (action === 'delete') {
        ConsistencyManager.add({ type: 'delete', path: path });
    } 
    else if (action === 'add') {
        const mockFile = createMockFile(path, type, sha, size);
        ConsistencyManager.add({ 
            type: 'add', 
            file: mockFile,
            parentPath: parentPath 
        });
    } 
    else if (action === 'rename') {
        const newName = newPath.split('/').pop();
        let newParent = newPath.includes('/') ? newPath.substring(0, newPath.lastIndexOf('/')) : '';
        // 保持父路径格式一致性（带/）
        if (newParent && !newParent.endsWith('/')) newParent += '/';

        const mockFile = createMockFile(newPath, type, sha, size);
        
        ConsistencyManager.add({ 
            type: 'rename', 
            oldPath: path, 
            newParentPath: newParent,
            newFile: mockFile
        });
    }

    // 更新 Tree Cache (用于 Tree 模式加速)
    if (state.repoTreeCache) {
        const isDir = type === 'dir' || type === 'tree';
        
        if (action === 'delete') {
            if (isDir) {
                const folderPrefix = path.endsWith('/') ? path : path + '/';
                state.repoTreeCache = state.repoTreeCache.filter(i => 
                    i.path !== path && !i.path.startsWith(folderPrefix)
                );
            } else {
                state.repoTreeCache = state.repoTreeCache.filter(i => i.path !== path);
            }
        } 
        else if (action === 'add') {
            const exists = state.repoTreeCache.some(i => i.path === path);
            if (!exists) {
                state.repoTreeCache.push({
                    path: path,
                    mode: isDir ? '040000' : '100644',
                    type: isDir ? 'tree' : 'blob',
                    sha: sha || null,
                    size: size || 0,
                    url: '' 
                });
                state.repoTreeCache.sort((a, b) => {
                    if (a.type !== b.type) return a.type === 'tree' ? -1 : 1;
                    return a.path.localeCompare(b.path);
                });
            }
        }
        else if (action === 'rename') {
            const oldPrefix = path + '/';
            const newPrefix = newPath + '/';
            state.repoTreeCache.forEach(node => {
                if (node.path === path) {
                    node.path = newPath;
                } else if (isDir && node.path.startsWith(oldPrefix)) {
                    node.path = newPrefix + node.path.substring(oldPrefix.length);
                }
            });
        }

        try {
            const treeKey = `full_tree_cache:${state.currentRepo}:${state.currentBranch}`;
            await SimpleDB.set(treeKey, { tree: state.repoTreeCache, timestamp: Date.now() });
        } catch (e) {}
    }

    // 更新当前列表视图缓存（内存 + DB）
    let targetPath = action === 'rename' ? itemData.path : (itemData.path || '');
    let computedParentPath = '';
    
    if (action === 'add' && itemData.parentPath !== undefined) {
        computedParentPath = itemData.parentPath;
    } else {
        if (targetPath.endsWith('/')) targetPath = targetPath.slice(0, -1);
        const lastSlash = targetPath.lastIndexOf('/');
        computedParentPath = lastSlash > -1 ? targetPath.substring(0, lastSlash + 1) : '';
    }

    await modifyParentCache(computedParentPath, action, itemData);

    // 递归清理子目录缓存
    if (action === 'rename' || action === 'delete') {
        const cacheKeyPrefix = `${state.currentRepo}:${state.currentBranch}:`;
        let cleanupPath = itemData.path;
        if (cleanupPath && !cleanupPath.endsWith('/')) cleanupPath += '/';
        
        const keys = await SimpleDB.keys();
        const targetPrefix = cacheKeyPrefix + cleanupPath;
        for (const key of keys) {
            if (key.startsWith(targetPrefix)) {
                state.fileCache.delete(key);
                await SimpleDB.del(key);
            }
        }
    }
}

async function modifyParentCache(parentPath, action, itemData) {
    const cacheKey = `${state.currentRepo}:${state.currentBranch}:${parentPath}`;
    
    let currentList = null;
    if (state.fileCache.has(cacheKey)) {
        currentList = state.fileCache.get(cacheKey);
    } else {
        try {
            const dbRecord = await SimpleDB.get(cacheKey);
            if (dbRecord && Array.isArray(dbRecord.data)) {
                currentList = dbRecord.data;
            }
        } catch (e) {}
    }

    if (!currentList) return;

    let listCopy = [...currentList];
    const { path, newPath, sha, size, type } = itemData;
    const fileName = (newPath || path).split('/').pop();
    
    if (action === 'delete') {
        listCopy = listCopy.filter(f => f.path !== path);
    } 
    else if (action === 'add') {
        const exists = listCopy.some(f => f.path === path);
        if (!exists) {
            const [owner, repo] = state.currentRepo.split('/');
            const branch = state.currentBranch;
            listCopy.push({
                name: fileName,
                path: path,
                type: type === 'tree' ? 'dir' : 'file',
                sha: sha || 'temp-sha',
                size: size || 0,
                html_url: `https://github.com/${owner}/${repo}/blob/${branch}/${path}`,
                url: `https://api.github.com/repos/${owner}/${repo}/contents/${path}?ref=${branch}`,
                download_url: `https://raw.githubusercontent.com/${owner}/${repo}/${branch}/${path}`,
                last_modified: new Date().toISOString()
            });
        }
    } 
    else if (action === 'rename') {
        const index = listCopy.findIndex(f => f.path === path);
        if (index > -1) {
            listCopy[index] = {
                ...listCopy[index],
                name: fileName,
                path: newPath,
                sha: sha || listCopy[index].sha,
                last_modified: new Date().toISOString()
            };
        }
    }

    state.fileCache.set(cacheKey, listCopy);
    
    try {
        const existingRecord = await SimpleDB.get(cacheKey);
        await SimpleDB.set(cacheKey, {
            data: listCopy,
            etag: existingRecord ? existingRecord.etag : null, 
            timestamp: Date.now()
        });
    } catch (e) {}

    if (state.currentPath === parentPath) {
        state.files = listCopy;
        state.shouldAnimateList = false;
        applyFiltersAndSort();
        renderFileList();
        updateActionBar(); 
    }
}



async function deleteSingleItem(item) {
    const [owner, repo] = state.currentRepo.split('/');
    
    const deleteFileAPI = async (path, sha) => {
        const res = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${path}`, {
            method: 'DELETE',
            headers: { Authorization: `token ${state.token}`, 'Content-Type': 'application/json' },
            body: JSON.stringify({ message: `Delete ${item.name}`, sha: sha, branch: state.currentBranch })
        });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
    };

    const getRecursiveFiles = async (path) => {
        let results = [];
        const res = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${path}?ref=${state.currentBranch}`, { 
            headers: { Authorization: `token ${state.token}` } 
        });
        const data = await res.json();
        if (Array.isArray(data)) {
            for (const f of data) {
                if (f.type === 'dir') {
                    results = results.concat(await getRecursiveFiles(f.path));
                } else {
                    results.push(f);
                }
            }
        }
        return results;
    };

    try {
        if (item.type === 'dir') {
            const allFiles = await getRecursiveFiles(item.path);
            for (const f of allFiles.reverse()) {
                await deleteFileAPI(f.path, f.sha);
            }
        } else {
            await deleteFileAPI(item.path, item.sha);
        }

        await updateGlobalCacheState('delete', { 
            path: item.path, 
            type: item.type 
        });

        state.selectedItems.delete(item.path);
        
    } catch (error) {
        showToast(`删除失败: ${error.message}`, 'error');
        await fetchFiles(true);
    }
}





async function updateCacheAfterDelete(path, isDir) {
    if (state.repoTreeCache) {
        if (isDir) {
            const folderPrefix = path.endsWith('/') ? path : path + '/';
            state.repoTreeCache = state.repoTreeCache.filter(item => 
                item.path !== path && !item.path.startsWith(folderPrefix)
            );
        } else {
            state.repoTreeCache = state.repoTreeCache.filter(item => item.path !== path);
        }
        
        try {
            const cacheKey = `full_tree_cache:${state.currentRepo}:${state.currentBranch}`;
            const cachedData = await SimpleDB.get(cacheKey);
            if (cachedData) {
                cachedData.tree = state.repoTreeCache;
                cachedData.timestamp = Date.now();
                await SimpleDB.set(cacheKey, cachedData);
            }
        } catch (e) {
            console.error(e);
        }
    }

    const currentDirKey = `${state.currentRepo}:${state.currentBranch}:${state.currentPath}`;
    if (state.fileCache.has(currentDirKey)) {
        let files = state.fileCache.get(currentDirKey);
        files = files.filter(f => f.path !== path);
        state.fileCache.set(currentDirKey, files);
        
        try {
            await SimpleDB.set(currentDirKey, {
                data: files,
                timestamp: Date.now()
            });
        } catch (e) {}
    }
}


async function handleContextMenuAction(action, oldFileObject) {
    let currentFile;

    if (state.isSearchResultsView) {
        currentFile = oldFileObject;
    } else {
        currentFile = state.files.find(f => f.path === oldFileObject.path);
        if (!currentFile) {
            showToast('文件已更新，请重新选择或刷新页面');
            return;
        }
    }

    switch (action) {
        case 'goToDirectory':
            if (currentFile.repository) {
                const repoFullName = currentFile.repository.full_name;
                
                try {
                    const res = await fetch(`https://api.github.com/repos/${repoFullName}`, {
                        headers: { Authorization: `token ${state.token}` }
                    });
                    if (!res.ok) throw new Error('无法获取仓库详情');
                    
                    const fullRepoData = await res.json();
                    
                    const path = currentFile.path;
                    let dirPath = path.substring(0, path.lastIndexOf('/'));
                    if (dirPath) {
                        dirPath += '/';
                    }
                    
                    navigateToRepo(fullRepoData, fullRepoData.default_branch, dirPath);

                } catch (error) {
                    showToast(`跳转失败: ${error.message}`, 'error');
                }
            }
            break;
    
        case 'rename':
            if (state.isSearchResultsView) {
                try {
                    const repoRes = await fetch(`https://api.github.com/repos/${state.currentRepo}`, {
                        headers: { Authorization: `token ${state.token}` }
                    });
                    if (!repoRes.ok) throw new Error('无法获取仓库详情');
                    const repoData = await repoRes.json();
                    
                    state.currentBranch = repoData.default_branch;
                    
                    showRenameModal(currentFile);
                } catch (error) {
                    showToast(`操作失败: ${error.message}`, 'error');
                }
            } else {
                showRenameModal(currentFile);
            }
            break;
        
        case 'copyPagesLink':
            const [owner, repoName] = state.currentRepo.split('/');
            // --- 核心修改：判断主站并生成不同链接 ---
            const isMainSiteRepo = repoName.toLowerCase() === `${owner.toLowerCase()}.github.io`;
            
            // 主站链接：https://user.github.io/file.html
            // 项目链接：https://user.github.io/repo/file.html
            const pagesUrl = isMainSiteRepo
                ? `https://${owner}.github.io/${currentFile.path}`
                : `https://${owner}.github.io/${repoName}/${currentFile.path}`;

            navigator.clipboard.writeText(pagesUrl).then(() => {
                showToast(isMainSiteRepo ? '主站链接已复制' : '项目网站链接已复制');
            }).catch(e => {
                showToast(`复制失败: ${e.message || '应用剪切板权限没给'}`);
            });
            break;

        case 'copyCustomDomainLink': {
            const currentRepoObject = state.repos.find(repo => repo.full_name === state.currentRepo);
            if (currentRepoObject && currentRepoObject.customDomain) {
                const customUrl = `https://${currentRepoObject.customDomain}/${currentFile.path}`;
                navigator.clipboard.writeText(customUrl).then(() => {
                    showToast(`自定义域名复制成功: ${customUrl}`);
                }).catch(e => {
                    showToast(`复制失败: ${e.message}`);
                });
            }
            break;
        }
        case 'unzip':
            unzipFile(currentFile);
            break;

        case 'delete':
            showDeleteModal(currentFile);
            break;
            
        case 'multiSelect':
            toggleMultiSelectMode(true);
            state.selectedItems.add(currentFile.path);
            renderFileList();
            updateActionBar();
            break;
        case 'download':
            downloadFile(currentFile);
            break;
        case 'downloadFolder':
            downloadFolderAsZip(currentFile);
            break;
        case 'copyLink':
            copyLink(currentFile);
            break;
        case 'copyProxy':
            copyProxyLink(currentFile);
            break;
        case 'copyGitHubLink':
            navigator.clipboard.writeText(currentFile.html_url).then(() => {
                showToast('GitHub 链接已复制');
            }).catch(e => {
                showToast(`复制失败: ${e.message || '应用剪切板权限没给'}`);
                console.error(e);
            });
            break;
        case 'edit':
            if (state.isSearchResultsView) {
                showToast('正在获取仓库信息...', 'info');
                try {
                    const repoRes = await fetch(`https://api.github.com/repos/${state.currentRepo}`, {
                        headers: { Authorization: `token ${state.token}` }
                    });
                    if (!repoRes.ok) throw new Error('无法获取仓库详情');
                    const repoData = await repoRes.json();
                    
                    state.currentBranch = repoData.default_branch;
                    
                    editFile(currentFile);
                } catch (error) {
                    showToast(`操作失败: ${error.message}`, 'error');
                }
            } else {
                editFile(currentFile);
            }
            break;
    }
}

async function handleRepoContextMenuAction(action, repo) {
    const isMainSiteRepo = state.user && repo.name === `${state.user.login}.github.io`;

    switch (action) {
        case 'viewDetails':
            // [修改] 统一使用新版概览卡片
            showRepoOverview(repo);
            break;
            
        case 'manageReleases':
    fetchAndDisplayReleases(repo.full_name);
    break;

        case 'togglePin': {
            const pinnedRepos = JSON.parse(localStorage.getItem('pinned_repos') || '[]');
            const repoId = repo.id;
            const index = pinnedRepos.indexOf(repoId);

            if (index > -1) {
                pinnedRepos.splice(index, 1);
                showToast(`仓库 "${repo.name}" 已取消置顶`);
            } else {
                pinnedRepos.push(repoId);
                showToast(`仓库 "${repo.name}" 已置顶`);
            }

            localStorage.setItem('pinned_repos', JSON.stringify(pinnedRepos));
            renderRepoList(state.currentView === 'own_repos' ? state.repos : state.starredRepos);
            break;
        }
       case 'forkRepo':
            showForkRepoModal(repo);
            break;
        
        case 'unstarRepo':
            showDeleteModal(
                null,
                false,
                '确认取消关注',
                `确定要取消关注仓库 "${escapeHtml(repo.name)}" 吗？`,
                async () => {
                    try {
                        const res = await fetch(`https://api.github.com/user/starred/${repo.full_name}`, {
                            method: 'DELETE',
                            headers: { 'Authorization': `token ${state.token}` }
                        });

                        if (!res.ok) {
                            throw new Error(`操作失败 (HTTP ${res.status})`);
                        }

                        showToast(`已取消关注 "${escapeHtml(repo.name)}"`);

                        state.starredRepos = state.starredRepos.filter(r => r.id !== repo.id);
                        localStorage.setItem('cached_starred_repos', JSON.stringify(state.starredRepos));
                        renderRepoList(state.starredRepos);

                    } catch (e) {
                        showToast(`取消关注失败: ${e.message}`, 'error');
                    }
                },
                '确认取消',
                'btn-danger'
            );
            break;

        case 'viewUserRepos':
            fetchAndDisplayUserRepos(repo.owner.login);
            break;

        case 'copyProjectSiteLink':
            const siteUrl = `https://${repo.owner.login}.github.io/${repo.name}/`;
            navigator.clipboard.writeText(siteUrl).then(() => {
                showToast('项目网站链接已复制', 'success');
            }).catch(err => {
                showToast('复制失败', 'error');
            });
            break;
        case 'copyMainSiteLink':
            const mainSiteUrl = `https://${repo.owner.login}.github.io/`;
            navigator.clipboard.writeText(mainSiteUrl).then(() => {
                showToast('主站链接已复制', 'success');
            }).catch(err => {
                showToast('复制失败', 'error');
            });
            break;
       
        case 'copyCustomDomainLink':
            if (repo.customDomain) {
                const customUrl = `https://${repo.customDomain}`;
                navigator.clipboard.writeText(customUrl).then(() => {
                    showToast(`自定义域名复制成功: ${customUrl}`);
                }).catch(err => {
                    showToast('复制失败', 'error');
                });
            }
            break;
        case 'copyRepoGitHubLink':
            navigator.clipboard.writeText(repo.html_url).then(() => showToast('仓库链接已复制'));
            break;
        case 'createBranch':
            showCreateBranchModal(repo);
            break;

        case 'downloadRepoDirect':
            downloadRepoAsZip(repo, false);
            break;
        case 'renameRepo':
            showRenameModal(repo);
            break;
        case 'deleteRepo':
            showDeleteModal(null, false, '确认删除仓库', `确定要删除仓库 "${repo.name}" 吗？此操作不可撤销！`, async () => {
                try {
                    const res = await fetch(`https://api.github.com/repos/${repo.full_name}`, {
                        method: 'DELETE',
                        headers: { 'Authorization': `token ${state.token}` }
                    });

                    if (!res.ok) {
                        if (res.status === 403) {
                             throw new Error('权限不足，请确认令牌已勾选 delete_repo 权限');
                        }
                        throw new Error((await res.json()).message || '删除失败');
                    }
                    
                    showToast(`仓库 "${repo.name}" 已成功删除`);
                    
                    await fetchRepos(true, true);

                } catch (e) {
                    showToast(`删除失败: ${e.message}`, 'error');
                }
            });
            break;
    }
}

async function batchUnpublishSites() {
    const reposToUnpublish = state.repos.filter(r => r.has_pages && r.name !== `${state.user.login}.github.io`);

    if (reposToUnpublish.length === 0) {
        showToast('没有需要取消发布的网站。', 'info');
        return;
    }

    el.batchUnpublishAllBtn.disabled = true;
    el.batchUnpublishAllBtn.classList.add('btn-processing');

    let successCount = 0;
    
    for (const [index, repo] of reposToUnpublish.entries()) {
        showToast(`正在取消发布 (${index + 1}/${reposToUnpublish.length}): ${repo.name}`);
        const result = await unpublishSite(repo);
        if (result.success) {
            const repoInState = state.repos.find(r => r.id === repo.id);
            if (repoInState) {
                repoInState.has_pages = false;
            }
            successCount++;
        }
    }

    renderPublishManagerLists();

    el.batchUnpublishAllBtn.classList.remove('btn-processing');
    showToast(`批量取消发布完成！共处理 ${successCount} 个。`, 'success');
}

async function batchPublishSites() {
    const reposToPublish = state.repos.filter(r => !r.private && r.name !== `${state.user.login}.github.io` && !r.has_pages);

    if (reposToPublish.length === 0) {
        showToast('没有可发布的仓库。', 'info');
        return;
    }

    el.batchPublishAllBtn.disabled = true;
    el.batchPublishAllBtn.classList.add('btn-processing');
    
    let successCount = 0;
    let failCount = 0;

    for (const [index, repo] of reposToPublish.entries()) {
        showToast(`正在发布 (${index + 1}/${reposToPublish.length}): ${repo.name}`);
        const result = await publishProjectSite(repo);
        if (result.success) {
            const repoInState = state.repos.find(r => r.id === repo.id);
            if (repoInState) {
                repoInState.has_pages = true;
            }
            successCount++;
        } else {
            failCount++;
        }
    }
    
    renderPublishManagerLists();
    
    el.batchPublishAllBtn.classList.remove('btn-processing');
    showToast(`批量发布完成！成功 ${successCount} 个，失败 ${failCount} 个。`, 'success');
}

function findNextAvailableBackupName() {
    let maxNum = 0;
    const prefix = 'Github----';
    state.repos.forEach(repo => {
        if (repo.name.startsWith(prefix)) {
            const numPart = repo.name.substring(prefix.length);
            if (/^\d+$/.test(numPart)) {
                const num = parseInt(numPart, 10);
                if (num > maxNum) {
                    maxNum = num;
                }
            }
        }
    });
    return `${prefix}${maxNum + 1}`;
}

let repoToSetAsSite = null;
let branchToPublish = null;

function hideSetAsSiteModal() {
    el.setAsSiteModal.classList.add('hidden');
    repoToSetAsSite = null;
    branchToPublish = null;
    const index = uiStateStack.indexOf(hideSetAsSiteModal);
    if (index > -1) uiStateStack.splice(index, 1);
}



const ImagePersistence = {
    DB_NAME: 'GitHubRepoImageCache',
    STORE_NAME: 'images_by_sha',
    EXPIRATION_MS: 30 * 24 * 60 * 60 * 1000, 
    dbPromise: null,

    init() {
        if (!this.dbPromise) {
            this.dbPromise = new Promise((resolve, reject) => {
                const request = indexedDB.open(this.DB_NAME, 1);
                request.onupgradeneeded = (e) => {
                    const db = e.target.result;
                    if (!db.objectStoreNames.contains(this.STORE_NAME)) {
                        db.createObjectStore(this.STORE_NAME, { keyPath: 'sha' });
                    }
                };
                request.onsuccess = (e) => {
                    const db = e.target.result;
                    resolve(db);
                    this.cleanup(db);
                };
                request.onerror = (e) => reject(e);
            });
        }
        return this.dbPromise;
    },

    

    async get(sha) {
        if (!sha) return null;
        try {
            const db = await this.init();
            return new Promise((resolve) => {
                const tx = db.transaction(this.STORE_NAME, 'readwrite');
                const store = tx.objectStore(this.STORE_NAME);
                const req = store.get(sha);
                
                req.onsuccess = () => {
                    const result = req.result;
                    if (result) {
                        resolve(result.blob);
                        result.timestamp = Date.now();
                        store.put(result);
                    } else {
                        resolve(null);
                    }
                };
                req.onerror = () => resolve(null);
            });
        } catch (e) {
            return null;
        }
    },



async cleanup(db) {
        if (!db) return;
        try {
            const tx = db.transaction(this.STORE_NAME, 'readwrite');
            const store = tx.objectStore(this.STORE_NAME);
            const req = store.openCursor();
            const now = Date.now();

            req.onsuccess = (e) => {
                const cursor = e.target.result;
                if (cursor) {
                    const record = cursor.value;
                    if (now - record.timestamp > this.EXPIRATION_MS) {
                        cursor.delete();
                    }
                    cursor.continue();
                }
            };
        } catch (e) {}
    },


    async put(sha, blob) {
        if (!sha || !blob) return;
        try {
            const db = await this.init();
            return new Promise((resolve, reject) => {
                const tx = db.transaction(this.STORE_NAME, 'readwrite');
                const store = tx.objectStore(this.STORE_NAME);
                const req = store.put({ sha, blob, timestamp: Date.now() });
                req.onsuccess = () => resolve();
                req.onerror = (e) => reject(e);
            });
        } catch (e) {}
    }
};


async function disablePages(repo) {
    try {
        // 使用 PATCH 更新仓库设置，这是禁用Pages更可靠的方法
        const res = await fetch(`https://api.github.com/repos/${repo.full_name}`, {
            method: 'PATCH',
            headers: {
                'Authorization': `token ${state.token}`,
                'Content-Type': 'application/json'
            },
            // 直接在仓库设置中关闭 has_pages 开关
            body: JSON.stringify({
                has_pages: false 
            })
        });

        if (!res.ok) {
            const errorData = await res.json().catch(() => ({}));
            const errorMessage = errorData.message || `禁用 Pages 失败 (HTTP ${res.status})`;
            throw new Error(errorMessage);
        }

        // 成功禁用后，立即更新本地缓存的仓库状态
        const repoInState = state.repos.find(r => r.id === repo.id);
        if (repoInState) {
            repoInState.has_pages = false;
        }

        return { success: true };

    } catch (error) {
        console.error(`禁用仓库 ${repo.name} 的 Pages 失败:`, error);
        // 将错误向上抛出，以便主流程能捕获并提示用户
        throw error;
    }
}




async function waitForRepoRename(oldRepoFullName, timeout = 30000) {
    const startTime = Date.now();
    const pollInterval = 2000;
    const [owner, oldRepoName] = oldRepoFullName.split('/');

    while (Date.now() - startTime < timeout) {
        await fetchRepos(true, false);
        const repoStillExists = state.repos.some(r => r.name === oldRepoName && r.owner.login === owner);
        if (!repoStillExists) {
            return true;
        }
        await new Promise(resolve => setTimeout(resolve, pollInterval));
    }
    throw new Error('等待旧主站重命名确认超时');
}



async function fetchSingleRepoState(repoFullName) {
    try {
        const res = await fetch(`https://api.github.com/repos/${repoFullName}`, {
            headers: { Authorization: `token ${state.token}`, 'User-Agent': 'Mozilla/5.0' },
            cache: 'no-store'
        });
        if (!res.ok) {
            throw new Error(`无法获取仓库信息: ${res.status}`);
        }
        return await res.json();
    } catch (error) {
        console.error(`获取仓库 ${repoFullName} 状态失败:`, error);
        showToast(`更新仓库 ${repoFullName.split('/')[1]} 状态失败`, 'error');
        return null;
    }
}

function updateSingleRepoInStateAndUI(updatedRepoObject) {
    if (!updatedRepoObject) return;

    const index = state.repos.findIndex(r => r.id === updatedRepoObject.id);
    if (index > -1) {
        const existingRepo = state.repos[index];
        updatedRepoObject.customDomain = existingRepo.customDomain;
        
        state.repos[index] = updatedRepoObject;
    } else {
        state.repos.unshift(updatedRepoObject);
    }
    
    localStorage.setItem('cached_repos', JSON.stringify(state.repos));
    
    if (!el.publishManagerModal.classList.contains('hidden')) {
        renderPublishManagerLists();
    }
    if (!el.repoList.classList.contains('hidden')) {
        
    }
}





async function showPublishBranchSelectorModal(repo, publishType) {
    repoToSetAsSite = repo;
    branchToPublish = repo.default_branch;

    const modalTitle = el.setAsSiteModal.querySelector('.modal-title-text');
    modalTitle.textContent = (publishType === 'mainSite') ? '发布主网站' : '发布项目网站';

    el.setAsSiteModal.classList.remove('hidden');
    uiStateStack.push(hideSetAsSiteModal);

    const selectorWrapper = document.getElementById('setAsSiteBranchSelector');
    const triggerText = selectorWrapper.querySelector('span');
    const optionsPanel = selectorWrapper.querySelector('.custom-branch-select-options');
    const confirmBtn = el.setAsSiteConfirmBtn;

    triggerText.textContent = '加载分支中...';
    optionsPanel.innerHTML = '';
    confirmBtn.disabled = true;

    try {
        const res = await fetch(`https://api.github.com/repos/${repo.full_name}/branches`, {
            headers: { Authorization: `token ${state.token}` }
        });
        if (!res.ok) throw new Error('获取分支列表失败');
        
        const branches = (await res.json()).reverse();
        if (branches.length === 0) {
            triggerText.textContent = '无可用分支';
            return;
        }

        confirmBtn.disabled = false;
        triggerText.textContent = branchToPublish;

        branches.forEach(branch => {
            const option = document.createElement('div');
            option.className = 'custom-branch-select-option';
            if (branch.name === branchToPublish) option.classList.add('selected');
            option.textContent = branch.name;
            option.dataset.branchName = branch.name;
            option.addEventListener('click', () => {
                branchToPublish = branch.name;
                triggerText.textContent = branch.name;
                const currentSelected = optionsPanel.querySelector('.selected');
                if (currentSelected) currentSelected.classList.remove('selected');
                option.classList.add('selected');
                selectorWrapper.classList.remove('open');
            });
            optionsPanel.appendChild(option);
        });
    } catch (error) {
        triggerText.textContent = '加载失败';
        showToast(error.message);
    }

    confirmBtn.onclick = async () => {
        const repoToProcess = repoToSetAsSite;
        const branchToUse = branchToPublish;
        if (!repoToProcess || !branchToUse) return;

        hideSetAsSiteModal();

        if (publishType === 'projectSite') {
            const buttonInManager = document.querySelector(`.project-action-btn[data-repo-fullname="${repoToProcess.full_name}"]`);
            if (buttonInManager) {
                buttonInManager.textContent = '处理中...';
                buttonInManager.disabled = true;
            }
            const result = await publishProjectSite(repoToProcess, branchToUse);
            showToast(result.message, result.success ? 'success' : 'error');
            if (result.success) {
                const repoInState = state.repos.find(r => r.id === repoToProcess.id);
                if (repoInState) repoInState.has_pages = true;
            }
            renderPublishManagerLists();
        } else if (publishType === 'mainSite') {
            const mainSiteButton = document.querySelector(`.set-as-main-site-btn[data-repo-fullname="${repoToProcess.full_name}"]`);
            if (mainSiteButton) {
                mainSiteButton.textContent = '处理中...';
                mainSiteButton.disabled = true;
            }
            
            el.mainLoader.classList.remove('hidden');
            const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));

            async function enablePagesWithRetry(repo, branch, maxAttempts = 2, delayBetweenAttempts = 4000) {
                for (let attempt = 1; attempt <= maxAttempts; attempt++) {
                    showToast(`正在配置网站页面`, 'info');
                    try {
                        const pagesRes = await fetch(`https://api.github.com/repos/${repo.full_name}/pages`, {
                            method: 'POST',
                            headers: { 'Authorization': `token ${state.token}`, 'Content-Type': 'application/json' },
                            body: JSON.stringify({ source: { branch: branch, path: "/" } })
                        });

                        if (pagesRes.ok || pagesRes.status === 409) {
                            return { success: true };
                        }
                        
                        const updateRes = await fetch(`https://api.github.com/repos/${repo.full_name}/pages`, {
                            method: 'PUT',
                            headers: { 'Authorization': `token ${state.token}`, 'Content-Type': 'application/json' },
                            body: JSON.stringify({ source: { branch: branch, path: "/" } })
                        });
                        
                        if (updateRes.ok) {
                            return { success: true };
                        }

                        if (attempt < maxAttempts) {
                            await delay(delayBetweenAttempts);
                            continue;
                        }
                        
                        throw new Error(`API错误: ${updateRes.status}`);

                    } catch (error) {
                        if (attempt >= maxAttempts) {
                            throw error;
                        }
                        await delay(delayBetweenAttempts);
                    }
                }
                 throw new Error('配置网站失败');
            }

            const MAX_SETUP_ATTEMPTS = 3;
            let finalError = null;

            for (let setupAttempt = 1; setupAttempt <= MAX_SETUP_ATTEMPTS; setupAttempt++) {
                try {
                    showToast(`正在设置主站 (第 ${setupAttempt}/${MAX_SETUP_ATTEMPTS} 次)`, 'info', 7000);
                    const mainSiteName = `${state.user.login}.github.io`;
                    await fetchRepos(true, false);
                    const existingMainSite = state.repos.find(r => r.name === mainSiteName);
                    
                    if (existingMainSite && existingMainSite.id !== repoToProcess.id) {
                        if (existingMainSite.has_pages) {
                            await disablePages(existingMainSite);
                        }
                        const backupName = findNextAvailableBackupName();
                        await fetch(`https://api.github.com/repos/${existingMainSite.full_name}`, {
                            method: 'PATCH', headers: { 'Authorization': `token ${state.token}`, 'Content-Type': 'application/json' },
                            body: JSON.stringify({ name: backupName })
                        });
                    }
                    
                    if (repoToProcess.name !== mainSiteName) {
                        await fetch(`https://api.github.com/repos/${repoToProcess.full_name}`, {
                            method: 'PATCH', headers: { 'Authorization': `token ${state.token}`, 'Content-Type': 'application/json' },
                            body: JSON.stringify({ name: mainSiteName })
                        });
                    }
                    
                    await delay(6000);
                    await fetchRepos(true, false);
                    const finalRepoToPublish = state.repos.find(r => r.name === mainSiteName);

                    if (!finalRepoToPublish) {
                         throw new Error('主站信息同步失败');
                    }
                    
                    const result = await enablePagesWithRetry(finalRepoToPublish, branchToUse);

                    if (!result.success) {
                        throw new Error('配置网站失败，请稍后在GitHub官网手动开启Pages');
                    }

                    showToast('主站发布成功！', 'success');
                    await delay(2000);
                    finalError = null;
                    break;

                } catch (e) {
                    finalError = e;
                    if (setupAttempt < MAX_SETUP_ATTEMPTS) {
                        showToast(`${e.message}，自动重试中`, 'info');
                        await delay(1000);
                    }
                }
            }

            if (finalError) {
                 showToast(`操作最终失败: ${finalError.message}，请手动重试`, 'error');
                 if (mainSiteButton) {
                     mainSiteButton.textContent = '发布为主站';
                     mainSiteButton.disabled = false;
                 }
            }
            
            await fetchRepos(true, false);
            el.mainLoader.classList.add('hidden');
            renderPublishManagerLists();
        }
    };
}








let uploadClickTimer = null;
let uploadClickCount = 0;

function handleUploadClick() {
    if (!state.currentRepo) {
        showToast('请先选择仓库');
        return;
    }
    showPreUploadModal();
}

function handleFilesSelected(e) {
    const files = Array.from(e.target.files || []);
    if (files.length === 0) return;

    // 统一逻辑：只添加到暂存区，不立即上传
    state.pendingUploadFiles = [...state.pendingUploadFiles, ...files];
    renderPreUploadList();
    
    // 如果面板没打开，打开它
    if (el.preUploadModal.classList.contains('hidden')) {
        showPreUploadModal();
    }
    
    e.target.value = ''; 
}


async function uploadReleaseAssets(files) {
    if (!state.currentRelease || !state.viewingReleasesForRepo) return;
    
    const releaseId = state.currentRelease.id;
    const [owner, repo] = state.viewingReleasesForRepo.split('/');
    
    showToast(`准备上传 ${files.length} 个文件到版本 ${state.currentRelease.tag_name}...`);

    for (const file of files) {
        try {
            showToast(`正在上传: ${file.name} ...`, 'info', 5000);
            
            const uploadUrl = `https://uploads.github.com/repos/${owner}/${repo}/releases/${releaseId}/assets?name=${encodeURIComponent(file.name)}`;
            
            const res = await fetch(uploadUrl, {
                method: 'POST',
                headers: {
                    'Authorization': `token ${state.token}`,
                    'Content-Type': file.type || 'application/octet-stream'
                },
                body: file
            });

            if (!res.ok) {
                if (res.status === 422) {
                    throw new Error('文件可能已存在或格式不支持');
                }
                throw new Error(`HTTP ${res.status}`);
            }

            showToast(`${file.name} 上传成功!`, 'success');
        } catch (e) {
            console.error(e);
            showToast(`上传 ${file.name} 失败: ${e.message}`, 'error');
        }
    }

    await refreshAssetsList();
}

// --- 新增：显示上传面板 ---
function showPreUploadModal() {
    // 每次打开不自动清空，保留上次未上传的？还是清空？这里设为不清空，如果为空则显示空状态
    renderPreUploadList();
    el.preUploadModal.classList.remove('hidden');
    uiStateStack.push(hidePreUploadModal);
}

function hidePreUploadModal() {
    el.preUploadModal.classList.add('hidden');
    const index = uiStateStack.indexOf(hidePreUploadModal);
    if (index > -1) uiStateStack.splice(index, 1);
    
    state.pendingUploadFiles = [];
    renderPreUploadList();
}

// --- 新增：渲染待上传列表 ---
function renderPreUploadList() {
    const container = el.preUploadList;
    container.innerHTML = '';

    if (state.pendingUploadFiles.length === 0) {
        container.innerHTML = `
            <div class="empty-state" style="padding: 20px; text-align: center; color: #9ca3af;">
                <i class="fa fa-cloud-upload" style="font-size: 2rem; margin-bottom: 10px;"></i>
                <p style="font-size: 0.8rem;">暂无待上传文件</p>
            </div>`;
        el.preUploadStartBtn.disabled = true;
        return;
    }

    el.preUploadStartBtn.disabled = false;

    state.pendingUploadFiles.forEach((file, index) => {
        const div = document.createElement('div');
        div.className = 'pre-upload-item';
        div.innerHTML = `
            <span class="pre-upload-name" title="${file.name}">${file.name}</span>
            <div style="display:flex; align-items:center;">
                <span class="pre-upload-size">${formatSize(file.size)}</span>
                <button class="btn-icon-sm danger remove-pending-btn" data-index="${index}">
                    <i class="fa fa-times"></i>
                </button>
            </div>
        `;
        container.appendChild(div);
    });

    // 绑定删除按钮事件
    container.querySelectorAll('.remove-pending-btn').forEach(btn => {
        btn.onclick = (e) => {
            const idx = parseInt(e.currentTarget.dataset.index);
            state.pendingUploadFiles.splice(idx, 1);
            renderPreUploadList();
        };
    });
}

function handleStartBatchUpload() {
    if (state.pendingUploadFiles.length === 0) return;

    const filesToUpload = [...state.pendingUploadFiles];
    hidePreUploadModal();
    state.pendingUploadFiles = [];

    el.uploadPanel.classList.remove('hidden');
    el.uploadItems.innerHTML = '';

    filesToUpload.forEach((file, index) => {
        let displayName = file.name;
        if (displayName.length > 25) displayName = displayName.slice(0, 22) + '...';
        
        const uploadItem = document.createElement('div');
        uploadItem.className = 'upload-item';
        uploadItem.innerHTML = `
            <div class="upload-info">
                <span class="upload-name" title="${file.name}">${displayName}</span>
                <span class="upload-size">${formatSize(file.size)}</span>
            </div>
            <div class="upload-progress-container">
                <div class="upload-progress" data-index="${index}">
                    <span class="percent-text" data-index="${index}">0%</span>
                </div>
            </div>
            <div class="upload-status" data-index="${index}">等待中...</div>
        `;
        el.uploadItems.appendChild(uploadItem);
    });

    const total = filesToUpload.length;
    
    const runSequence = async (idx) => {
        if (idx >= total) {
            setTimeout(() => el.uploadPanel.classList.add('hidden'), 1000);
            showToast('所有文件上传完成', 'success');
            
            if (state.files) {
                const patched = ConsistencyManager.apply(state.files);
                state.files = patched;
                applyFiltersAndSort();
                renderFileList();
            }
            return;
        }

        showToast(`正在上传 (${idx + 1}/${total}): ${filesToUpload[idx].name}`, 'loading', 0);

        try {
            if (state.currentView === 'assets_list') {
                await uploadSingleReleaseAsset(filesToUpload[idx], idx);
            } else {
                await uploadSingleFile(filesToUpload[idx], idx);
            }
        } catch (e) {
            console.error(e);
        }
        
        await runSequence(idx + 1);
    };

    runSequence(0);
}


async function uploadReleaseAssetsInSequence(files, index) {
    if (index >= files.length) {
        setTimeout(() => {
            el.uploadPanel.classList.add('hidden');
        }, 500);
        await refreshAssetsList();
        return;
    }

    const file = files[index];
    try {
        await uploadSingleReleaseAsset(file, index);
    } catch (error) {
        console.error(error);
    }
    
    await uploadReleaseAssetsInSequence(files, index + 1);
}

async function uploadSingleReleaseAsset(file, index) {
    return new Promise((resolve, reject) => {
        const progressBar = document.querySelector(`.upload-progress[data-index="${index}"]`);
        const statusElement = document.querySelector(`.upload-status[data-index="${index}"]`);
        const percentTextEl = progressBar ? progressBar.querySelector(`.percent-text[data-index="${index}"]`) : null;

        // 1. 基础校验
        if (!state.currentRelease) {
            if (statusElement) {
                statusElement.textContent = '错误：无版本信息';
                statusElement.className = 'upload-status error';
            }
            resolve();
            return;
        }

        if (file.size === 0) {
            if (statusElement) {
                statusElement.textContent = '错误：空文件';
                statusElement.className = 'upload-status error';
            }
            resolve();
            return;
        }

        if (statusElement) statusElement.textContent = '读取文件中...';

        // 2. 使用 FileReader 读取文件流 (解决跨域和文件占用问题)
        const reader = new FileReader();
        
        reader.onload = function(e) {
            // 文件读取成功，开始上传
            const arrayBuffer = e.target.result;
            
            // 3. 构建 URL (手动拼接最稳妥)
            let uploadUrl = '';
            try {
                const rawUrl = state.currentRelease.upload_url.split('{')[0];
                // 使用 encodeURIComponent 确保中文文件名不报错
                uploadUrl = `${rawUrl}?name=${encodeURIComponent(file.name)}`;
            } catch (err) {
                if (statusElement) statusElement.textContent = 'URL生成失败';
                resolve();
                return;
            }

            if (statusElement) statusElement.textContent = '开始传输...';

            const xhr = new XMLHttpRequest();
            xhr.open('POST', uploadUrl, true);

            // 4. 设置关键请求头
            xhr.setRequestHeader('Authorization', `token ${state.token}`);
            xhr.setRequestHeader('Content-Type', file.type || 'application/octet-stream');
            // 加上 Accept 头，防止 GitHub API 拒绝
            xhr.setRequestHeader('Accept', 'application/vnd.github.v3+json');

            // 5. 监听进度
            xhr.upload.onprogress = (evt) => {
                if (evt.lengthComputable) {
                    const percentComplete = Math.round((evt.loaded / evt.total) * 100);
                    if (progressBar) progressBar.style.width = `${percentComplete}%`;
                    if (percentTextEl) percentTextEl.textContent = `${percentComplete}%`;
                    
                    if (statusElement) {
                        statusElement.textContent = percentComplete < 100 ? `上传中 ${percentComplete}%` : '服务器处理中...';
                    }
                }
            };

            // 6. 请求完成处理
            xhr.onload = () => {
                if (xhr.status >= 200 && xhr.status < 300) {
                    if (progressBar) progressBar.style.width = '100%';
                    if (percentTextEl) percentTextEl.textContent = '100%';
                    if (statusElement) {
                        statusElement.textContent = '上传成功';
                        statusElement.className = 'upload-status success';
                    }
                    // 成功后延迟移除 UI
                    setTimeout(() => {
                        const itemContainer = statusElement ? statusElement.closest('.upload-item') : null;
                        if (itemContainer) {
                            itemContainer.style.transition = 'opacity 0.5s ease';
                            itemContainer.style.opacity = '0';
                            setTimeout(() => itemContainer.remove(), 500);
                        }
                    }, 1000);
                    resolve();
                } else {
                    // 解析错误信息
                    let errorMsg = `HTTP ${xhr.status}`;
                    try {
                        const json = JSON.parse(xhr.responseText);
                        if (json.errors && json.errors[0]?.code === 'already_exists') {
                            errorMsg = '文件已存在';
                        } else if (json.message) {
                            errorMsg = json.message;
                        }
                    } catch (ignore) {
                        if (xhr.responseText && xhr.responseText.length < 100) errorMsg = xhr.responseText;
                    }
                    
                    if (statusElement) {
                        statusElement.textContent = errorMsg;
                        statusElement.className = 'upload-status error';
                        statusElement.title = errorMsg;
                        if (progressBar) progressBar.style.backgroundColor = '#ef4444';
                    }
                    resolve();
                }
            };

            // 7. 网络错误处理
            xhr.onerror = () => {
                if (statusElement) {
                    statusElement.textContent = '网络中断';
                    statusElement.className = 'upload-status error';
                    statusElement.title = '无法连接到 GitHub 上传服务器，请检查网络或 VPN';
                    if (progressBar) progressBar.style.backgroundColor = '#ef4444';
                }
                resolve();
            };

            // 发送 ArrayBuffer 二进制数据
            xhr.send(arrayBuffer);
        };

        reader.onerror = function() {
            if (statusElement) {
                statusElement.textContent = '读取文件失败';
                statusElement.className = 'upload-status error';
            }
            resolve();
        };

        // 开始读取文件
        reader.readAsArrayBuffer(file);
    });
}


function arrayBufferToBase64(buffer) {
    let binary = '';
    const bytes = new Uint8Array(buffer);
    const len = bytes.byteLength;
    for (let i = 0; i < len; i++) {
        binary += String.fromCharCode(bytes[i]);
    }
    return btoa(binary);
}

async function renameWithGitDataAPI(item, newName) {
    const [owner, repo] = state.currentRepo.split('/');
    const oldPath = item.path;
    const newPath = oldPath.substring(0, oldPath.lastIndexOf('/') + 1) + newName;
    const refResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/git/refs/heads/${state.currentBranch}`, {
        headers: { 'Authorization': `token ${state.token}` }
    });
    if (!refResponse.ok) throw new Error('无法获取分支信息');
    const refData = await refResponse.json();
    const latestCommitSha = refData.object.sha;
    const commitResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/git/commits/${latestCommitSha}`, {
        headers: { 'Authorization': `token ${state.token}` }
    });
    if (!commitResponse.ok) throw new Error('无法获取提交信息');
    const commitData = await commitResponse.json();
    const baseTreeSha = commitData.tree.sha;
    const createTreeResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/git/trees`, {
        method: 'POST',
        headers: { 'Authorization': `token ${state.token}`, 'Content-Type': 'application/json' },
        body: JSON.stringify({
            base_tree: baseTreeSha,
            tree: [
                { path: newPath, mode: '100644', type: 'blob', sha: item.sha },
                { path: oldPath, mode: '100644', type: 'blob', sha: null }
            ]
        })
    });
    if (!createTreeResponse.ok) throw new Error('创建新目录树失败');
    const treeData = await createTreeResponse.json();
    const newTreeSha = treeData.sha;
    const createCommitResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/git/commits`, {
        method: 'POST',
        headers: { 'Authorization': `token ${state.token}`, 'Content-Type': 'application/json' },
        body: JSON.stringify({
            message: `Rename ${item.name} to ${newName}`,
            tree: newTreeSha,
            parents: [latestCommitSha]
        })
    });
    if (!createCommitResponse.ok) throw new Error('创建新提交失败');
    const newCommitData = await createCommitResponse.json();
    const newCommitSha = newCommitData.sha;
    const updateRefResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/git/refs/heads/${state.currentBranch}`, {
        method: 'PATCH',
        headers: { 'Authorization': `token ${state.token}`, 'Content-Type': 'application/json' },
        body: JSON.stringify({ sha: newCommitSha })
    });
    if (!updateRefResponse.ok) throw new Error('更新分支引用失败');
}

async function renameFolderWithGitDataAPI(item, newName) {
    const [owner, repo] = state.currentRepo.split('/');
    const oldPath = item.path;
    const newPath = oldPath.substring(0, oldPath.lastIndexOf('/') + 1) + newName;
    const refResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/git/refs/heads/${state.currentBranch}`, {
        headers: { 'Authorization': `token ${state.token}` }
    });
    if (!refResponse.ok) throw new Error('无法获取分支信息');
    const refData = await refResponse.json();
    const latestCommitSha = refData.object.sha;
    const commitResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/git/commits/${latestCommitSha}`, {
        headers: { 'Authorization': `token ${state.token}` }
    });
    if (!commitResponse.ok) throw new Error('无法获取提交信息');
    const commitData = await commitResponse.json();
    const baseTreeSha = commitData.tree.sha;
    const createTreeResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/git/trees`, {
        method: 'POST',
        headers: { 'Authorization': `token ${state.token}`, 'Content-Type': 'application/json' },
        body: JSON.stringify({
            base_tree: baseTreeSha,
            tree: [
                { path: newPath, mode: '040000', type: 'tree', sha: item.sha },
                { path: oldPath, mode: '040000', type: 'tree', sha: null }
            ]
        })
    });
    if (!createTreeResponse.ok) throw new Error('创建新目录树失败');
    const treeData = await createTreeResponse.json();
    const newTreeSha = treeData.sha;
    const createCommitResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/git/commits`, {
        method: 'POST',
        headers: { 'Authorization': `token ${state.token}`, 'Content-Type': 'application/json' },
        body: JSON.stringify({
            message: `Rename ${item.name} to ${newName}`,
            tree: newTreeSha,
            parents: [latestCommitSha]
        })
    });
    if (!createCommitResponse.ok) throw new Error('创建新提交失败');
    const newCommitData = await createCommitResponse.json();
    const newCommitSha = newCommitData.sha;
    const updateRefResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/git/refs/heads/${state.currentBranch}`, {
        method: 'PATCH',
        headers: { 'Authorization': `token ${state.token}`, 'Content-Type': 'application/json' },
        body: JSON.stringify({ sha: newCommitSha })
    });
    if (!updateRefResponse.ok) throw new Error('更新分支引用失败');
}









function showUnpublishMainSiteModal(repo) {
    const extraSettingsContainer = document.getElementById('renameModalExtraSettings');
    extraSettingsContainer.innerHTML = ''; 

    el.renameTitle.querySelector('.modal-title-text').textContent = '取消发布主网站';

    el.renameWarn.innerHTML = '此操作会先禁用网站的静态页面配置，然后将仓库重命名，从而安全地下线。您的所有文件都会被保留。';
    el.renameWarn.classList.remove('text-red-400');
    el.renameWarn.style.color = '';
    el.renameWarn.style.fontSize = '0.7rem';
    el.renameWarn.style.marginBottom = '0.6rem';
    el.renameWarn.style.display = 'block';

    el.renameInput.value = '';
    el.renameInput.placeholder = '请输入新的仓库名';
    
    el.renameConfirm.disabled = true;
    el.renameModal.classList.remove('hidden');

    el.renameInput.oninput = function() {
        const newName = el.renameInput.value.trim();
        el.renameConfirm.disabled = !newName || newName === repo.name;
    };

    el.renameConfirm.onclick = async function() {
        const newName = el.renameInput.value.trim();
        if (!newName) return;

        this.disabled = true;
        this.classList.add('btn-processing');
        this.innerHTML = '处理中 <i class="fa fa-spinner fa-spin"></i>';

        try {
            showToast('步骤1/2: 正在禁用静态页面配置...');
            await disablePages(repo);
            
            showToast('步骤2/2: 正在重命名仓库以完成下线...');
            const res = await fetch(`https://api.github.com/repos/${repo.full_name}`, {
                method: 'PATCH',
                headers: { 'Authorization': `token ${state.token}`, 'Content-Type': 'application/json' },
                body: JSON.stringify({ name: newName })
            });
            if (!res.ok) throw new Error((await res.json()).message || '重命名失败');
            
            showToast('主网站已成功下线');
            hideRenameModal();
            await fetchRepos(true, false);
            renderPublishManagerLists();

        } catch (e) {
            showToast(`操作失败: ${e.message}`, 'error');
        } finally {
            this.disabled = false;
            this.classList.remove('btn-processing');
            this.innerHTML = '确认';
        }
    };

    uiStateStack.push(hideRenameModal);
}




function showRenameModal(item) {
    const isRepo = typeof item.full_name === 'string';
    const extraSettingsContainer = document.getElementById('renameModalExtraSettings');
    extraSettingsContainer.innerHTML = '';
    el.renameWarn.textContent = '';
    el.renameWarn.style.display = 'none';
    el.renameInput.value = isRepo ? item.name : item.name;
    el.renameConfirm.disabled = true;
    el.renameModal.classList.remove('hidden');

    if (isRepo) {
        el.renameTitle.querySelector('.modal-title-text').textContent = '修改仓库';
        const settingsHTML = `
            <textarea id="newRepoDesc" placeholder="仓库描述（可选）" style="margin-top: 0.6rem;">${item.description || ''}</textarea>
            <div class="checkbox-container" style="margin: 0.6rem 0;">
                <input type="checkbox" id="newRepoPrivate">
                <label for="newRepoPrivate">公开仓库</label>
            </div>
        `;
        extraSettingsContainer.innerHTML = settingsHTML;
        
        const descTextarea = document.getElementById('newRepoDesc');
        const privateCheckbox = document.getElementById('newRepoPrivate');
        privateCheckbox.checked = !item.private;

        const updateRepoBtnState = () => {
            const newName = el.renameInput.value.trim();
            const newDesc = descTextarea.value.trim();
            const visibilityChanged = privateCheckbox.checked === item.private;
            const nameChanged = newName !== item.name;
            const descChanged = newDesc !== (item.description || '');
            
            el.renameConfirm.disabled = !(nameChanged || descChanged || visibilityChanged) || !newName;
        };

        el.renameInput.oninput = updateRepoBtnState;
        descTextarea.oninput = updateRepoBtnState;
        privateCheckbox.onchange = updateRepoBtnState;

        el.renameConfirm.onclick = async function() {
            const newName = el.renameInput.value.trim();
            const newDesc = descTextarea.value.trim();
            const isPrivate = !privateCheckbox.checked;
            
            this.disabled = true;
            this.classList.add('btn-processing');
            this.innerHTML = '<i class="fa fa-spinner fa-spin"></i>';

            try {
                const res = await fetch(`https://api.github.com/repos/${item.full_name}`, {
                    method: 'PATCH',
                    headers: { 'Authorization': `token ${state.token}`, 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name: newName, description: newDesc, private: isPrivate })
                });
                if (!res.ok) throw new Error((await res.json()).message || '修改失败');
                
                showToast('保存成功');
                hideRenameModal();
                await fetchRepos(true, true);
            } catch (e) {
                showToast(`修改失败: ${e.message}`, 'error');
            } finally {
                if (document.body.contains(this)) {
                    this.disabled = false;
                    this.classList.remove('btn-processing');
                    this.innerHTML = '确认';
                }
            }
        };

    } else {
        el.renameTitle.querySelector('.modal-title-text').textContent = '重命名';
        
        el.renameInput.oninput = function() {
            const val = this.value.trim();
            el.renameConfirm.disabled = !val || val === item.name;
        };

        el.renameConfirm.onclick = async function() {
            const newName = el.renameInput.value.trim();
            if (!newName || newName === item.name) return;

            this.disabled = true;
            this.classList.add('btn-processing');
            this.innerHTML = '<i class="fa fa-spinner fa-spin"></i>';

            try {
                if (item.type === 'branch') {
                    const res = await fetch(`https://api.github.com/repos/${item.repo.full_name}/branches/${item.name}/rename`, { 
                        method: 'POST', 
                        headers: { 'Authorization': `token ${state.token}`, 'Content-Type': 'application/json' }, 
                        body: JSON.stringify({ new_name: newName }) 
                    });
                    if (!res.ok) throw new Error('重命名分支失败');
                    hideRenameModal();
                    hideCreateBranchModal();
                    showToast('分支重命名成功');
                    if (state.currentRepo === item.repo.full_name) {
                        await fetchBranches(item.repo);
                    }
                } else {
                    const isDir = item.type === 'dir';
                    
                    if (isDir) {
                        await renameFolderWithGitDataAPI(item, newName);
                    } else {
                        if (item.size > 1024 * 1024) {
                            await renameWithGitDataAPI(item, newName);
                        } else {
                            const [owner, repo] = state.currentRepo.split('/');
                            const fileData = await (await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${item.path}?ref=${state.currentBranch}`, { 
                                headers: { Authorization: `token ${state.token}` } 
                            })).json();
                            
                            const oldPath = item.path;
                            const parentPath = oldPath.includes('/') ? oldPath.substring(0, oldPath.lastIndexOf('/')) : '';
                            const newPath = parentPath ? `${parentPath}/${newName}` : newName;

                            const putRes = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${newPath}`, { 
                                method: 'PUT', 
                                headers: { Authorization: `token ${state.token}`, 'Content-Type': 'application/json' }, 
                                body: JSON.stringify({ message: `Rename to ${newName}`, content: fileData.content, branch: state.currentBranch }) 
                            });
                            
                            if (!putRes.ok) throw new Error('创建新文件失败');

                            const putData = await putRes.json();

                            await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${oldPath}`, { 
                                method: 'DELETE', 
                                headers: { Authorization: `token ${state.token}`, 'Content-Type': 'application/json' }, 
                                body: JSON.stringify({ message: `Delete old`, sha: fileData.sha, branch: state.currentBranch }) 
                            });

                            const newItemSha = putData.content ? putData.content.sha : null;
                            const newItemSize = putData.content ? putData.content.size : item.size;

                            await updateGlobalCacheState('rename', {
                                path: oldPath,
                                newPath: newPath,
                                type: item.type,
                                sha: newItemSha,
                                size: newItemSize
                            });
                        }
                    }

                    if (isDir || item.size > 1024 * 1024) {
                        const oldPath = item.path;
                        const parent = oldPath.includes('/') ? oldPath.substring(0, oldPath.lastIndexOf('/')) : '';
                        const newPath = parent ? `${parent}/${newName}` : newName;

                        await updateGlobalCacheState('rename', {
                            path: oldPath,
                            newPath: newPath,
                            type: item.type
                        });
                    }
                    
                    hideRenameModal();
                    showToast('重命名成功');
                }
            } catch (e) {
                showToast(`失败: ${e.message}`, 'error');
            } finally {
                if (document.body.contains(this)) {
                    this.disabled = false;
                    this.classList.remove('btn-processing');
                    this.innerHTML = '确认';
                }
            }
        };
    }

    uiStateStack.push(hideRenameModal);
}



function hideCreateFolderModal() {
    el.createFolderModal.classList.add('hidden');
    const index = uiStateStack.indexOf(hideCreateFolderModal);
    if (index > -1) uiStateStack.splice(index, 1);
}

function showCreateFolderModal() {
    el.createFolderInput.value = '';
    el.createFolderModal.classList.remove('hidden');
    el.createFolderConfirm.disabled = true;
    
    el.createFolderConfirm.onclick = async function() {
        const name = el.createFolderInput.value.trim();
        if (!name || el.createFolderConfirm.classList.contains('btn-processing')) return;
        
        el.createFolderConfirm.classList.add('btn-processing');
        el.createFolderConfirm.innerHTML = '创建中 <i class="fa fa-spinner fa-spin"></i>';
        
        try {
            const [owner, repo] = state.currentRepo.split('/');
            const folderPath = state.currentPath ? `${state.currentPath}${name}` : name;
            const filePath = `${folderPath}/.gitkeep`;
            
            const res = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${filePath}`, {
                method: 'PUT',
                headers: { Authorization: `token ${state.token}`, 'Content-Type': 'application/json', 'User-Agent': 'Mozilla/5.0' },
                body: JSON.stringify({ message: `create folder ${name}`, content: '', branch: state.currentBranch })
            });

            if (!res.ok) throw new Error('创建失败');
            
            const responseData = await res.json();

            await updateGlobalCacheState('add', {
                path: filePath,
                type: 'blob',
                sha: responseData.content ? responseData.content.sha : null,
                size: 0,
                parentPath: folderPath
            });

            await updateGlobalCacheState('add', {
                path: folderPath,
                type: 'tree',
                sha: null,
                size: 0,
                parentPath: state.currentPath
            });

            showToast(`已创建文件夹: ${name}`);
            hideCreateFolderModal();
            
        } catch (e) {
            showToast(`失败: ${e.message}`);
        } finally {
            if(el.createFolderConfirm) {
                el.createFolderConfirm.classList.remove('btn-processing');
                el.createFolderConfirm.innerHTML = '确认';
                el.createFolderConfirm.disabled = !el.createFolderInput.value.trim();
            }
        }
    };
    uiStateStack.push(hideCreateFolderModal);
}

function hideCreateFileModal() {
    el.createFileModal.classList.add('hidden');
    const index = uiStateStack.indexOf(hideCreateFileModal);
    if (index > -1) uiStateStack.splice(index, 1);
}

function showCreateFileModal() {
    if (!state.currentRepo) {
        showToast('请先选择仓库');
        return;
    }
    el.createFileNameInput.value = '';
    el.createFileContentInput.value = '';
    el.createFileModal.classList.remove('hidden');
    el.createFileConfirm.disabled = true;
    
    el.createFileConfirm.onclick = async function() {
        const name = el.createFileNameInput.value.trim();
        const content = el.createFileContentInput.value;
        if (!name) return;
        
        el.createFileConfirm.disabled = true;
        el.createFileConfirm.classList.add('btn-processing');
        el.createFileConfirm.innerHTML = '创建中 <i class="fa fa-spinner fa-spin"></i>';
        
        try {
            const [owner, repo] = state.currentRepo.split('/');
            const path = state.currentPath ? `${state.currentPath}${name}` : name;
            const encodedContent = btoa(unescape(encodeURIComponent(content)));
            
            const res = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${path}`, {
                method: 'PUT',
                headers: { Authorization: `token ${state.token}`, 'Content-Type': 'application/json' },
                body: JSON.stringify({ message: `create file ${name}`, content: encodedContent, branch: state.currentBranch })
            });
            
            if (!res.ok) throw new Error('创建失败');
            
            const responseData = await res.json();
            
            await updateGlobalCacheState('add', {
                path: path,
                type: 'blob',
                sha: responseData.content ? responseData.content.sha : null,
                size: responseData.content ? responseData.content.size : 0,
                parentPath: state.currentPath
            });

            showToast(`已创建文件: ${name}`);
            hideCreateFileModal();
            
        } catch (e) {
            showToast(`失败: ${e.message}`);
        } finally {
            if(el.createFileConfirm) {
                el.createFileConfirm.disabled = false;
                el.createFileConfirm.classList.remove('btn-processing');
                el.createFileConfirm.innerHTML = '确认';
            }
        }
    };
    uiStateStack.push(hideCreateFileModal);
}


function hideCreateBranchModal() {
    el.createBranchModal.classList.add('hidden');
    const index = uiStateStack.indexOf(hideCreateBranchModal);
    if (index > -1) uiStateStack.splice(index, 1);
}

async function showCreateBranchModal(repo) {
    el.createBranchNameInput.value = '';
    el.createBranchConfirm.disabled = true;
    el.createBranchModal.classList.remove('hidden');
    el.createBranchNameInput.oninput = () => {
        el.createBranchConfirm.disabled = !el.createBranchNameInput.value.trim();
    };
    const sourceSelector = {
        wrapper: document.getElementById('sourceBranchSelector'),
        trigger: document.getElementById('sourceBranchSelector').querySelector('.custom-branch-select-trigger'),
        optionsPanel: document.getElementById('sourceBranchSelector').querySelector('.custom-branch-select-options'),
        triggerText: document.getElementById('sourceBranchSelector').querySelector('span'),
        currentSelection: { name: null, sha: null }
    };
    sourceSelector.triggerText.textContent = '加载中...';
    sourceSelector.optionsPanel.innerHTML = '';

    const updateBranchActionButtonsState = () => {
        const selectedBranchName = sourceSelector.currentSelection.name;
        if (!selectedBranchName) {
            el.renameBranchBtn.disabled = true;
            el.deleteBranchBtn.disabled = true;
            el.renameBranchBtn.title = '重命名所选分支';
            el.deleteBranchBtn.title = '删除所选分支';
            return;
        };
        const isDefaultBranch = selectedBranchName === repo.default_branch;
        el.renameBranchBtn.disabled = false;
        el.renameBranchBtn.title = isDefaultBranch ? '不能重命名默认分支' : `重命名分支: ${selectedBranchName}`;
        el.deleteBranchBtn.disabled = false;
        el.deleteBranchBtn.title = isDefaultBranch ? '不能删除默认分支' : `删除分支: ${selectedBranchName}`;
    };

    try {
        await fetchBranches(repo);
        const populateBranchOptions = () => {
            sourceSelector.optionsPanel.innerHTML = '';
            if (!state.branches || state.branches.length === 0) {
                sourceSelector.triggerText.textContent = '无可用分支';
                sourceSelector.currentSelection = { name: null, sha: null };
                el.createBranchConfirm.disabled = true;
                return;
            }
            state.branches.forEach(branch => {
                const option = document.createElement('div');
                option.className = 'custom-branch-select-option';
                option.textContent = branch.name;
                option.dataset.branchName = branch.name;
                option.dataset.branchSha = branch.commit.sha;
                option.addEventListener('click', () => {
                    sourceSelector.currentSelection = { name: branch.name, sha: branch.commit.sha };
                    const previouslySelected = sourceSelector.optionsPanel.querySelector('.selected');
                    if (previouslySelected) previouslySelected.classList.remove('selected');
                    option.classList.add('selected');
                    sourceSelector.triggerText.textContent = branch.name;
                    sourceSelector.wrapper.classList.remove('open');
                    updateBranchActionButtonsState();
                });
                sourceSelector.optionsPanel.appendChild(option);
            });
            const defaultBranch = state.branches.find(b => b.name === repo.default_branch) || state.branches[0];
            if (defaultBranch) {
                sourceSelector.currentSelection = { name: defaultBranch.name, sha: defaultBranch.commit.sha };
                sourceSelector.triggerText.textContent = defaultBranch.name;
                const defaultOption = sourceSelector.optionsPanel.querySelector(`[data-branch-name="${defaultBranch.name}"]`);
                if (defaultOption) defaultOption.classList.add('selected');
            }
        };
        populateBranchOptions();
    } catch (error) {
        console.error("加载分支失败:", error);
        sourceSelector.triggerText.textContent = '加载分支失败';
        showToast('加载分支列表失败');
        sourceSelector.currentSelection = { name: null, sha: null };
        el.createBranchConfirm.disabled = true;
    }

    updateBranchActionButtonsState();

    sourceSelector.trigger.onclick = (e) => {
        if (!state.branches || state.branches.length === 0) return;
        e.stopPropagation();
        sourceSelector.wrapper.classList.toggle('open');
    };

    document.addEventListener('click', (e) => {
        if (!sourceSelector.wrapper.contains(e.target)) {
            sourceSelector.wrapper.classList.remove('open');
        }
    });

    el.renameBranchBtn.onclick = function() {
        const branchToRename = sourceSelector.currentSelection.name;
        if (!branchToRename) return;
        if (branchToRename === repo.default_branch) {
            showToast('禁止重命名默认分支');
            return;
        }
        showRenameModal({ name: branchToRename, type: 'branch', repo: repo });
    };

    el.deleteBranchBtn.onclick = function() {
    const branchToDelete = sourceSelector.currentSelection.name;
    if (!branchToDelete) return;
    if (branchToDelete === repo.default_branch) {
        showToast('禁止删除默认分支');
        return;
    }
    
    const restoreInteractivity = () => {
        el.createBranchModal.style.pointerEvents = 'auto';
    };

    el.createBranchModal.style.pointerEvents = 'none';

    showDeleteModal(
        null,
        false,
        '确认删除分支',
        `确定要删除分支 "${branchToDelete}" 吗？此操作不可撤销`,
        async () => {
            try {
                const res = await fetch(`https://api.github.com/repos/${repo.full_name}/git/refs/heads/${branchToDelete}`, {
                    method: 'DELETE',
                    headers: { 'Authorization': `token ${state.token}` }
                });
                if (!res.ok) throw new Error((await res.json()).message || '删除分支失败');
                showToast(`分支 &nbsp;${branchToDelete}已成功删除,请等待服务器刷新`);
                if (state.currentRepo === repo.full_name) {
                    await fetchBranches(repo);
                }
            } catch (e) {
                showToast(`删除失败: ${e.message}`);
            } finally {
                restoreInteractivity();
            }
        },
        '确认删除',
        'btn-danger',
        restoreInteractivity
    );
};

    el.createBranchConfirm.onclick = async function() {
        const newBranchName = el.createBranchNameInput.value.trim();
        const sourceBranchSha = sourceSelector.currentSelection.sha;
        if (!newBranchName || !sourceBranchSha) return;
        this.disabled = true;
        this.classList.add('btn-processing');
        this.innerHTML = '创建中 <i class="fa fa-spinner fa-spin"></i>';
        try {
            const res = await fetch(`https://api.github.com/repos/${repo.full_name}/git/refs`, {
                method: 'POST',
                headers: { 'Authorization': `token ${state.token}`, 'Content-Type': 'application/json' },
                body: JSON.stringify({ ref: `refs/heads/${newBranchName}`, sha: sourceBranchSha })
            });
            if (!res.ok) throw new Error((await res.json()).message || '创建分支失败');
            showToast(`分支 &nbsp;${newBranchName}创建成功,请等待服务器刷新`);
            hideCreateBranchModal();
            await fetchRepos(true);
            if (state.currentRepo === repo.full_name) {
                await fetchBranches(repo);
                renderBranchSwitcher();
            }
        } catch (e) {
            showToast(`创建失败: ${e.message}`);
        } finally {
            this.disabled = false;
            this.classList.remove('btn-processing');
            this.innerHTML = '创建分支';
        }
    };
    uiStateStack.push(hideCreateBranchModal);
}

function showRenameRepoModal(repo) {
    const mainSiteName = state.user ? `${state.user.login}.github.io` : null;
    
    const extraSettingsContainer = document.getElementById('renameModalExtraSettings');
    extraSettingsContainer.innerHTML = '';
    el.renameWarn.textContent = '';
    el.renameWarn.style.display = 'none';

    const settingsHTML = `
        <textarea id="newRepoDesc" placeholder="仓库描述（可选）" style="margin-top: 0.6rem;">${repo.description || ''}</textarea>
        <div class="checkbox-container" style="margin: 0.6rem 0;">
            <input type="checkbox" id="newRepoPrivate">
            <label for="newRepoPrivate">公开仓库</label>
        </div>
    `;
    extraSettingsContainer.innerHTML = settingsHTML;

    el.renameTitle.querySelector('.modal-title-text').textContent = `重命名`;
    const descTextarea = document.getElementById('newRepoDesc');
    const privateCheckbox = document.getElementById('newRepoPrivate');
    el.renameInput.value = repo.name;
    privateCheckbox.checked = !repo.private;
    el.renameConfirm.disabled = true;

    descTextarea.addEventListener('input', function() {
        autoGrow(this);
    });
    autoGrow(descTextarea);

    const updateButtonState = () => {
        const newName = el.renameInput.value.trim();
        const newDesc = descTextarea.value.trim();
        
        el.renameWarn.style.display = 'none';
        el.renameWarn.classList.remove('text-red-400', 'text-orange-400');
        
        if (mainSiteName) {
            if (repo.name === mainSiteName && newName !== mainSiteName) {
                el.renameWarn.textContent = '提示：重命名主站仓库将导致您的主网站下线。';
                el.renameWarn.classList.add('text-orange-400');
                el.renameWarn.style.display = 'block';
            } else if (repo.name !== mainSiteName && newName === mainSiteName) {
                el.renameWarn.textContent = '提示：手动命名为主站仓库不会自动发布网站。推荐使用“设为主站”功能。';
                el.renameWarn.classList.add('text-orange-400');
                el.renameWarn.style.display = 'block';
            }
        }
        
        const nameChanged = newName !== repo.name;
        const descChanged = newDesc !== (repo.description || '');
        const visibilityChanged = privateCheckbox.checked === repo.private;
        const isModified = nameChanged || descChanged || visibilityChanged;
        
        el.renameConfirm.disabled = !isModified || !newName;
    };

    el.renameInput.oninput = updateButtonState;
    descTextarea.oninput = updateButtonState;
    privateCheckbox.onchange = updateButtonState;

    el.renameConfirm.onclick = async function() {
        const newName = el.renameInput.value.trim();
        const newDesc = descTextarea.value.trim();
        const isPrivate = !privateCheckbox.checked;

        const requestBody = { name: newName, description: newDesc, private: isPrivate };
        
        this.disabled = true;
        this.classList.add('btn-processing');
        this.innerHTML = '处理中 <i class="fa fa-spinner fa-spin"></i>';
        try {
            const res = await fetch(`https://api.github.com/repos/${repo.full_name}`, {
                method: 'PATCH',
                headers: { 'Authorization': `token ${state.token}`, 'Content-Type': 'application/json' },
                body: JSON.stringify(requestBody)
            });
            if (!res.ok) throw new Error((await res.json()).message || '修改失败');
            state.shouldAnimateList = true;
            showToast(`保存成功`);
            
            hideRenameModal();
            await fetchRepos(true, true);
        } catch (e) {
            showToast(`修改失败: ${e.message}`, 'error');
        } finally {
            this.disabled = false;
            this.classList.remove('btn-processing');
            this.innerHTML = '确认';
        }
    };

    el.renameModal.classList.remove('hidden');
    uiStateStack.push(hideRenameModal);
}

function hideRenameModal() {
    el.renameModal.classList.add('hidden');

    // 核心修改：恢复布局和样式，避免影响其他功能
    el.renameInput.after(el.renameWarn); // 把提示框移回输入框下面
    el.renameWarn.style.color = '';
    el.renameWarn.style.fontSize = '';
    el.renameWarn.style.marginBottom = '';
    el.renameWarn.classList.add('text-red-400'); // 把默认的红色加回来
    
    const index = uiStateStack.indexOf(hideRenameModal);
    if (index > -1) uiStateStack.splice(index, 1);
}


function hideDeleteModal() {
    el.deleteModal.classList.add('hidden');
    const index = uiStateStack.indexOf(hideDeleteModal);
    if (index > -1) uiStateStack.splice(index, 1);
}


function showDeleteModal(item, isDir = false, title, description, onConfirm, confirmButtonText = '确认删除', confirmButtonClass = 'btn-danger', onCancel) {
    el.deleteTitle.querySelector('.modal-title-text').textContent = title || '确认操作';
    if (item) {
        isDir = item.type === 'dir';
        el.deleteDesc.textContent = description || (isDir ? `确定要删除文件夹 "${item.name}" 吗？
        注意：如果文件夹内文件过多，可能需要较长时间并消耗大量API额度，可在仪表盘查看额度使用情况。` : `确定要删除文件 "${item.name}" 吗？`);
    } else {
        el.deleteDesc.innerHTML = description;
    }

    el.deleteConfirm.textContent = confirmButtonText;
    el.deleteConfirm.className = `btn ${confirmButtonClass}`; 

    el.deleteModal.classList.remove('hidden');
    
    el.deleteConfirm.onclick = async function() {
        const confirmBtn = this;
        confirmBtn.disabled = true;
        confirmBtn.classList.add('btn-processing');
        confirmBtn.innerHTML = '处理中 <i class="fa fa-spinner fa-spin"></i>';
        try {
            if (onConfirm) {
                await onConfirm();
            } else if (item) {
                await deleteSingleItem(item);
                showToast(`"${escapeHtml(item.name)}" 已删除`);
                state.shouldAnimateList = true;
                fetchFiles(true);
            }
        } catch (error) {
            showToast(`操作失败: ${error.message}`);
        } finally {
            hideDeleteModal();
            confirmBtn.disabled = false;
            confirmBtn.classList.remove('btn-processing');
            confirmBtn.innerHTML = confirmButtonText; 
        }
    };

    el.deleteCancel.onclick = function() {
        if (typeof onCancel === 'function') {
            onCancel();
        }
        hideDeleteModal();
    };

    uiStateStack.push(hideDeleteModal);
}

function goUp() {
    history.back();
}

function closeProxySettingsModal() {
    el.proxySettingsModal.classList.add('hidden');
    const index = uiStateStack.indexOf(closeProxySettingsModal);
    if (index > -1) uiStateStack.splice(index, 1);
}

function openProxySettingsModal() {
    updateProxySettingsUI();
    renderProxyList();
    el.proxySettingsModal.classList.remove('hidden');
    uiStateStack.push(closeProxySettingsModal);
}

function updateProxySettingsUI() {
    updateProxyUI();
    const isAutoSelectEnabled = !!state.autoSelectProxy;
    el.proxyAutoSelectToggle.classList.toggle('active', isAutoSelectEnabled);
    el.proxyAutoSelectToggle.title = isAutoSelectEnabled ? '自动优选代理已开启' : '自动优选代理已关闭';
}

async function testProxyEnhanced(proxyUrl) {
    const TIMEOUT_MS = 5000;
    const ROUNDS = 3;
    
    if (!proxyUrl) return { ok: false, ms: null };

    let baseUrl = proxyUrl;
    if (!baseUrl.endsWith('/')) baseUrl += '/';
    const targetUrl = baseUrl + PROXY_TEST_URL;

    const latencies = [];

    for (let i = 0; i < ROUNDS; i++) {
        const start = performance.now();
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), TIMEOUT_MS);
        
        try {
            const cacheBuster = (targetUrl.includes('?') ? '&' : '?') + `_t=${Date.now()}_${i}`;
            const res = await fetch(targetUrl + cacheBuster, { 
                method: 'GET', 
                cache: 'no-store', 
                signal: controller.signal 
            });
            
            clearTimeout(timeoutId);
            
            if (res.ok) {
                await res.text();
                latencies.push(performance.now() - start);
            }
        } catch (e) {
            clearTimeout(timeoutId);
        }
    }

    if (latencies.length === 0) {
        return { ok: false, ms: null, err: '连接失败' };
    }

    const average = latencies.reduce((a, b) => a + b, 0) / latencies.length;
    return { ok: true, ms: Math.round(average), err: null };
}

function renderProxyList() {
    const container = el.proxyListContainer;
    container.innerHTML = '';
    if (state.proxies.length === 0) {
        el.proxyListEmpty.classList.remove('hidden');
        el.proxyTestAllBtn.disabled = true;
        el.proxyClearAllBtn.disabled = true;
        el.proxyAutoSelectToggle.disabled = true;
    } else {
        el.proxyListEmpty.classList.add('hidden');
        el.proxyTestAllBtn.disabled = false;
        el.proxyClearAllBtn.disabled = false;
        el.proxyAutoSelectToggle.disabled = false;
    }

    const sortedProxies = [...state.proxies].sort((a, b) => {
        const getPriority = (proxy) => {
            if (proxy.status === 'ok') return 1;
            if (proxy.status === 'fail') return 3;
            return 2;
        };

        const priorityA = getPriority(a);
        const priorityB = getPriority(b);

        if (priorityA !== priorityB) {
            return priorityA - priorityB;
        }

        if (priorityA === 1) {
            return (a.latency ?? Infinity) - (b.latency ?? Infinity);
        }

        return 0;
    });

    sortedProxies.forEach((proxy) => {
        const index = state.proxies.indexOf(proxy);
        const proxyItem = document.createElement('div');
        proxyItem.className = 'proxy-item';
        if (index === state.activeProxyIndex) proxyItem.classList.add('active');
        
        let statusClass = 'gray', latencyText = '未测试', typeText = '';
        if (proxy.type === 'raw_domain_replace') {
            typeText = '类型：替换域名';
        } else if (proxy.type === 'prefix') {
            typeText = '类型：添加前缀';
        }

        if (proxy.status === 'testing') {
            latencyText = `<span class="spinner-small"></span>`;
        } else if (proxy.status === 'ok') {
            latencyText = `${proxy.latency} ms`;
            if (proxy.latency <= 500) statusClass = 'green';
            else if (proxy.latency <= 2000) statusClass = 'yellow';
            else statusClass = 'red';
        } else if (proxy.status === 'fail') {
            statusClass = 'red';
            latencyText = '失败';
        }
        
        proxyItem.innerHTML = `
            <div class="proxy-identity">
                <span class="status-dot ${statusClass}"></span>
                <div class="proxy-url-details">
                    <span class="proxy-url" title="${proxy.url || ''}">${getDomainFromUrl(proxy.url) || '无效URL'}</span>
                    ${typeText ? `<span class="proxy-type-label">${typeText}</span>` : ''}
                </div>
            </div>
            <div class="proxy-status-actions">
                <span class="latency-text ${statusClass}">${latencyText}</span>
                <div class="proxy-actions">
                    <button class="btn-icon-sm edit-proxy-btn" data-index="${index}" title="编辑"><i class="fa fa-pencil"></i></button>
                    <button class="btn-icon-sm delete-proxy-btn danger" data-index="${index}" title="删除"><i class="fa-regular fa-trash-can"></i></button>
                </div>
            </div>
        `;
        proxyItem.addEventListener('click', (e) => {
            if (e.target.closest('.edit-proxy-btn, .delete-proxy-btn')) return;
            if (index === state.activeProxyIndex) return;
            setActiveProxy(index);
        });
        container.appendChild(proxyItem);
    });

    container.querySelectorAll('.edit-proxy-btn').forEach(button => {
        button.onclick = (e) => { e.stopPropagation(); openAddEditProxyModal(parseInt(e.currentTarget.dataset.index)); };
    });
    container.querySelectorAll('.delete-proxy-btn').forEach(button => {
        button.onclick = (e) => { e.stopPropagation(); showConfirmDeleteProxyModal(parseInt(e.currentTarget.dataset.index)); };
    });
    saveProxyConfig();
}

function saveProxyConfig() {
    localStorage.setItem('proxies', JSON.stringify(state.proxies));
    localStorage.setItem('active_proxy_index', JSON.stringify(state.activeProxyIndex));
    localStorage.setItem('proxy_global_enable', JSON.stringify(state.proxyGlobalEnable));
    updateProxyUI();
}

function openAddEditProxyModal(index = null) {
    state.editingProxyIndex = index;
    const modal = el.addEditProxyModal;
    const titleTextSpan = el.addEditProxyTitle.querySelector('.modal-title-text');
    const urlInput = el.addEditProxyUrlInput;
    const saveBtn = el.addEditProxySaveBtn;
    const cancelBtn = document.getElementById('addEditProxyCancelBtn');
    urlInput.value = '';
    el.addEditProxyError.style.display = 'none';
    if (index !== null && state.proxies[index]) {
        const proxy = state.proxies[index];
        titleTextSpan.textContent = '编辑代理';
        urlInput.value = proxy.url;
        urlInput.placeholder = '修改代理地址';
    } else {
        titleTextSpan.textContent = '添加新代理';
        urlInput.placeholder = '例如：https://ghproxy.net/';
    }
    cancelBtn.onclick = closeAddEditProxyModal;
    saveBtn.onclick = null; 
    modal.classList.remove('hidden');
    validateAddEditProxyInput();
    uiStateStack.push(closeAddEditProxyModal);
}

function closeAddEditProxyModal() {
    el.addEditProxyModal.classList.add('hidden');
    state.editingProxyIndex = null;
    el.addEditProxySaveBtn.disabled = false;
    el.addEditProxySaveBtn.classList.remove('btn-processing');
    el.addEditProxySaveBtn.innerHTML = '保存';
    const index = uiStateStack.indexOf(closeAddEditProxyModal);
    if (index > -1) uiStateStack.splice(index, 1);
}

function validateAddEditProxyInput() {
    const url = el.addEditProxyUrlInput.value.trim();
    const saveBtn = el.addEditProxySaveBtn;
    let fullUrl = url;
    if (url && !/^https?:\/\//i.test(fullUrl)) fullUrl = 'https://' + fullUrl;
    const isDuplicate = state.proxies.some((proxy, index) => {
        if (state.editingProxyIndex !== null && index === state.editingProxyIndex) return false;
        let existingUrl = proxy.url;
        if (!/^https?:\/\//i.test(existingUrl)) existingUrl = 'https://' + existingUrl;
        return existingUrl === fullUrl;
    });
    if (!url) {
        saveBtn.disabled = true;
        saveBtn.onclick = null;
    } else if (isDuplicate) {
        saveBtn.disabled = true;
        saveBtn.onclick = () => { showToast('该代理已存在'); };
    } else {
        saveBtn.disabled = false;
        saveBtn.onclick = handleSaveProxy;
    }
    return !isDuplicate && !!url;
}

async function handleSaveProxy() {
    let url = el.addEditProxyUrlInput.value.trim();
    if (url && !/^https?:\/\//i.test(url)) url = 'https://' + url;
    const isEditing = state.editingProxyIndex !== null;
    let indexToTest;
    if (isEditing) {
        indexToTest = state.editingProxyIndex;
        const proxyToEdit = state.proxies[indexToTest];
        proxyToEdit.url = url;
        proxyToEdit.status = 'testing';
        proxyToEdit.latency = null;
        proxyToEdit.err = null;
        proxyToEdit.type = null;
        showToast('代理已更新，正在重新测试...');
    } else {
        const newProxy = { url: url, status: 'testing', latency: null, err: null, type: null };
        state.proxies.unshift(newProxy); 
        indexToTest = 0;
        showToast('代理已添加，正在后台测试...');
    }
    closeAddEditProxyModal();
    renderProxyList();
    const proxyToTest = state.proxies[indexToTest];
    if (!proxyToTest) return;
    const result = await testProxyEnhanced(proxyToTest.url);
    proxyToTest.latency = result.ms;
    proxyToTest.status = result.ok ? 'ok' : 'fail';
    proxyToTest.err = result.err;
    proxyToTest.type = result.type;
    renderProxyList();
}

function showConfirmDeleteProxyModal(index) {
    const proxy = state.proxies[index];
    el.confirmDeleteProxyTitle.querySelector('.modal-title-text').textContent = '确认删除代理';
    el.confirmDeleteProxyMessage.innerHTML = `确定要删除代理 <strong>"${escapeHtml(proxy.url)}"</strong> 吗？此操作不可撤销。`;
    el.confirmDeleteProxyModal.classList.remove('hidden');
    el.confirmDeleteProxyConfirmBtn.onclick = null;
    el.confirmDeleteProxyCancelBtn.onclick = null;
    el.confirmDeleteProxyConfirmBtn.onclick = async () => {
        el.confirmDeleteProxyConfirmBtn.disabled = true;
        el.confirmDeleteProxyConfirmBtn.classList.add('btn-processing');
        el.confirmDeleteProxyConfirmBtn.innerHTML = `删除中 <span class="spinner-small"></span>`;
        try {
            await deleteProxy(index);
            hideConfirmDeleteProxyModal();
        } finally {
            el.confirmDeleteProxyConfirmBtn.disabled = false;
            el.confirmDeleteProxyConfirmBtn.classList.remove('btn-processing');
            el.confirmDeleteProxyConfirmBtn.innerHTML = '确认删除';
        }
    };
    el.confirmDeleteProxyCancelBtn.onclick = hideConfirmDeleteProxyModal;
    uiStateStack.push(hideConfirmDeleteProxyModal);
}

function hideConfirmDeleteProxyModal() {
    el.confirmDeleteProxyModal.classList.add('hidden');
    const index = uiStateStack.indexOf(hideConfirmDeleteProxyModal);
    if (index > -1) uiStateStack.splice(index, 1);
}

function showConfirmClearAllProxiesModal() {
    el.confirmClearAllProxiesModal.classList.remove('hidden');
    el.clearAllProxiesConfirmBtn.disabled = false;
    el.clearAllProxiesConfirmBtn.innerHTML = '确认清空';
    uiStateStack.push(hideConfirmClearAllProxiesModal);
}

function hideConfirmClearAllProxiesModal() {
    el.confirmClearAllProxiesModal.classList.add('hidden');
    const index = uiStateStack.indexOf(hideConfirmClearAllProxiesModal);
    if (index > -1) uiStateStack.splice(index, 1);
}

async function clearAllProxiesConfirmed() {
    el.clearAllProxiesConfirmBtn.disabled = true;
    el.clearAllProxiesConfirmBtn.classList.add('btn-processing');
    el.clearAllProxiesConfirmBtn.innerHTML = `清空中 <span class="spinner-small"></span>`;
    state.proxies = [];
    state.activeProxyIndex = -1;
    showToast('所有代理已清空');
    hideConfirmClearAllProxiesModal();
    renderProxyList();
    el.clearAllProxiesConfirmBtn.disabled = false;
    el.clearAllProxiesConfirmBtn.classList.remove('btn-processing');
    el.clearAllProxiesConfirmBtn.innerHTML = '确认清空';
}

async function deleteProxy(index) {
    state.proxies.splice(index, 1);
    if (state.activeProxyIndex === index) {
        state.activeProxyIndex = state.proxies.length > 0 ? 0 : -1;
    } else if (state.activeProxyIndex > index) {
        state.activeProxyIndex--;
    }
    showToast('代理已删除');
    renderProxyList();
}





async function testAllProxies(showInitialToast = true) {
    if (state.proxies.length === 0) {
        if (showInitialToast) showToast('没有代理可供测试', 'info');
        return;
    }
    el.proxyTestAllBtn.disabled = true;
    el.proxyTestAllSpinner.classList.remove('hidden');
    el.proxyTestAllBoltIcon.classList.add('hidden');

    if (showInitialToast) {
        showToast(`开始测试 ${state.proxies.length} 个代理...`);
    }

    state.proxies.forEach(proxy => {
        proxy.status = 'testing';
        proxy.latency = null;
        proxy.err = null;
        proxy.type = null;
    });
    renderProxyList();


//修改同时测试的代理数量
    const BATCH_SIZE = 30;
    for (let i = 0; i < state.proxies.length; i += BATCH_SIZE) {
        const batch = state.proxies.slice(i, i + BATCH_SIZE);
        const testPromises = batch.map(async (proxy) => {
            try {
                const result = await testProxyEnhanced(proxy.url);
                proxy.latency = result.ms;
                proxy.status = result.ok ? 'ok' : 'fail';
                proxy.err = result.err;
                proxy.type = result.type;
            } catch (error) {
                proxy.status = 'fail';
                proxy.err = '测试异常';
            }
        });
        await Promise.all(testPromises);
        renderProxyList();
    }

    showToast('所有代理测试完成！');
    el.proxyTestAllBtn.disabled = false;
    el.proxyTestAllBoltIcon.classList.remove('hidden');
    el.proxyTestAllSpinner.classList.add('hidden');
}





async function importProxiesFromUrl() {
    const importButton = el.importBtn;
    const importIcon = importButton.querySelector('i');
    const importSpinner = el.importSpinner;

    importButton.disabled = true;
    if (importIcon) importIcon.classList.add('hidden');
    if (importSpinner) importSpinner.classList.remove('hidden');
    
    showToast('正在获取云端节点...', 'info');

    try {
        const PROXY_PREFIXES = [
            'https://gh.927223.xyz/',
            'https://ghproxy.net/',
            'https://ghfast.top/',
            'https://tvv.tw/'
        ];
        
        const timestamp = `?t=${Date.now()}`;
        const urlsToTry = [
            ...PROXY_PREFIXES.map(prefix => prefix + PROXY_TEST_URL + timestamp),
            PROXY_TEST_URL + timestamp 
        ];

        let responseText = null;
        let success = false;

        for (const url of urlsToTry) {
            try {
                const response = await fetch(url, { cache: 'no-store' });
                if (response.ok) {
                    responseText = await response.text();
                    success = true;
                    break; 
                }
            } catch (error) {
                continue;
            }
        }

        if (!success) throw new Error('无法连接到节点源');
        
        const urls = responseText.split('\n').map(url => url.trim()).filter(url => url && url.length > 5);
        
        if (urls.length > 0) {
            let addedCount = 0;
            urls.forEach(u => {
                const cleanU = u.replace(/\/$/, '');
                const exists = state.proxies.some(p => p.url && p.url.replace(/\/$/, '') === cleanU);
                if (!exists) {
                    state.proxies.push({ url: u, status: null, latency: null });
                    addedCount++;
                }
            });

            if (addedCount > 0) {
                if (state.activeProxyIndex === -1) {
                    state.activeProxyIndex = Math.floor(Math.random() * state.proxies.length);
                }
                saveProxyConfig();
                renderProxyList();
                showToast(`已更新 ${addedCount} 个节点`);
                findAndSetBestProxy(true);
            } else {
                showToast('节点列表已是最新');
            }
        }

    } catch (error) {
        showToast(`更新失败: ${error.message}`, 'error');
    } finally {
        importButton.disabled = false;
        if (importIcon) importIcon.classList.remove('hidden');
        if (importSpinner) importSpinner.classList.add('hidden');
    }
}


function initProxySystem() {
    state.activeProxyIndex = parseInt(localStorage.getItem('active_proxy_index') || '-1');
    state.proxyGlobalEnable = JSON.parse(localStorage.getItem('proxy_global_enable') || 'true');
    state.autoSelectProxy = JSON.parse(localStorage.getItem('proxy_auto_select') || 'true');

    if (state.proxies.length === 0) {
        importProxiesFromUrl();
    } else {
        if (state.activeProxyIndex === -1 || state.activeProxyIndex >= state.proxies.length) {
            state.activeProxyIndex = Math.floor(Math.random() * state.proxies.length);
            saveProxyConfig();
        }

        const lastCheck = parseInt(localStorage.getItem('last_proxy_check_time') || '0');
        const now = Date.now();
        const ONE_DAY = 24 * 60 * 60 * 1000;

        if (now - lastCheck > ONE_DAY) {
            findAndSetBestProxy(true);
        } else {
            const current = state.proxies[state.activeProxyIndex];
            if (current) {
                testProxyEnhanced(current.url).then(res => {
                    if (!res.ok) {
                        findAndSetBestProxy(true);
                    }
                });
            }
        }
    }
    updateProxyUI();
}






async function findAndSetBestProxy(isSilent = false) {
    if (state.proxies.length === 0) {
        if (!isSilent) importProxiesFromUrl();
        return;
    }

    if (!isSilent) {
        el.proxyTestAllBtn.disabled = true;
        const icon = el.proxyTestAllBtn.querySelector('i');
        if(icon) icon.className = 'fa fa-spinner fa-spin';
        showToast(`开始测速 (共${state.proxies.length}个节点)...`);
    }

    const BATCH_SIZE = 4;
    const allProxies = state.proxies;
    
    for (let i = 0; i < allProxies.length; i += BATCH_SIZE) {
        const batch = allProxies.slice(i, i + BATCH_SIZE);
        
        const batchPromises = batch.map(async (proxy) => {
            proxy.status = 'testing';
            const result = await testProxyEnhanced(proxy.url);
            proxy.latency = result.ms;
            proxy.status = result.ok ? 'ok' : 'fail';
            proxy.err = result.err;
            return proxy;
        });
        
        await Promise.all(batchPromises);
        
        if (!el.proxySettingsModal.classList.contains('hidden')) {
            renderProxyList();
        }
    }

    const validProxies = state.proxies.filter(p => p.status === 'ok' && p.latency !== null);
    
    if (validProxies.length > 0) {
        validProxies.sort((a, b) => a.latency - b.latency);
        const bestProxy = validProxies[0];
        const bestIndex = state.proxies.indexOf(bestProxy);

        if (bestIndex !== -1) {
            const currentProxy = state.proxies[state.activeProxyIndex];
            
            const isCurrentInvalid = !currentProxy || currentProxy.status !== 'ok' || currentProxy.latency > 1500;
            
            if (state.autoSelectProxy || isCurrentInvalid) {
                if (state.activeProxyIndex !== bestIndex) {
                    setActiveProxy(bestIndex, !isSilent);
                }
            }
        }
    } else {
        if (!isSilent) showToast('所有节点均无法连接', 'error');
    }

    localStorage.setItem('last_proxy_check_time', Date.now().toString());
    saveProxyConfig();

    if (!isSilent) {
        el.proxyTestAllBtn.disabled = false;
        const icon = el.proxyTestAllBtn.querySelector('i');
        if(icon) icon.className = 'fa-solid fa-bolt';
    }
}







async function handleRefreshApiStatus() {
    const refreshBtn = el.refreshApiStatusBtn;
    const icon = refreshBtn.querySelector('i');
    refreshBtn.disabled = true;
    icon.classList.add('fa-spin-custom');
    try {
        await fetchAndRenderApiStatus();
    } catch (error) {
        console.error("手动刷新API状态时出错:", error);
    } finally {
        refreshBtn.disabled = false;
        icon.classList.remove('fa-spin-custom');
    }
}

const closeMultiSelect = () => toggleMultiSelectMode(false);

function toggleMultiSelectMode(enable) {
    state.isMultiSelectMode = enable;
    const fileListEl = el.fileList;
    const toggleBtn = el.multiSelectToggleBtn;
    if (enable) {
        fileListEl.classList.add('multi-select-mode');
        el.multiSelectBar.classList.add('active');
        toggleBtn.classList.add('active');
        toggleBtn.title = '取消多选';
        uiStateStack.push(closeMultiSelect);
    } else {
        fileListEl.classList.remove('multi-select-mode');
        el.multiSelectBar.classList.remove('active');
        toggleBtn.classList.remove('active');
        toggleBtn.title = '多项选择';
        fileListEl.querySelectorAll('.file-item.selected').forEach(item => {
            item.classList.remove('selected');
        });
        state.selectedItems.clear();
        const index = uiStateStack.indexOf(closeMultiSelect);
        if (index > -1) uiStateStack.splice(index, 1);
    }
    updateActionBar();
}

function updateActionBar() {
    const count = state.selectedItems.size;
    const total = state.displayFiles.length;
    el.selectedCountSpan.textContent = count > 0 ? `已选 ${count} / ${total} 项` : '未选择';
    el.downloadBtn.disabled = count === 0;
    el.deleteBtn.disabled = count === 0;
    el.invertSelectBtn.disabled = count === 0;
    const selectAllIcon = el.selectAllBtn.querySelector('i');
    if (total > 0 && count === total) {
        selectAllIcon.className = 'fa-regular fa-square-minus';
        el.selectAllBtn.title = '取消全选';
    } else {
        selectAllIcon.className = 'fa-regular fa-square-check';
        el.selectAllBtn.title = '全选';
    }
}



async function downloadFilesConcurrently(files, zipFolder, onProgress) {
    const CONCURRENCY_LIMIT = 5;
    let completedCount = 0;
    let activeCount = 0;
    let currentIndex = 0;
    const total = files.length;

    return new Promise((resolve, reject) => {
        if (total === 0) resolve();

        const next = () => {
            if (completedCount === total) {
                resolve();
                return;
            }

            while (activeCount < CONCURRENCY_LIMIT && currentIndex < total) {
                const file = files[currentIndex++];
                activeCount++;

                const fetchAndZip = async () => {
                    try {
                        const rawUrl = file.download_url || 
                                     `https://raw.githubusercontent.com/${state.currentRepo}/${state.currentBranch}/${file.path.split('/').map(encodeURIComponent).join('/')}`;
                        
                        const url = getProxiedUrl(rawUrl);

                        const res = await fetch(url);
                        
                        if (!res.ok) throw new Error(`HTTP ${res.status}`);
                        
                        const blob = await res.blob();
                        
                        zipFolder.file(file.zipPath, blob);
                        
                    } catch (e) {
                        console.error(e);
                        zipFolder.file(file.zipPath + ".error.txt", "Download failed: " + e.message);
                    } finally {
                        activeCount--;
                        completedCount++;
                        if (onProgress) onProgress(completedCount, total);
                        next();
                    }
                };

                fetchAndZip();
            }
        };

        next();
    });
}

async function gatherAllFiles(path, zipPathPrefix = "") {
    const [owner, repo] = state.currentRepo.split('/');
    let collectedFiles = [];
    
    try {
        const url = `https://api.github.com/repos/${owner}/${repo}/contents/${path}?ref=${state.currentBranch}`;
        const res = await fetch(url, { headers: { 'Authorization': `token ${state.token}` } });
        if (!res.ok) throw new Error('Failed');
        
        const items = await res.json();
        const promises = items.map(async (item) => {
            const itemZipPath = zipPathPrefix ? `${zipPathPrefix}/${item.name}` : item.name;
            if (item.type === 'file') {
                return [{
                    path: item.path,
                    zipPath: itemZipPath,
                    size: item.size
                }];
            } else if (item.type === 'dir') {
                return await gatherAllFiles(item.path, itemZipPath);
            }
            return [];
        });

        const results = await Promise.all(promises);
        collectedFiles = results.flat();
    } catch (e) {
        console.error(e);
    }
    return collectedFiles;
}

// 全局下载状态锁
let isDownloading = false;

// 1. 安卓端会调用这个函数来解锁
window.resetDownloadState = function() {
    isDownloading = false;
    // 如果有 Toast 提示正在下载，可以在这里关闭它
    // if (typeof hideToast === 'function') hideToast();
};

async function triggerNativeDownload(blob, filename) {
    // 创建 URL
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename; // 这里的 filename 会被安卓端获取并使用
    a.style.display = 'none';
    document.body.appendChild(a);
    
    // 触发点击，让 Android 拦截
    a.click(); 
    
    // 延长 Blob 存活时间，确保安卓端有足够时间去读取
    setTimeout(() => {
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }, 60000); 
}

// 可选：接收安卓端的重置信号（即使不写逻辑，函数必须存在，防止安卓调用报错）
window.resetDownloadState = function() {
    // 可以在这里清除网页上的 Loading 提示（如果有的话）
    if (typeof showToast === 'function' && document.querySelector('#toast.show')) {
        // hideToast(); 
    }
};



async function downloadSelectedItemsAsZip() {
    if (state.selectedItems.size === 0) return;
    
    const updateProgressToast = (current, total, phase) => {
        const toastEl = document.getElementById('toast');
        const msgEl = document.getElementById('toastMessage');
        toastEl.className = 'toast-info show';
        if (phase === 'scanning') {
            msgEl.textContent = `正在扫描文件列表...`;
        } else {
            const percent = Math.round((current / total) * 100);
            msgEl.textContent = `正在下载: ${current}/${total} (${percent}%)`;
        }
    };

    updateProgressToast(0, 0, 'scanning');
try {
    await LibraryLoader.load(LIBS.JSZIP, 'JSZip');
} catch (e) {
    showToast('加载压缩组件失败', 'error');
    return;
}
const zip = new JSZip();
let allFilesToDownload = [];

    try {
        const rootItems = state.files.filter(file => state.selectedItems.has(file.path));
        
        const scanPromises = rootItems.map(async (item) => {
            if (item.type === 'file') {
                return [{ path: item.path, zipPath: item.name }];
            } else if (item.type === 'dir') {
                return await gatherAllFiles(item.path, item.name);
            }
            return [];
        });

        const results = await Promise.all(scanPromises);
        allFilesToDownload = results.flat();

        if (allFilesToDownload.length === 0) {
            showToast('没有可下载的文件');
            return;
        }

        await downloadFilesConcurrently(allFilesToDownload, zip, (curr, total) => {
            updateProgressToast(curr, total, 'downloading');
        });

        document.getElementById('toastMessage').textContent = "正在打包压缩...";
        
        const content = await zip.generateAsync({ type: "blob" });
        const fileName = `${state.currentRepo.split('/')[1]}-selected.zip`;
        
        triggerNativeDownload(content, fileName);
        
        showToast('打包完成，请查看分享或下载', 'success');

    } catch (e) {
        showToast(`操作失败: ${e.message}`, 'error');
    }
}

async function downloadFolderAsZip(folderItem) {
    if (folderItem.type !== 'dir') return;

    const updateProgressToast = (current, total, phase) => {
        const toastEl = document.getElementById('toast');
        const msgEl = document.getElementById('toastMessage');
        toastEl.className = 'toast-info show';
        if (phase === 'scanning') {
            msgEl.textContent = `正在扫描文件夹: ${folderItem.name}...`;
        } else {
            const percent = Math.round((current / total) * 100);
            msgEl.textContent = `下载中: ${current}/${total} (${percent}%)`;
        }
    };

    updateProgressToast(0, 0, 'scanning');
try {
    await LibraryLoader.load(LIBS.JSZIP, 'JSZip');
} catch (e) {
    showToast('加载压缩组件失败', 'error');
    return;
}
const zip = new JSZip();

    try {
        const allFiles = await gatherAllFiles(folderItem.path, folderItem.name);
        
        if (allFiles.length === 0) {
            showToast('文件夹为空');
            return;
        }

        await downloadFilesConcurrently(allFiles, zip, (curr, total) => {
            updateProgressToast(curr, total, 'downloading');
        });

        document.getElementById('toastMessage').textContent = "正在打包压缩...";
        const content = await zip.generateAsync({ type: "blob" });
        const fileName = `${folderItem.name}.zip`;

        triggerNativeDownload(content, fileName);

        showToast('打包完成，请查看分享或下载', 'success');

    } catch (e) {
        showToast(`下载失败: ${e.message}`, 'error');
    }
}

function downloadRepoAsZip(repo) {
    const zipRaw = `https://github.com/${repo.full_name}/archive/refs/heads/${repo.default_branch || 'main'}.zip`;
    let zipUrl = zipRaw;
    let viaProxy = false;

    if (state.proxyGlobalEnable && state.proxies.length > 0 && state.activeProxyIndex !== -1) {
        const activeProxy = state.proxies[state.activeProxyIndex];
        if (activeProxy && activeProxy.url && activeProxy.type) {
            if (activeProxy.type === 'prefix') {
                let proxyBase = activeProxy.url;
                if (!proxyBase.endsWith('/')) {
                    proxyBase += '/';
                }
                zipUrl = proxyBase + zipRaw;
                viaProxy = true;
            } else if (activeProxy.type === 'raw_domain_replace') {
                try {
                    const proxyDomain = getDomainFromUrl(activeProxy.url);
                    if (proxyDomain) {
                        const originalUrl = new URL(zipRaw);
                        originalUrl.hostname = proxyDomain;
                        zipUrl = originalUrl.toString();
                        viaProxy = true;
                    }
                } catch (e) {
                    console.error(e);
                }
            }
        }
    }

    const a = document.createElement('a');
    a.href = zipUrl;
    a.download = `${repo.name}.zip`;
    a.target = "_blank"; 
    document.body.appendChild(a);
    a.click();
    setTimeout(() => document.body.removeChild(a), 500);
    showToast(`正在使用${viaProxy ? '代理' : '直连'}下载 ${repo.name}.zip `);
}



function saveContextMenuSettings() {
    localStorage.setItem('context_menu_visibility', JSON.stringify(state.contextMenuVisibility));
}

function loadContextMenuSettings() {
    const savedSettings = JSON.parse(localStorage.getItem('context_menu_visibility'));
    state.contextMenuVisibility = JSON.parse(JSON.stringify(DEFAULT_MENU_VISIBILITY));
    if (savedSettings) {
        for (const category in state.contextMenuVisibility) {
            if (savedSettings[category]) {
                for (const action in state.contextMenuVisibility[category]) {
                    if (savedSettings[category][action] !== undefined) {
                        state.contextMenuVisibility[category][action] = savedSettings[category][action];
                    }
                }
            }
        }
    }
}

function renderContextMenuSettings(category) {
    const content = el.contextMenuSettingsContent;
    content.innerHTML = '';
    const settings = state.contextMenuVisibility[category];
    const definitions = CONTEXT_MENU_DEFINITIONS[category];
    definitions.forEach(item => {
        if (category === 'repo' && (item.action === 'copyMainSiteLink')) return;
        let labelText = item.text;
        if (category === 'repo' && item.action === 'setAsMainSite') {
            labelText = '主站链接';
        }
        const isVisible = settings[item.action];
        const settingItem = document.createElement('div');
        settingItem.className = 'setting-item';
        settingItem.innerHTML = `
            <label for="toggle-${category}-${item.action}">${labelText}</label>
            <label class="switch">
                <input type="checkbox" id="toggle-${category}-${item.action}" data-category="${category}" data-action="${item.action}" ${isVisible ? 'checked' : ''}>
                <span class="slider round"></span>
            </label>
        `;
        content.appendChild(settingItem);
    });
}

function hideContextMenuSettingsModal() {
    el.contextMenuSettingsModal.classList.add('hidden');
    const index = uiStateStack.indexOf(hideContextMenuSettingsModal);
    if (index > -1) uiStateStack.splice(index, 1);
}

function openContextMenuSettingsModal() {
    el.contextMenuSettingsModal.classList.remove('hidden');
    const activeTab = el.contextMenuSettingsModal.querySelector('.context-menu-settings-tabs .tab-btn.active');
    if (activeTab) {
        const activeCategory = activeTab.dataset.tab;
        renderContextMenuSettings(activeCategory);
    } else {
        renderContextMenuSettings('file');
    }
    uiStateStack.push(hideContextMenuSettingsModal);
}







function hideMediaPreview() {
    const preview = document.getElementById('mediaPreview');
    if (!preview.classList.contains('hidden')) {
        preview.classList.add('hidden');
        document.getElementById('mediaPreviewImg').src = '';
        const video = document.getElementById('mediaPreviewVideo');
        video.src = '';
        video.pause();
        const index = uiStateStack.indexOf(hideMediaPreview);
        if (index > -1) uiStateStack.splice(index, 1);
    }
}





const NavSpectrum = {
    canvas: null,
    ctx: null,
    audioContext: null,
    analyser: null,
    source: null,
    isActive: false,
    mediaElement: null,
    dataArray: null,
    resizeObserver: null,

    init(audioElement) {
        if (this.mediaElement === audioElement) return;
        this.mediaElement = audioElement;
        this.canvas = document.getElementById('nav-spectrum');
        if (!this.canvas) return;

        this.ctx = this.canvas.getContext('2d');
        
        if (this.resizeObserver) this.resizeObserver.disconnect();
        const footer = document.querySelector('footer');
        if (footer) {
            this.resizeObserver = new ResizeObserver(() => this.resize());
            this.resizeObserver.observe(footer);
        }

        this.setupAudioContext();
    },

    setupAudioContext() {
        if (this.analyser) return;

        try {
            const AC = window.AudioContext || window.webkitAudioContext;
            if (!AC) return;

            this.audioContext = new AC();
            this.analyser = this.audioContext.createAnalyser();
            this.analyser.fftSize = 512;
            this.analyser.smoothingTimeConstant = 0.85;

            try {
                this.source = this.audioContext.createMediaElementSource(this.mediaElement);
                this.source.connect(this.analyser);
                this.analyser.connect(this.audioContext.destination);
                
                this.dataArray = new Uint8Array(this.analyser.frequencyBinCount);
                this.isActive = true;
                this.render();
            } catch (e) {}
        } catch (e) {}
    },

    resize() {
        if (!this.canvas) return;
        const footer = document.querySelector('footer');
        if (footer) {
            const dpr = window.devicePixelRatio || 1;
            this.canvas.width = footer.clientWidth * dpr;
            this.canvas.height = footer.clientHeight * dpr;
            this.ctx.scale(dpr, dpr);
        }
    },

    render() {
        if (!this.isActive) return;
        requestAnimationFrame(() => this.render());

        const width = this.canvas.width / (window.devicePixelRatio || 1);
        const height = this.canvas.height / (window.devicePixelRatio || 1);

        this.ctx.clearRect(0, 0, width, height);

        if (this.mediaElement.paused) return;
        if (this.audioContext.state === 'suspended') this.audioContext.resume();

        this.analyser.getByteFrequencyData(this.dataArray);

        const isDark = !document.body.classList.contains('light-theme');
        const points = [];
        const totalPoints = 12;
        const step = Math.floor(this.dataArray.length * 0.4 / totalPoints);

        points.push({ x: 0, y: height });

        for (let i = 0; i <= totalPoints; i++) {
            const dataIndex = i * step;
            const value = this.dataArray[dataIndex] || 0;
            const percent = value / 255;
            const x = (i / totalPoints) * width;
            const y = height - (percent * height * 0.7);
            points.push({ x, y });
        }

        points.push({ x: width, y: height });

        const gradient = this.ctx.createLinearGradient(0, 0, 0, height);
        if (isDark) {
            gradient.addColorStop(0, 'rgba(56, 189, 248, 0.0)');
            gradient.addColorStop(0.5, 'rgba(56, 189, 248, 0.15)');
            gradient.addColorStop(1, 'rgba(192, 132, 252, 0.4)');
        } else {
            gradient.addColorStop(0, 'rgba(99, 102, 241, 0.0)');
            gradient.addColorStop(0.5, 'rgba(99, 102, 241, 0.15)');
            gradient.addColorStop(1, 'rgba(236, 72, 153, 0.4)');
        }

        this.ctx.fillStyle = gradient;
        this.ctx.beginPath();
        this.ctx.moveTo(points[0].x, points[0].y);

        for (let i = 0; i < points.length - 1; i++) {
            const curr = points[i];
            const next = points[i + 1];
            const mx = (curr.x + next.x) / 2;
            const my = (curr.y + next.y) / 2;
            this.ctx.quadraticCurveTo(curr.x, curr.y, mx, my);
        }

        const last = points[points.length - 1];
        this.ctx.lineTo(last.x, last.y);
        this.ctx.lineTo(width, height);
        this.ctx.lineTo(0, height);
        this.ctx.closePath();
        this.ctx.fill();
    }
};

(function hookAudioToSpectrum() {
    // 劫持原有的 audioManager (如果存在)
    // 如果你是把代码整合进去，请直接修改 initMediaPreview 函数中的 audioManager.init 方法
    
    // 假设 audioManager 定义在 window 作用域或者闭包内
    // 这里我们提供一个思路：当播放时初始化频谱
    
    const originalPlay = window.HTMLAudioElement.prototype.play;
    window.HTMLAudioElement.prototype.play = function() {
        // 当任意 audio 元素播放时
        // 检查这个 audio 是否是我们用来预览文件的那个
        // 通常预览的 audio 是 js 动态创建的，没有 id，但我们可以无差别绑定
        
        // 仅当音频元素有 src 时才绑定
        if (this.src) {
            // 初始化频谱
            NavSpectrum.init(this);
        }
        return originalPlay.apply(this, arguments);
    };
})();



function initMediaPreview() {
    const preview = document.getElementById('mediaPreview');
    const img = document.getElementById('mediaPreviewImg');
    const video = document.getElementById('mediaPreviewVideo');
    const audioExts = ['mp3', 'wav', 'ogg', 'flac', 'm4a'];
    const imageExts = ['png', 'jpg', 'jpeg', 'gif', 'webp', 'ico', 'bmp', 'svg'];
    const videoExts = ['mp4', 'webm', 'ogg', 'mov', 'avi', 'mkv'];

    window.globalAudioManager = {
        audio: null,
        currentUrl: '',
        currentName: '',
        activeRequestId: 0, 

        init() {
            if (!this.audio) {
                this.audio = new Audio();
                this.audio.crossOrigin = 'anonymous';
                
                this.audio.addEventListener('ended', () => {
                    showToast(`播放结束: ${this.currentName}`);
                });
                
                this.audio.addEventListener('error', (e) => {
                    // 如果音频源被清空，忽略错误
                    if (!this.audio.src || this.audio.src === window.location.href) return;
                    
                    const error = e.target.error;
                    // 忽略被中断的错误（切歌时常见）
                    if (error.code === error.MEDIA_ERR_ABORTED) return;
                    
                    let msg = '播放出错';
                    if (error.code === error.MEDIA_ERR_NETWORK) msg = '网络错误，加载失败';
                    if (error.code === error.MEDIA_ERR_DECODE) msg = '音频格式损坏';
                    if (error.code === error.MEDIA_ERR_SRC_NOT_SUPPORTED) msg = '不支持的音频格式';
                    
                    showToast(msg, 'error');
                });
            }
        },

        async toggle(url, name) {
            this.init();
            const requestId = Date.now();
            this.activeRequestId = requestId;

            // 逻辑：暂停/继续
            if (this.currentUrl === url && this.audio.src) {
                if (this.audio.paused) {
                    this.audio.play().then(() => {
                        // 校验ID，防止过期的请求弹出提示
                        if (this.activeRequestId === requestId) {
                            showToast(`继续播放: ${name}`);
                        }
                    }).catch(() => {});
                } else {
                    this.audio.pause();
                    showToast(`已暂停: ${name}`);
                }
                return;
            }

            // 逻辑：切歌
            this.stop(); 
            
            this.activeRequestId = requestId; 
            this.currentUrl = url;
            this.currentName = name;
            this.audio.src = url;
            this.audio.currentTime = 0;

            showToast(`正在缓冲: ${name}...`);

            try {
                await this.audio.play();
                // 只有当ID依然匹配时才提示播放，防止切歌太快导致提示错乱
                if (this.activeRequestId === requestId) {
                    showToast(`正在播放: ${name}`);
                }
            } catch (error) {
                // 忽略主动中断的错误
                if (error.name !== 'AbortError') {
                    console.error(error);
                }
            }
        },

        stop() {
            if (this.audio) {
                this.audio.pause();
                // 关键：清空src可以停止浏览器后台下载，释放带宽
                this.audio.removeAttribute('src'); 
                this.audio.load();
                this.currentUrl = '';
            }
        }
    };

    preview.onclick = function(e) {
        if (e) {
            e.stopPropagation();
            e.preventDefault();
        }
        hideMediaPreview();
    };

    const fileListEl = document.getElementById('fileList');
    
    fileListEl.addEventListener('click', function(e) {
        if (state.isMultiSelectMode) return;
        if (e.target.classList.contains('multi-select-checkbox')) return;
        if (e.target.closest('.flex.gap-1, button')) return;

        const item = e.target.closest('.file-item');
        if (!item) return;

        const nameElement = item.querySelector('.file-name');
        const name = nameElement ? nameElement.textContent : '';
        const ext = name.split('.').pop()?.toLowerCase();
        
        const file = state.displayFiles.find(f => f.path === item.dataset.filePath) || 
                     state.files.find(f => f.name === name);

        if (!file || file.type !== 'file') return;

        const raw = file.download_url ? file.download_url : file.html_url.replace('github.com', 'raw.githubusercontent.com').replace('/blob/', '/');
        const url = getProxiedUrl(raw);

        // --- 音频处理 ---
        if (audioExts.includes(ext)) {
            e.preventDefault();
            e.stopPropagation();
            
            const nameWithoutExt = name.substring(0, name.lastIndexOf('.'));
            window.globalAudioManager.toggle(url, nameWithoutExt);
            return;
        }

        // --- 图片处理 ---
        if (imageExts.includes(ext)) {
            // 注意：这里没有调用 stop()，音乐继续播放
            
            const thumbImg = item.querySelector('.file-thumbnail');
            if (thumbImg && thumbImg.src && thumbImg.src.startsWith('blob:')) {
                img.src = thumbImg.src;
            } else {
                img.src = url;
            }
            
            img.style.cssText = ''; 
            img.removeAttribute('width');
            img.removeAttribute('height');
            
            video.style.display = 'none';
            img.style.display = 'block';
            
            preview.classList.remove('hidden');
            uiStateStack.push(hideMediaPreview);
            e.preventDefault();
            e.stopPropagation();
            return;
        }

        // --- 视频处理 ---
        if (videoExts.includes(ext)) {
            // 关键：看视频时必须停止音乐
            window.globalAudioManager.stop();
            
            video.src = url;
            video.style.display = 'block';
            img.style.display = 'none';
            
            preview.classList.remove('hidden');
            uiStateStack.push(hideMediaPreview);
            e.preventDefault();
            
            video.load();
            video.play().catch(() => {});
            return;
        }

    }, true);
}






             
             
             

function hideCreateRepoModal() {
    el.createRepoModal.classList.add('hidden');
    const index = uiStateStack.indexOf(hideCreateRepoModal);
    if (index > -1) uiStateStack.splice(index, 1);
}

function showCreateRepoModal() {
    el.createRepoNameInput.value = '';
    el.createRepoDescInput.value = '';
    el.createRepoPrivate.checked = true;
    el.repoNameError.style.display = 'none';
    el.createRepoModal.classList.remove('hidden');
    el.createRepoConfirm.disabled = true;
    function validateRepoName(name) {
        if (/[\u4e00-\u9fa5]/.test(name)) return '仓库名称不能包含中文字符';
        if (name.length > 100) return '仓库名称不能超过100个字符';
        if (name.startsWith('.') || name.endsWith('.')) return '仓库名称不能以点号开头或结尾';
        return null;
    }
    el.createRepoNameInput.oninput = function() {
        this.value = this.value.replace(/[\u4e00-\u9fa5]/g, '');
        const name = el.createRepoNameInput.value.trim();
        const error = validateRepoName(name);
        if (error) {
            el.repoNameError.textContent = error;
            el.repoNameError.style.display = 'block';
            el.createRepoConfirm.disabled = true;
        } else {
            el.repoNameError.style.display = 'none';
            el.createRepoConfirm.disabled = !name;
        }
    };
    el.createRepoConfirm.onclick = async function() {
        const name = el.createRepoNameInput.value.trim();
        const description = el.createRepoDescInput.value.trim();
        const isPrivate = !el.createRepoPrivate.checked;
        const error = validateRepoName(name);
        
        if (error || !name) return;

        this.disabled = true;
        this.classList.add('btn-processing');
        this.innerHTML = '创建中 <i class="fa fa-spinner fa-spin"></i>';
        
        try {
            const res = await fetch('https://api.github.com/user/repos', {
                method: 'POST',
                headers: { 
                    'Authorization': `token ${state.token}`, 
                    'Content-Type': 'application/json', 
                    'User-Agent': 'Mozilla/5.0' 
                },
                body: JSON.stringify({ 
                    name: name, 
                    description: description || undefined, 
                    private: isPrivate, 
                    auto_init: true 
                })
            });

            if (!res.ok) {
                const errData = await res.json().catch(() => ({}));
                throw new Error(errData.message || '创建仓库失败');
            }
            
            showToast(`仓库 "${name}" 创建成功`, 'success');
            hideCreateRepoModal();
            await fetchRepos(true, true);

        } catch (e) {
            showToast(`创建失败: ${e.message}`, 'error');
        } finally {
            if (el.createRepoModal.classList.contains('hidden')) {
                this.innerHTML = '创建仓库';
                this.classList.remove('btn-processing');
                this.disabled = false;
            } else {
                this.disabled = false;
                this.classList.remove('btn-processing');
                this.innerHTML = '创建仓库';
            }
        }
    };
    uiStateStack.push(hideCreateRepoModal);
}

function hideApiStatusPanel() {
    el.apiStatusOverlay.classList.remove('open');
    el.apiStatusPanel.classList.remove('open');
    setTimeout(() => {
        el.apiStatusOverlay.classList.add('hidden');
    }, 300);
    const index = uiStateStack.indexOf(hideApiStatusPanel);
    if (index > -1) uiStateStack.splice(index, 1);
}

function showApiStatusPanel() {
    el.apiStatusOverlay.classList.remove('hidden');
    setTimeout(() => {
        el.apiStatusOverlay.classList.add('open');
        el.apiStatusPanel.classList.add('open');
    }, 10);
    fetchAndRenderApiStatus();
    uiStateStack.push(hideApiStatusPanel);
}

async function fetchAndRenderApiStatus() {
    const contentEl = document.getElementById('apiStatusContent');
    contentEl.innerHTML = `<div class="loading-spinner" style="height: auto; padding: 2rem 0;"><div class="spinner"></div></div>`;
    
    try {
        const res = await fetch('https://api.github.com/rate_limit', {
            headers: { Authorization: `token ${state.token}`, 'User-Agent': 'Mozilla/5.0' },
            cache: 'no-store'
        });
        
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        
        const data = await res.json();
        const resources = data.resources;
        let html = '';

        const generateCard = (key, name, icon) => {
            const item = resources[key];
            if (!item) return '';
            
            const limit = item.limit;
            const used = item.used;
            const remaining = item.remaining;
            const resetDate = new Date(item.reset * 1000);
            const resetTimeStr = resetDate.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
            
            const percentUsed = limit > 0 ? (used / limit) * 100 : 0;
            const percentRemaining = 100 - percentUsed;
            
            let statusClass = 'status-good';
            let progressClass = 'progress-green';
            let iconColor = '#10b981';

            if (percentRemaining < 5) {
                statusClass = 'status-critical';
                progressClass = 'progress-red';
                iconColor = '#ef4444';
            } else if (percentRemaining < 25) {
                statusClass = 'status-warning';
                progressClass = 'progress-yellow';
                iconColor = '#f59e0b';
            }

            let refreshText = '';
            if (key === 'core') refreshText = '重置周期: 1小时';
            if (key === 'search') refreshText = '重置周期: 1分钟';

            return `
            <div class="api-status-card ${statusClass}">
                <h4>
                    <i class="fa ${icon}" style="color: ${iconColor};"></i>
                    ${name} API
                </h4>
                <div class="rate-limit-details">
                    <p>总额度: <span>${limit}</span></p>
                    <p>已使用: <span>${used}</span></p>
                    <p>剩余可用: <span class="highlight-value" style="font-size: 1.1em;">${remaining}</span></p>
                </div>
                <div class="rate-limit-progress-bar">
                    <div class="${progressClass}" style="width: ${percentUsed}%;"></div>
                </div>
                <div class="rate-limit-details" style="margin-top: 4px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.05);">
                    <p>${refreshText} <span class="refresh-badge">${resetTimeStr} 重置</span></p>
                </div>
            </div>`;
        };

        html += generateCard('core', '核心 (Core)', 'fa-cube');
        html += generateCard('search', '搜索 (Search)', 'fa-search');
        html += generateCard('graphql', 'GraphQL', 'fa-project-diagram');

        const scopesHeader = res.headers.get('x-oauth-scopes');
        let scopesHtml = '';
        if (scopesHeader) {
            const scopes = scopesHeader.split(', ');
            const badges = scopes.map(s => `<span class="token-scope">${s}</span>`).join('');
            scopesHtml = `
                <div class="api-status-card">
                    <h4><i class="fa fa-shield-alt"></i> Token 权限范围</h4>
                    <div class="token-scopes">${badges}</div>
                </div>
            `;
        } else {
            scopesHtml = `
                <div class="api-status-card status-warning">
                    <h4><i class="fa fa-shield-alt"></i> Token 权限</h4>
                    <p style="font-size: 0.8rem; color: #94a3b8;">
                        无法获取具体权限（可能是细粒度 Token），请确保拥有 repo 相关权限。
                    </p>
                </div>
            `;
        }

        html += scopesHtml;
        contentEl.innerHTML = html;

    } catch (error) {
        contentEl.innerHTML = `
            <div class="api-status-card status-critical">
                <h4><i class="fa fa-exclamation-triangle"></i> 数据获取失败</h4>
                <p style="color: #f87171; font-size: 0.85rem;">${error.message}</p>
                <button onclick="handleRefreshApiStatus()" class="btn btn-secondary btn-sm" style="margin-top:10px; width:100%;">重试</button>
            </div>
        `;
    }
}

function toggleEditorSearch(show) {
    const { editorSearchPanel, editorSearchInput } = el;
    if (show) {
        editorSearchPanel.classList.remove('hidden');
        editorSearchInput.focus();
        editorSearchInput.select();
        performEditorSearch();
    } else {
        editorSearchPanel.classList.add('hidden');
        state.editorSearchState = { query: '', matches: [], currentIndex: -1 };
        el.editorSearchInput.value = '';
        updateSearchUI();
        if (aceEditorInstance) {
            aceEditorInstance.clearSelection();
            aceEditorInstance.focus();
        }
    }
}

function performEditorSearch() {
    const query = el.editorSearchInput.value;
    if (!aceEditorInstance) return;
    
    const content = aceEditorInstance.getValue();
    state.editorSearchState.query = query;

    if (!query) {
        state.editorSearchState.matches = [];
        state.editorSearchState.currentIndex = -1;
    } else {
        const queryLower = query.toLowerCase();
        const contentLower = content.toLowerCase();
        const matches = [];
        let startIndex = 0;
        let index;
        while ((index = contentLower.indexOf(queryLower, startIndex)) > -1) {
            matches.push(index);
            startIndex = index + queryLower.length;
        }
        state.editorSearchState.matches = matches;
        state.editorSearchState.currentIndex = matches.length > 0 ? 0 : -1;
    }
    
    updateSearchUI();
    if (state.editorSearchState.currentIndex !== -1) {
        highlightCurrentMatch();
    }
}

function navigateSearchMatches(direction) {
    const { matches } = state.editorSearchState;
    const total = matches.length;
    if (total <= 0) return;

    let newIndex = state.editorSearchState.currentIndex + direction;

    if (newIndex < 0) {
        newIndex = total - 1;
    } else if (newIndex >= total) {
        newIndex = 0;
    }

    state.editorSearchState.currentIndex = newIndex;
    updateSearchUI();
    highlightCurrentMatch();
}

function highlightCurrentMatch() {
    const { matches, currentIndex, query } = state.editorSearchState;
    if (currentIndex === -1 || !aceEditorInstance) return;

    const startCharIndex = matches[currentIndex];
    const endCharIndex = startCharIndex + query.length;

    const doc = aceEditorInstance.session.getDocument();
    const startPos = doc.indexToPosition(startCharIndex, 0);
    const endPos = doc.indexToPosition(endCharIndex, 0);

    const range = new ace.Range(startPos.row, startPos.column, endPos.row, endPos.column);
    
    aceEditorInstance.selection.setRange(range);
    aceEditorInstance.centerSelection();
}


function updateSearchUI() {
    const { matches, currentIndex } = state.editorSearchState;
    const total = matches.length;
    
    if (total > 0) {
        el.editorSearchMatchCount.textContent = `${currentIndex + 1} / ${total}`;
    } else {
        el.editorSearchMatchCount.textContent = '0 / 0';
    }

    el.editorSearchPrevBtn.disabled = total <= 1;
    el.editorSearchNextBtn.disabled = total <= 1;
}




function getErrorMessage(error) {
    const msg = error.message || '';
    if (msg.includes('404')) return '资源不存在 (404)，可能已被删除';
    if (msg.includes('403')) return 'API 请求过于频繁，请稍后再试';
    if (msg.includes('401')) return 'Token 无效或已过期，请重新登录';
    if (msg.includes('Failed to fetch') || msg.includes('NetworkError')) return '网络连接失败，请检查网络';
    if (msg.includes('timeout')) return '请求超时，请重试';
    return msg || '未知错误';
}

async function handleRefresh() {
    const view = state.currentView;
    const targetListEl = !el.repoList.classList.contains('hidden') ? el.repoList : el.fileList;

    if (targetListEl === el.fileList) {
        await fetchFiles(true, false);
        return;
    }

    switch (view) {
        case 'own_repos':
            await fetchRepos(true, false);
            break;
        case 'starred_repos':
            await fetchStarredRepos(true, false, false);
            break;
        case 'other_user_repos':
            if (state.viewingOwner) {
                await _renderAndFetchUserRepos(state.viewingOwner, false);
            }
            break;
        case 'public_search_results':
            const query = el.currentRepo.textContent.replace('公共仓库搜索: "', '').slice(0, -1);
            await searchPublicRepositories(query, state.publicSearchPage, false, false);
            break;
        case 'releases_list':
            if (state.viewingReleasesForRepo) {
                await fetchAndDisplayReleases(state.viewingReleasesForRepo, false);
            }
            break;
        case 'assets_list':
            await refreshAssetsList();
            break;
        default:
            await fetchRepos(true, false);
            break;
    }
}

function initPullToRefresh() {
    const mainEl = document.querySelector('main');
    const ptrIndicator = document.getElementById('pull-to-refresh');

    if (!mainEl || !ptrIndicator) return;

    let targetListEl = null;
    let isDragging = false;
    let startX = 0;
    let hasVibrated = false;

    const resetPullState = () => {
        ptrIndicator.classList.remove('visible', 'ready', 'refreshing');
        ptrIndicator.style.transition = 'transform 0.4s cubic-bezier(0.25, 1, 0.5, 1)';
        if (targetListEl) {
            targetListEl.style.transition = 'transform 0.4s cubic-bezier(0.25, 1, 0.5, 1)';
            targetListEl.style.transform = 'translateY(0px)';
        }
        state.pullToRefresh.active = false;
        state.pullToRefresh.pullDistance = 0;
        isDragging = false;
        hasVibrated = false;
    };

    mainEl.addEventListener('touchstart', (e) => {
        if (mainEl.scrollTop === 0) {
            state.pullToRefresh.startY = e.touches[0].clientY;
            startX = e.touches[0].clientX;
            state.pullToRefresh.active = true;
            isDragging = true;
            hasVibrated = false;
            
            targetListEl = !el.repoList.classList.contains('hidden') ? el.repoList : 
                           !el.fileList.classList.contains('hidden') ? el.fileList : null;
            
            if(targetListEl) {
                ptrIndicator.style.transition = 'none';
                targetListEl.style.transition = 'none';
            }
        }
    }, { passive: true });

    mainEl.addEventListener('touchmove', (e) => {
        if (!state.pullToRefresh.active || !isDragging || !targetListEl) return;

        const currentY = e.touches[0].clientY;
        const currentX = e.touches[0].clientX;
        
        let deltaY = currentY - state.pullToRefresh.startY;
        let deltaX = currentX - startX;

        if (Math.abs(deltaX) > Math.abs(deltaY) && deltaY < 10) {
            state.pullToRefresh.active = false;
            return;
        }

        if (deltaY < 0) deltaY = 0;
        if (deltaY > 0 && mainEl.scrollTop === 0) {
            if (e.cancelable) e.preventDefault();
        }
        
        state.pullToRefresh.pullDistance = deltaY;

        if (deltaY > 0) {
            ptrIndicator.classList.add('visible');
            
            const dampFactor = 0.5;
            const maxDrag = window.innerHeight * 0.4;
            const dampedDistance = (deltaY * dampFactor * maxDrag) / (deltaY * dampFactor + maxDrag);

            ptrIndicator.style.transform = `translateY(${dampedDistance - 50}px)`;
            targetListEl.style.transform = `translateY(${dampedDistance}px)`;
            
            if (dampedDistance > state.pullToRefresh.threshold) {
                if (!ptrIndicator.classList.contains('ready')) {
                    ptrIndicator.classList.add('ready');
                    if (!hasVibrated && navigator.vibrate) {
                        navigator.vibrate(15);
                        hasVibrated = true;
                    }
                }
            } else {
                ptrIndicator.classList.remove('ready');
                hasVibrated = false;
            }
        }
    }, { passive: false });

    mainEl.addEventListener('touchend', async () => {
        if (!state.pullToRefresh.active || !targetListEl) return;

        if (state.isRefreshing) {
            resetPullState();
            return;
        }

        const deltaY = state.pullToRefresh.pullDistance;
        const dampFactor = 0.5;
        const maxDrag = window.innerHeight * 0.4;
        const dampedDistance = (deltaY * dampFactor * maxDrag) / (deltaY * dampFactor + maxDrag);

        if (dampedDistance > state.pullToRefresh.threshold) {
            ptrIndicator.classList.add('refreshing');
            ptrIndicator.classList.remove('ready');
            
            ptrIndicator.style.transition = 'transform 0.3s ease';
            targetListEl.style.transition = 'transform 0.3s ease';
            
            ptrIndicator.style.transform = `translateY(${state.pullToRefresh.threshold - 50}px)`;
            targetListEl.style.transform = `translateY(${state.pullToRefresh.threshold}px)`;
            
            state.isRefreshing = true; 
            
            const timeoutPromise = new Promise((_, reject) => 
                setTimeout(() => reject(new Error('请求超时')), 8000)
            );

            try {
                await Promise.race([handleRefresh(), timeoutPromise]);
                showToast('刷新成功', 'success');
            } catch (error) {
                let errorMsg = '刷新失败';
                if (error.message === '请求超时') {
                    errorMsg = '网络请求超时，请重试';
                } else if (typeof getErrorMessage === 'function') {
                    errorMsg = getErrorMessage(error);
                } else if (error.message) {
                    errorMsg = error.message;
                }
                showToast(errorMsg, 'error');
            } finally {
                setTimeout(() => {
                    resetPullState();
                    state.isRefreshing = false;
                }, 500);
            }

        } else {
            resetPullState();
        }
        state.pullToRefresh.active = false;
        isDragging = false;
    });
}




async function publishProjectSite(repo, branchName) {
    try {
        const pagesRes = await fetch(`https://api.github.com/repos/${repo.full_name}/pages`, {
            method: 'POST',
            headers: { 'Authorization': `token ${state.token}`, 'Content-Type': 'application/json' },
            body: JSON.stringify({ source: { branch: branchName, path: "/" } })
        });

        if (pagesRes.status === 409) {
            return { success: true, message: '网站已存在或正在构建中。' };
        }
        
        if (!pagesRes.ok) {
            let errorMessage;
            if (pagesRes.status === 422) errorMessage = '仓库为空或分支无效。';
            else if (pagesRes.status === 403) errorMessage = '权限不足。';
            else errorMessage = `发生未知网络错误 (HTTP ${pagesRes.status})。`;
            throw new Error(errorMessage);
        }

        return { success: true, message: '发布成功！' };
    } catch (error) {
        console.error(`发布仓库 ${repo.name} 失败:`, error);
        return { success: false, message: error.message };
    }
}




async function unpublishSite(repo) {
    try {
        const res = await fetch(`https://api.github.com/repos/${repo.full_name}/pages`, {
            method: 'DELETE',
            headers: { 'Authorization': `token ${state.token}` }
        });
        if (!res.ok && res.status !== 404) {
            let errorMessage;
            if (res.status === 403) errorMessage = '权限不足。';
            else errorMessage = `发生未知网络错误 (HTTP ${res.status})。`;
            throw new Error(errorMessage);
        }
        
        const updatedRepo = await fetchSingleRepoState(repo.full_name);
        updateSingleRepoInStateAndUI(updatedRepo);
        
        return { success: true, message: '取消发布成功！' };
    } catch (error) {
        console.error(`取消发布仓库 ${repo.name} 失败:`, error);
        return { success: false, message: error.message };
    }
}









function renderPublishManagerLists() {
    // 1. 处理选项卡 UI 状态
    if (state.publishManagerActiveTab === 'official') {
        el.officialConfigTabBtn.classList.add('active');
        el.customDomainTabBtn.classList.remove('active');
    } else {
        el.officialConfigTabBtn.classList.remove('active');
        el.customDomainTabBtn.classList.add('active');
    }

    const listEl = el.publishManageList;
    
    // 2. [核心优化] 记录当前滚动位置，防止列表跳动
    const previousScrollTop = listEl.scrollTop;

    // 3. [核心优化] 同步读取二级缓存 (LocalStorage) 实现毫秒级数据回填
    // 解决了 IndexedDB 异步读取导致的 "切换瞬间数据丢失" 问题
    let syncDomainCache = {};
    try {
        syncDomainCache = JSON.parse(localStorage.getItem('sync_domain_cache') || '{}');
    } catch (e) {}

    // 4. [核心优化] 瞬时修补内存数据
    // 在渲染前，强制检查内存中是否丢失了域名，如果丢失且缓存中有，立即补上
    state.repos.forEach(repo => {
        if (repo.has_pages && !repo.customDomain && syncDomainCache[repo.full_name]) {
            repo.customDomain = syncDomainCache[repo.full_name];
        }
    });

    // 准备渲染数据
    let mainSiteRepo = null;
    if (state.user && state.user.login) {
        const mainSiteName = `${state.user.login}.github.io`;
        mainSiteRepo = state.repos.find(r => r.name === mainSiteName);
    }
    const mainSiteExists = !!mainSiteRepo;
    const isActiveTabOfficial = state.publishManagerActiveTab === 'official';
    let reposToRender;

    if (isActiveTabOfficial) {
        const otherPublicRepos = state.repos.filter(r => !r.private && (!mainSiteRepo || r.id !== mainSiteRepo.id));
        const publishedRepos = otherPublicRepos.filter(r => r.has_pages);
        const unpublishedRepos = otherPublicRepos.filter(r => !r.has_pages);
        publishedRepos.sort((a, b) => a.name.localeCompare(b.name));
        unpublishedRepos.sort((a, b) => a.name.localeCompare(b.name));
        reposToRender = mainSiteRepo ? [mainSiteRepo, ...publishedRepos, ...unpublishedRepos] : [...publishedRepos, ...unpublishedRepos];
    } else {
        // 自定义域名 Tab：只显示已发布或有域名的仓库
        let publishedRepos = state.repos.filter(r => r.has_pages || r.customDomain);
        if (mainSiteRepo && (mainSiteRepo.has_pages || mainSiteRepo.customDomain)) {
            // 确保主站也在列表中（如果在上面已被过滤）
            if (!publishedRepos.find(r => r.id === mainSiteRepo.id)) {
                publishedRepos.push(mainSiteRepo);
            }
        }
        
        let otherRepos = publishedRepos.filter(r => !mainSiteRepo || r.id !== mainSiteRepo.id);
        
        otherRepos.sort((a, b) => {
            const aHasDomain = !!a.customDomain;
            const bHasDomain = !!b.customDomain;
            if (aHasDomain && !bHasDomain) return -1;
            if (!aHasDomain && bHasDomain) return 1;
            return a.name.localeCompare(b.name);
        });
        
        reposToRender = mainSiteRepo ? [mainSiteRepo, ...otherRepos] : otherRepos;
    }

    // 5. 开始渲染 DOM
    listEl.innerHTML = '';

    if (reposToRender.length === 0) {
        const emptyMessage = isActiveTabOfficial
            ? '没有可管理的公开项目'
            : '没有已发布的项目网站';
        listEl.innerHTML = `<p class="publish-list-empty">${emptyMessage}</p>`;
    } else {
        const fragment = document.createDocumentFragment();
        const mainSiteHasCustomDomain = mainSiteRepo && mainSiteRepo.customDomain;
        const projectSiteHasDomain = state.repos.some(r => r.has_pages && r.customDomain && (!mainSiteRepo || r.id !== mainSiteRepo.id));
        
        // 用于收集最新数据的临时对象
        let newCacheData = { ...syncDomainCache };
        let cacheChanged = false;

        reposToRender.forEach(repo => {
            // 收集数据用于反向更新缓存
            if (repo.customDomain) {
                if (newCacheData[repo.full_name] !== repo.customDomain) {
                    newCacheData[repo.full_name] = repo.customDomain;
                    cacheChanged = true;
                }
            }

            const item = document.createElement('div');
            item.className = 'publish-item';
            
            if (repo.has_pages) {
                item.classList.add('is-published');
                item.title = '点击复制网站链接';
            }

            if (isActiveTabOfficial) {
                const isPublished = repo.has_pages;
                const isMainSite = mainSiteRepo && repo.id === mainSiteRepo.id;
                let actionButtonHTML = '';

                if (isMainSite) {
                    if (isPublished && !repo.customDomain) {
                        actionButtonHTML = `<button class="btn btn-unpublish btn-sm main-site-action-btn">取消主站</button>`;
                    }
                } else {
                    if (isPublished) {
                        if (!repo.customDomain) {
                            actionButtonHTML = `<button class="btn btn-unpublish btn-sm project-action-btn">取消项目</button>`;
                        }
                    } else {
                        actionButtonHTML = `<button class="btn btn-primary btn-sm project-action-btn">发布项目</button>`;
                    }
                }

                const showSetAsMainSiteButton = !isMainSite && !repo.customDomain && !mainSiteExists;

                item.innerHTML = `
                    <span class="repo-name" title="${repo.name}">${repo.name}</span>
                    <div class="publish-item-actions">
                        ${showSetAsMainSiteButton ? `<button class="btn btn-secondary btn-sm set-as-main-site-btn" data-repo-fullname="${repo.full_name}">发布为主站</button>` : ''}
                        ${actionButtonHTML}
                    </div>
                `;
                
                // 绑定事件 (保持原有逻辑)
                if (isMainSite) {
                    const btn = item.querySelector('.main-site-action-btn');
                    if (btn) btn.onclick = () => showUnpublishMainSiteModal(repo);
                } else {
                    const btn = item.querySelector('.project-action-btn');
                    if (btn) {
                        if (isPublished) {
                            btn.onclick = () => {
                                showDeleteModal(null, false, '确认取消发布', `确定要取消发布 "${repo.name}" 吗？`, async () => {
                                    btn.textContent = '处理中...'; btn.disabled = true;
                                    const res = await unpublishSite(repo);
                                    showToast(res.message, res.success ? 'success' : 'error');
                                    if(res.success) {
                                        const r = state.repos.find(x => x.id === repo.id);
                                        if(r) r.has_pages = false;
                                        renderPublishManagerLists();
                                    }
                                }, '确认取消', 'btn-danger');
                            };
                        } else {
                            btn.dataset.repoFullname = repo.full_name;
                            btn.onclick = () => showPublishBranchSelectorModal(repo, 'projectSite');
                        }
                    }
                }

            } else {
                // 自定义域名 Tab 渲染逻辑
                const isMainSite = mainSiteRepo && repo.id === mainSiteRepo.id;
                let showConfigureButton = false;
                if(isMainSite) {
                    showConfigureButton = !projectSiteHasDomain;
                } else {
                    showConfigureButton = !mainSiteHasCustomDomain;
                }

                let actionButtonsHTML = '';
                if (repo.customDomain) {
                    actionButtonsHTML += `<button class="btn btn-unpublish btn-sm remove-domain-btn" data-repo-fullname="${repo.full_name}">取消绑定</button>`;
                }
                if (showConfigureButton) {
                    actionButtonsHTML += `<button class="btn btn-primary btn-sm configure-domain-btn" data-repo-fullname="${repo.full_name}">配置域名</button>`;
                }
                
                item.innerHTML = `
                    <div class="repo-info-wrapper">
                        <span class="repo-name" title="${repo.name}">${repo.name}</span>
                        ${repo.customDomain ? `<p class="repo-domain-display">${repo.customDomain}</p>` : ''}
                    </div>
                    <div class="publish-item-actions">
                        ${actionButtonsHTML}
                    </div>
                `;
            }
            
            // 通用点击事件 (复制链接)
            item.addEventListener('click', (e) => {
                if (e.target.closest('button')) return;
                
                if (state.publishManagerActiveTab === 'official') {
                    if (!repo.has_pages) {
                        showToast('未发布静态网页'); return;
                    }
                    const isMain = state.user && repo.name === `${state.user.login}.github.io`;
                    const url = isMain ? `https://${repo.owner.login}.github.io/` : `https://${repo.owner.login}.github.io/${repo.name}/`;
                    navigator.clipboard.writeText(url).then(() => showToast('链接已复制')).catch(() => showToast('复制失败'));
                } else {
                    if (repo.customDomain) {
                        navigator.clipboard.writeText(`https://${repo.customDomain}`).then(() => showToast('域名已复制'));
                    } else {
                        showToast('未配置域名');
                    }
                }
            });
            
            fragment.appendChild(item);
        });
        
        listEl.appendChild(fragment);

        // 6. [核心优化] 反向更新缓存
        // 如果本次渲染发现有新域名（可能来自后台更新），保存到 localStorage 供下次同步使用
        if (cacheChanged) {
            localStorage.setItem('sync_domain_cache', JSON.stringify(newCacheData));
        }
    }

    // 7. [核心优化] 恢复滚动位置
    if (previousScrollTop > 0) {
        listEl.scrollTop = previousScrollTop;
    }
}



function showPublishHelpModal() {
    el.publishHelpModal.classList.remove('hidden');
    uiStateStack.push(hidePublishHelpModal);
}

function hidePublishHelpModal() {
    el.publishHelpModal.classList.add('hidden');
    const index = uiStateStack.indexOf(hidePublishHelpModal);
    if (index > -1) uiStateStack.splice(index, 1);
}


function showUsageGuideModal() {
    hideMainMenuPopup();
    el.usageGuideModal.classList.remove('hidden');
    uiStateStack.push(hideUsageGuideModal);
}

function hideUsageGuideModal() {
    el.usageGuideModal.classList.add('hidden');
    const index = uiStateStack.indexOf(hideUsageGuideModal);
    if (index > -1) uiStateStack.splice(index, 1);
}

async function showPublishManagerModal() {
    hideMainMenuPopup();
    state.publishManagerActiveTab = 'official';
    el.publishManagerModal.classList.remove('hidden');
    uiStateStack.push(hidePublishManagerModal);

    el.publishManageList.innerHTML = '<div class="loading-spinner"><i class="fa fa-spinner fa-spin"></i></div>';

    const CACHE_KEY = 'custom_domains_cache';
    try {
        const cachedDomains = (await SimpleDB.get(CACHE_KEY)) || {};
        state.repos.forEach(repo => {
            if (repo.has_pages && cachedDomains[repo.full_name] !== undefined) {
                repo.customDomain = cachedDomains[repo.full_name];
            }
        });
    } catch (e) {}

    renderPublishManagerLists();
}




async function smartPreloadCNAMEs() {
    const pagesRepos = state.repos.filter(r => r.has_pages);
    if (pagesRepos.length === 0) return;

    const CACHE_KEY = 'custom_domains_cache';
    let cachedDomains = {};

    try {
        cachedDomains = (await SimpleDB.get(CACHE_KEY)) || {};
    } catch (e) {}

    let hasInitialCacheUpdate = false;
    pagesRepos.forEach(repo => {
        if (cachedDomains[repo.full_name] && repo.customDomain !== cachedDomains[repo.full_name]) {
            repo.customDomain = cachedDomains[repo.full_name];
            hasInitialCacheUpdate = true;
        }
    });

    if (hasInitialCacheUpdate && !document.getElementById('publishManagerModal').classList.contains('hidden')) {
        renderPublishManagerLists();
    }

    const runFetch = async () => {
        const BATCH_SIZE = 8;
        let globalCacheChanged = false;

        for (let i = 0; i < pagesRepos.length; i += BATCH_SIZE) {
            const batch = pagesRepos.slice(i, i + BATCH_SIZE);
            let batchChanged = false;

            await Promise.all(batch.map(async (repo) => {
                try {
                    const url = `https://api.github.com/repos/${repo.full_name}/contents/CNAME`;
                    const res = await fetch(url, {
                        headers: { 'Authorization': `token ${state.token}` },
                        cache: 'no-store'
                    });

                    if (res.ok) {
                        const data = await res.json();
                        const remoteDomain = atob(data.content).trim();

                        if (repo.customDomain !== remoteDomain) {
                            repo.customDomain = remoteDomain;
                            cachedDomains[repo.full_name] = remoteDomain;
                            batchChanged = true;
                            globalCacheChanged = true;
                        }
                    } else if (res.status === 404) {
                        if (repo.customDomain) {
                            repo.customDomain = null;
                            if (cachedDomains[repo.full_name]) {
                                delete cachedDomains[repo.full_name];
                                batchChanged = true;
                                globalCacheChanged = true;
                            }
                        }
                    }
                } catch (e) {
                    console.warn(e);
                }
            }));

            if (batchChanged) {
                if (!document.getElementById('publishManagerModal').classList.contains('hidden')) {
                    renderPublishManagerLists();
                }
            }

            if (i + BATCH_SIZE < pagesRepos.length) {
                await new Promise(r => setTimeout(r, 200));
            }
        }

        if (globalCacheChanged) {
            await SimpleDB.set(CACHE_KEY, cachedDomains);
        }
    };

    runFetch();
}




function hidePublishManagerModal() {
    el.publishManagerModal.classList.add('hidden');
    const index = uiStateStack.indexOf(hidePublishManagerModal);
    if (index > -1) uiStateStack.splice(index, 1);

    if (!el.repoList.classList.contains('hidden')) {
        state.shouldAnimateList = false;
        renderRepoList();
    }
}


function parseGithubUrl(url) {
    const patterns = [
        /(?:https?:\/\/)?(?:www\.)?github\.com\/([a-zA-Z0-9_-]+)\/?$/,
        /(?:https?:\/\/)?(?:www\.)?github\.com\/([a-zA-Z0-9_-]+)\/([a-zA-Z0-9_.-]+)(?:\/tree\/[^\/]+\/(.*))?/,
        /(?:https?:\/\/)?(?:www\.)?github\.com\/([a-zA-Z0-9_-]+)\/([a-zA-Z0-9_.-]+)\/?$/
    ];

    for (const pattern of patterns) {
        const match = url.match(pattern);
        if (match) {
            return {
                owner: match[1],
                repo: match[2] || null,
                path: match[3] || ''
            };
        }
    }
    return null;
}






async function searchPublicRepositories(query, page = 1, updateHistory = true, showMainLoader = true) {
    if (!query) return;
    state.publicSearchQuery = query;
    state.publicSearchPage = page;
    
    // 核心修复：先强制设置当前视图状态，确保后续UI渲染逻辑正确
    state.currentView = 'public_search_results';

    const cacheKey = `${query}_${page}`;
    
    // 尝试读取缓存
    if (state.publicSearchCache.has(cacheKey)) {
        const cachedResults = state.publicSearchCache.get(cacheKey);
        
        // 核心修复：从缓存中恢复总数，这对分页按钮至关重要
        state.publicSearchTotalResults = cachedResults.total_count;
        
        if (showMainLoader) {
            toggleView(true);
            el.currentRepo.textContent = `公共仓库搜索: "${query}"`;
            renderRepoList(cachedResults.items);
            
            setTimeout(() => { el.main.scrollTop = state.repoListScrollPosition; }, 0);
        } else {
            // 如果是静默更新（如popstate），也要确保列表渲染
            renderRepoList(cachedResults.items);
        }
        
        updateHomeStarredButtonState();
        updateGlobalSearchVisibility();
        updatePaginationUI();
        return; 
    }

    // 无缓存，走网络请求
    if (showMainLoader) {
        el.repoList.innerHTML = '<div class="loading-spinner"><div class="spinner"></div></div>';
        toggleView(true);
        el.currentRepo.textContent = `公共仓库搜索: "${query}"`;
    }

    if (updateHistory) {
        history.pushState({ view: 'public_search_results', query: query, page: page }, '', window.location.pathname);
    }

    updateHomeStarredButtonState();
    updateGlobalSearchVisibility();

    try {
        const url = `https://api.github.com/search/repositories?q=${encodeURIComponent(query)}&page=${page}&per_page=${state.publicSearchPerPage}`;
        const res = await fetch(url, { headers: { Authorization: `token ${state.token}` } });
        
        if (!res.ok) {
            if (res.status === 403) {
                 throw new Error('API请求频率超限，请稍后再试。');
            }
            throw new Error('搜索失败，请检查网络或API配额');
        }

        const data = await res.json();
        
        // 核心修复：更新总数
        state.publicSearchTotalResults = data.total_count;
        
        state.publicSearchCache.set(cacheKey, { items: data.items, total_count: data.total_count });
        
        renderRepoList(data.items);

    } catch (error) {
        showToast(error.message, 'error');
        el.repoList.innerHTML = `<div class="empty-state"><p>${error.message}</p></div>`;
    } finally {
        updatePaginationUI(); 
    }
}







function updatePaginationUI() {
    const backBtn = el.backBtn;
    const newFolderBtn = el.newFolderBtn;
    const newFileBtn = el.newFileBtn;
    const uploadBtn = el.uploadBtn;
    const newReleaseBtn = el.newReleaseBtn;
    const footer = document.querySelector('footer');

    // 1. 全局重置：先隐藏所有，清空内容，移除事件
    [backBtn, newFolderBtn, newFileBtn, uploadBtn, newReleaseBtn].forEach(btn => {
        btn.classList.add('hidden');
        btn.classList.remove('disabled');
        btn.onclick = null;
        btn.innerHTML = '';
        btn.title = '';
    });
    footer.style.display = '';

    switch (state.currentView) {
        
        // === 场景 A: 公共仓库搜索结果 ===
        // 必须显示：返回按钮 + 分页按钮(如果有)
        case 'public_search_results':
            backBtn.classList.remove('hidden');
            backBtn.innerHTML = '<i class="fa-solid fa-arrow-up"></i>';
            backBtn.title = '返回';
            backBtn.onclick = goUp;
            
            // 确保总页数有效
            const totalSearchPages = (state.publicSearchTotalResults && state.publicSearchPerPage) 
                ? Math.ceil(state.publicSearchTotalResults / state.publicSearchPerPage) 
                : 1;
            const currentSearchPage = state.publicSearchPage || 1;

            if (totalSearchPages > 1) {
                // 上一页
                newFolderBtn.classList.remove('hidden');
                newFolderBtn.innerHTML = '<i class="fa-solid fa-arrow-left"></i>';
                newFolderBtn.title = '上一页';
                newFolderBtn.onclick = handlePrevPage;
                newFolderBtn.classList.toggle('disabled', currentSearchPage <= 1);

                // 下一页
                newFileBtn.classList.remove('hidden');
                newFileBtn.innerHTML = '<i class="fa-solid fa-arrow-right"></i>';
                newFileBtn.title = '下一页';
                newFileBtn.onclick = handleNextPage;
                newFileBtn.classList.toggle('disabled', currentSearchPage >= totalSearchPages);
            }
            break;

        // === 场景 B: 仓库文件列表 (核心逻辑) ===
        case 'file_list':
            backBtn.classList.remove('hidden');
            backBtn.innerHTML = '<i class="fa-solid fa-arrow-up"></i>';
            backBtn.title = '返回上级';
            backBtn.onclick = goUp;

            const isOwner = state.user && state.viewingOwner === state.user.login;
            
            if (isOwner) {
                // 是自己的仓库：显示新建/上传按钮
                newFolderBtn.innerHTML = '<i class="fa-regular fa-folder"></i>';
                newFolderBtn.title = '新建文件夹';
                newFolderBtn.onclick = showCreateFolderModal;
                newFolderBtn.classList.remove('hidden');

                newFileBtn.innerHTML = '<i class="fa-regular fa-file"></i>';
                newFileBtn.title = '新建文件';
                newFileBtn.onclick = showCreateFileModal;
                newFileBtn.classList.remove('hidden');

                uploadBtn.innerHTML = '<i class="fa-solid fa-arrow-up-from-bracket"></i>';
                uploadBtn.title = '上传文件';
                uploadBtn.onclick = handleUploadClick;
                uploadBtn.classList.remove('hidden');
            } else {
                // 是别人的仓库：什么都不做 = 按钮保持隐藏
                // 仅显示滚动按钮(如果有内容)
                uploadBtn.innerHTML = '<i class="fa-solid fa-arrows-up-down"></i>';
                uploadBtn.title = '滚动';
                uploadBtn.onclick = handleScrollToggle;
                if (el.main.scrollHeight > el.main.clientHeight) {
                    uploadBtn.classList.remove('hidden');
                }
            }
            break;

        // === 场景 C: 版本/发布页面 ===
        case 'releases_list':
        case 'assets_list':
            backBtn.classList.remove('hidden');
            backBtn.innerHTML = '<i class="fa-solid fa-arrow-up"></i>';
            backBtn.title = '返回';
            backBtn.onclick = goUp;

            if (state.viewingReleasesForRepo) {
                const [owner] = state.viewingReleasesForRepo.split('/');
                if (state.user && owner === state.user.login) {
                    if (state.currentView === 'releases_list') {
                        newReleaseBtn.classList.remove('hidden');
                        newReleaseBtn.innerHTML = '<i class="fa-regular fa-folder-open"></i>';
                        newReleaseBtn.title = '发布新版本';
                        newReleaseBtn.onclick = () => {
                            const repo = state.repos.find(r => r.full_name === state.viewingReleasesForRepo) || 
                                         { full_name: state.viewingReleasesForRepo, owner: { login: owner }, default_branch: 'main' };
                            showReleaseManagerModal(repo, true); 
                        };
                    } else {
                        newReleaseBtn.classList.remove('hidden');
                        newReleaseBtn.innerHTML = '<i class="fa-solid fa-arrow-up-from-bracket"></i>';
                        newReleaseBtn.title = '打开上传面板';
                        newReleaseBtn.onclick = () => showPreUploadModal();
                    }
                }
            }
            break;

        // === 场景 D: 搜索结果 (内容搜索) ===
        case 'search_results':
             backBtn.classList.remove('hidden');
             backBtn.innerHTML = '<i class="fa-solid fa-arrow-up"></i>';
             backBtn.title = '返回上级';
             backBtn.onclick = goUp;
             break;

        // === 场景 E: 其他列表视图 (默认) ===
        case 'starred_repos':
        case 'other_user_repos':
        case 'own_repos':
        default:
            const isOwnRepos = state.currentView === 'own_repos' || !state.currentView;
            
            if (isOwnRepos) {
                newFolderBtn.classList.remove('hidden');
                newFolderBtn.innerHTML = '<i class="fa-regular fa-folder-open"></i>';
                newFolderBtn.title = '新建仓库';
                newFolderBtn.onclick = showCreateRepoModal;
            } else {
                backBtn.classList.remove('hidden');
                backBtn.innerHTML = '<i class="fa-solid fa-arrow-up"></i>';
                backBtn.onclick = goUp;
            }

            let repoSource = state.repos;
            let currentRepoPage = state.myReposPage;
            
            if (state.currentView === 'starred_repos') {
                repoSource = state.starredRepos;
                currentRepoPage = state.starredReposPage;
            } else if (state.currentView === 'other_user_repos') {
                repoSource = state.currentRepoList;
                currentRepoPage = state.userReposPage;
            }

            const totalRepoPages = Math.ceil((repoSource || []).length / state.REPOS_PER_PAGE) || 1;

            if (totalRepoPages > 1) {
                if (!isOwnRepos) {
                    newFolderBtn.classList.remove('hidden');
                    newFolderBtn.innerHTML = '<i class="fa-solid fa-arrow-left"></i>';
                    newFolderBtn.title = '上一页';
                    newFolderBtn.onclick = handlePrevRepoPage;
                    newFolderBtn.classList.toggle('disabled', currentRepoPage <= 1);
                } else if (currentRepoPage > 1) {
                     // 首页如果有上一页，放在返回键位置
                     backBtn.classList.remove('hidden');
                     backBtn.innerHTML = '<i class="fa-solid fa-arrow-left"></i>';
                     backBtn.title = '上一页';
                     backBtn.onclick = handlePrevRepoPage;
                }

                newFileBtn.classList.remove('hidden');
                newFileBtn.innerHTML = '<i class="fa-solid fa-arrow-right"></i>';
                newFileBtn.title = '下一页';
                newFileBtn.onclick = handleNextRepoPage;
                newFileBtn.classList.toggle('disabled', currentRepoPage >= totalRepoPages);
            }
            break;
    }
}






function handlePrevPage() {
    if (state.publicSearchPage > 1) {
        const newPage = state.publicSearchPage - 1;
        const query = state.publicSearchQuery;
        if (!query) {
            showToast('搜索词丢失，请重新搜索', 'error');
            return;
        }
        history.replaceState({ view: 'public_search_results', query: query, page: newPage }, '', window.location.pathname);
        searchPublicRepositories(query, newPage, false);
    } else {
        showToast('已经是第一页了');
    }
}

function handleNextPage() {
    const totalPages = Math.ceil(state.publicSearchTotalResults / state.publicSearchPerPage);
    if (state.publicSearchPage < totalPages) {
        const newPage = state.publicSearchPage + 1;
        const query = state.publicSearchQuery;
        if (!query) {
            showToast('搜索词丢失，请重新搜索', 'error');
            return;
        }
        history.replaceState({ view: 'public_search_results', query: query, page: newPage }, '', window.location.pathname);
        searchPublicRepositories(query, newPage, false);
    } else {
        showToast('已经是最后一页了');
    }
}

function handleScrollToggle() {
    const mainEl = el.main;
    // 判断是否已滚动到底部（留出1像素的误差）
    const atBottom = mainEl.scrollHeight - mainEl.scrollTop - mainEl.clientHeight < 1;

    if (atBottom) {
        mainEl.scrollTo({ top: 0, behavior: 'smooth' });
    } else {
        mainEl.scrollTo({ top: mainEl.scrollHeight, behavior: 'smooth' });
    }
}



async function handleGlobalSearch(query) {
    document.getElementById('globalSearchHistoryContainer').classList.add('hidden');
    addSearchToHistory(query);
    state.publicSearchCache.clear();
    state.repoListScrollPosition = 0;

    const rawMatch = query.match(/^https?:\/\/raw\.githubusercontent\.com\/([^\/]+)\/([^\/]+)\/([^\/]+)\/(.+)$/);
    const urlData = parseGithubUrl(query);
    const atUserMatch = query.match(/^@([a-zA-Z0-9_-]+)$/);
    const fileSearchMatch = query.match(/^#(.+)$/);

    try {
        if (rawMatch) {
            const owner = rawMatch[1];
            const repo = rawMatch[2];
            const branch = rawMatch[3];
            const filePath = rawMatch[4];
            
            const lastSlash = filePath.lastIndexOf('/');
            const dirPath = lastSlash !== -1 ? filePath.substring(0, lastSlash + 1) : '';
            const repoFullName = `${owner}/${repo}`;

            const res = await fetch(`https://api.github.com/repos/${repoFullName}`, { headers: { Authorization: `token ${state.token}` } });
            if (!res.ok) throw new Error('仓库不存在或无法访问');
            const repoData = await res.json();

            state.viewingOwner = repoData.owner.login;
            state.currentView = 'other_user_repos';
            
            navigateToRepo(repoData, branch, dirPath);

        } else if (urlData) {
            if (urlData.repo) {
                const repoFullName = `${urlData.owner}/${urlData.repo}`;
                const res = await fetch(`https://api.github.com/repos/${repoFullName}`, { headers: { Authorization: `token ${state.token}` } });
                if (!res.ok) throw new Error('仓库不存在或为私有');
                const repoData = await res.json();
                
                state.viewingOwner = repoData.owner.login;
                state.currentView = 'other_user_repos';
                
                let targetPath = urlData.path;
                let targetBranch = repoData.default_branch;

                const branchMatch = query.match(/\/(?:blob|tree)\/([^\/]+)(?:\/(.*))?$/);
                if (branchMatch) {
                    targetBranch = branchMatch[1];
                    targetPath = branchMatch[2] || '';
                } else {
                    targetBranch = localStorage.getItem(`last_branch_${repoFullName}`) || repoData.default_branch;
                }

                if (query.includes('/blob/')) {
                    const lastSlash = targetPath.lastIndexOf('/');
                    targetPath = lastSlash !== -1 ? targetPath.substring(0, lastSlash + 1) : '';
                } else if (targetPath && !targetPath.endsWith('/')) {
                    targetPath += '/';
                }

                navigateToRepo(repoData, targetBranch, targetPath);
            } else {
                await fetchAndDisplayUserRepos(urlData.owner);
            }
        } else if (atUserMatch) {
            await fetchAndDisplayUserRepos(atUserMatch[1]);
        } else if (fileSearchMatch) {
            const fileName = fileSearchMatch[1];
            await searchGlobalFiles(fileName);
        } else {
            await searchPublicRepositories(query);
        }
    } catch (error) {
        showToast(error.message, 'error');
    } finally {
        el.globalSearchInput.value = '';
        el.globalSearchContainer.classList.add('hidden');
        el.globalSearchToggleBtn.classList.remove('active');
    }
}




async function fetchUserRepos(username) {
    try {
        const res = await fetch(`https://api.github.com/users/${username}/repos`, {
            headers: {
                Authorization: `token ${state.token}`,
                'User-Agent': 'Mozilla/5.0'
            },
            cache: 'no-store'
        });

        if (!res.ok) {
            let errorMsg = `获取 ${username} 的仓库失败 (HTTP ${res.status})`;
            if (res.status === 404) {
                errorMsg = `用户 ${username} 不存在。`;
            }
            throw new Error(errorMsg);
        }

        const repos = await res.json();
        return repos;
    } catch (err) {
        showToast(err.message, 'error');
        el.repoList.innerHTML = `<div class="empty-state"><i class="fa fa-exclamation-circle"></i><p>${err.message}</p></div>`;
        return [];
    }
}


async function _renderAndFetchUserRepos(username, showMainLoader = true) {
    // --- 核心修改：只有在需要时才显示主加载动画 ---
    if (showMainLoader) {
        el.repoList.innerHTML = '<div class="loading-spinner"><div class="spinner"></div></div>';
    }
    
    state.viewingOwner = username;
    state.currentView = 'other_user_repos';
    updateGlobalSearchVisibility();
    showRepoListView();
    
    const repos = await fetchUserRepos(username);
     
    renderRepoList(repos);
    
}

async function fetchAndDisplayUserRepos(username) {
    history.pushState({ view: 'other_user_repos', owner: username }, '', window.location.pathname);
    await _renderAndFetchUserRepos(username);
}
async function searchGlobalFiles(query) {
    if (!query) return;

    toggleView(false);
    el.searchToggleBtn.classList.add('hidden');
    el.multiSelectToggleBtn.classList.add('hidden');
    el.sortToggleBtn.classList.add('hidden');
    state.currentView = 'search_results';
    updateHomeStarredButtonState();
    updateGlobalSearchVisibility();
    updatePaginationUI();

    el.fileList.innerHTML = '<div class="loading-spinner"><div class="spinner"></div></div>';
    el.currentRepo.textContent = `搜索: "${query}"`;
    history.pushState({ view: 'search_results', query: query }, '', window.location.pathname);
    state.currentPath = '';
    renderPathNav();
    el.branchSwitcherContainer.classList.add('hidden');

    try {
        
        
        await fetchRepos(true, false);
        const reposToSearch = [...state.repos];
        const totalRepos = reposToSearch.length;
        const allResults = [];

        for (let i = 0; i < totalRepos; i++) {
            const repo = reposToSearch[i];
            el.currentRepo.textContent = `搜索中 (${i + 1}/${totalRepos}): ${repo.name}`;
            
            try {
                const url = `https://api.github.com/repos/${repo.full_name}/git/trees/${repo.default_branch}?recursive=1`;
                const res = await fetch(url, { headers: { Authorization: `token ${state.token}` } });

                if (res.ok) {
                    const data = await res.json();
                    const queryLower = query.toLowerCase();
                    
                    data.tree.forEach(item => {
                        if (item.type === 'blob' && item.path.toLowerCase().includes(queryLower)) {
                            allResults.push({
                                name: item.path.split('/').pop(),
                                path: item.path,
                                sha: item.sha,
                                html_url: `https://github.com/${repo.full_name}/blob/${repo.default_branch}/${item.path}`,
                                repository: repo
                            });
                        }
                    });
                } else {
                    console.warn(`无法搜索仓库 ${repo.name}: ${res.statusText}`);
                }
            } catch (e) {
                console.error(`搜索仓库 ${repo.name} 时出错:`, e);
            }
        }

        el.currentRepo.textContent = `搜索: "${query}"`;
        state.isSearchResultsView = true;
        state.lastSearchResults = allResults;
        renderGlobalSearchResults(allResults);

    } catch (error) {
        showToast(error.message, 'error');
        el.fileList.innerHTML = `<div class="empty-state"><p>${error.message}</p></div>`;
    }
}

function renderGlobalSearchResults(items) {
    const listEl = el.fileList;
    listEl.innerHTML = '';

    if (items.length === 0) {
        listEl.innerHTML = '<div class="empty-state"><p>未在您的仓库中找到匹配的文件</p></div>';
        return;
    }

    items.sort((a, b) => {
        const repoCompare = a.repository.full_name.localeCompare(b.repository.full_name);
        if (repoCompare !== 0) return repoCompare;
        return a.path.localeCompare(b.path);
    });

    items.forEach(item => {
        const itemEl = document.createElement('div');
        itemEl.className = 'file-item';
        const repoName = item.repository.name;
        const filePath = item.path;
        
        const fileExtension = item.name.split('.').pop()?.toLowerCase();
        const rawUrl = `https://raw.githubusercontent.com/${item.repository.full_name}/${item.repository.default_branch}/${item.path}`;
        const imageUrl = getProxiedUrl(rawUrl);

        if (state.viewMode === 'grid' && IMAGE_EXTS.includes(fileExtension)) {
            itemEl.classList.add('is-image-grid');
            itemEl.innerHTML = `
                <div class="file-thumbnail-container loading" data-image-url="${escapeHtml(imageUrl)}" data-image-name="${escapeHtml(item.name)}">
                     <i class="fa fa-spinner fa-spin thumbnail-loader-icon"></i>
                     <div class="thumbnail-error retry-trigger" title="点击重试"><i class="fa fa-repeat"></i></div>
                </div>
                <div class="file-info">
                    <p class="file-name">${escapeHtml(item.name)}</p>
                    <p class="file-meta">${escapeHtml(repoName)}</p>
                </div>
            `;
        } else {
            itemEl.classList.add('search-result-item');
            const icon = getFileIcon(item.name);
            itemEl.innerHTML = `
                <div class="file-icon"><i class="fa ${icon}"></i></div>
                <div class="file-info">
                    <p class="file-name">${escapeHtml(item.name)}</p>
                    <p class="file-meta search-result-path-list">${escapeHtml(repoName)}/${escapeHtml(filePath)}</p>
                </div>
            `;
        }

        const fileObjectForActions = {
            name: item.name,
            path: item.path,
            sha: item.sha,
            html_url: item.html_url,
            download_url: rawUrl,
            type: 'file',
            repository: item.repository
        };

        itemEl.addEventListener('click', async () => {
            const url = getProxiedUrl(fileObjectForActions.download_url);
            
            if (IMAGE_EXTS.includes(fileExtension) || VIDEO_EXTS.includes(fileExtension)) {
                const preview = document.getElementById('mediaPreview');
                const img = document.getElementById('mediaPreviewImg');
                const video = document.getElementById('mediaPreviewVideo');
                if (IMAGE_EXTS.includes(fileExtension)) {
                    img.src = url;
                    img.style.display = '';
                    video.style.display = 'none';
                } else {
                    video.src = url;
                    video.style.display = '';
                    img.style.display = 'none';
                    video.load();
                }
                preview.classList.remove('hidden');
                uiStateStack.push(hideMediaPreview);
                return;
            }

            if (AUDIO_EXTS.includes(fileExtension)) {
                const nameWithoutExt = fileObjectForActions.name.substring(0, fileObjectForActions.name.lastIndexOf('.'));
                audioManager.play(url, nameWithoutExt);
                return;
            }

            if (NON_EDITABLE_EXTS.includes(fileExtension)) {
                downloadFile(fileObjectForActions);
                return;
            }

            state.editingFile = fileObjectForActions;
            el.editFileName.textContent = `${fileObjectForActions.name}`;
            el.fileContent.value = '';
            showEditStatus('', '');
            showEditModal();
            el.saveEdit.classList.add('hidden');
            try {
                const repoRes = await fetch(`https://api.github.com/repos/${item.repository.full_name}`, { headers: { Authorization: `token ${state.token}` } });
                if (!repoRes.ok) throw new Error('无法获取仓库详情');
                const fullRepoData = await repoRes.json();
                const branch = fullRepoData.default_branch;
                const contentRes = await fetch(`https://api.github.com/repos/${item.repository.full_name}/contents/${item.path}?ref=${branch}`, { headers: { Authorization: `token ${state.token}` } });
                if (!contentRes.ok) throw new Error((await contentRes.json()).message || '加载文件内容失败');
                const contentData = await contentRes.json();
                const content = decodeURIComponent(escape(atob(contentData.content)));
                el.fileContent.value = content;
                state.originalContent = content;
                state.fileSha = contentData.sha;
                state.currentRepo = item.repository.full_name;
                state.currentBranch = branch;
                state.viewingOwner = item.repository.owner.login;
                el.editorOverlay.classList.remove('show');
                el.fileContent.oninput = checkContentChanges;
                checkContentChanges();
                const isOwner = state.user && state.viewingOwner === state.user.login;
                el.saveEdit.classList.toggle('hidden', !isOwner);
                el.revertEditBtn.classList.toggle('hidden', !isOwner);
                el.fileContent.readOnly = !isOwner;
            } catch (error) {
                showToast(`打开文件失败: ${error.message}`, 'error');
                showEditStatus(`错误：${error.message}`, 'error');
                el.editorOverlay.classList.remove('show');
            }
        });

        itemEl.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            const repoData = item.repository;
            state.currentRepo = repoData.full_name;
            state.viewingOwner = repoData.owner.login;

            const fileForMenu = {
                name: item.name,
                path: item.path,
                sha: item.sha,
                html_url: item.html_url,
                download_url: `https://raw.githubusercontent.com/${repoData.full_name}/${repoData.default_branch}/${item.path}`,
                type: 'file',
                repository: item.repository
            };
            
            showContextMenu(e, fileForMenu);

            fetch(`https://api.github.com/repos/${state.currentRepo}`, { headers: { Authorization: `token ${state.token}` } })
                .then(res => {
                    if (!res.ok) throw new Error('无法获取仓库详情');
                    return res.json();
                })
                .then(fullRepoData => {
                    const existingRepoIndex = state.repos.findIndex(r => r.id === fullRepoData.id);
                    if (existingRepoIndex > -1) {
                        state.repos[existingRepoIndex] = fullRepoData;
                    } else {
                        state.repos.push(fullRepoData);
                    }
                })
                .catch(error => {
                    console.warn(`后台获取仓库详情失败: ${error.message}`);
                });
        });
        listEl.appendChild(itemEl);
    });
    
    processImagePlaceholders();
}






function updateGlobalSearchVisibility() {
    const globalSearchToggleBtn = document.getElementById('globalSearchToggleBtn');
    if (!globalSearchToggleBtn) return;

    const shouldHide = state.currentRepo !== null && state.currentView === 'own_repos';
    
    globalSearchToggleBtn.classList.toggle('hidden', shouldHide);
}


function updateHomeStarredButtonState() {
    const viewStarredBtn = document.getElementById('viewStarredBtn');
    if (!viewStarredBtn) return;
    const icon = viewStarredBtn.querySelector('i');
    
    const isAtMyRepoRoot = state.currentRepo === null && state.currentView === 'own_repos';

    if (isAtMyRepoRoot) {
        icon.className = 'fa-regular fa-star';
        viewStarredBtn.title = '查看星标仓库';
    } else {
        icon.className = 'fa-regular fa-house';
        viewStarredBtn.title = '返回我的仓库';
    }
}






async function starRepository(repoFullName) {
    const response = await fetch(`https://api.github.com/user/starred/${repoFullName}`, {
        method: 'PUT',
        headers: { 'Authorization': `token ${state.token}`, 'Content-Length': 0 }
    });
    if (response.status !== 204) throw new Error('关注失败');
}

async function unstarRepository(repoFullName) {
    const response = await fetch(`https://api.github.com/user/starred/${repoFullName}`, {
        method: 'DELETE',
        headers: { 'Authorization': `token ${state.token}` }
    });
    if (response.status !== 204) throw new Error('取消关注失败');
}



let repoToFork = null;

function showForkRepoModal(repo) {
    repoToFork = repo;
    const modal = document.getElementById('forkRepoModal');
    const originInfo = document.getElementById('forkOriginInfo');
    const nameInput = document.getElementById('forkRepoNameInput');
    const confirmBtn = document.getElementById('forkRepoConfirmBtn');
    const errorDiv = document.getElementById('forkRepoError');

    originInfo.textContent = `复刻 ${repo.full_name} 仓库到自己名下`;
    nameInput.value = repo.name;
    confirmBtn.disabled = true;
    errorDiv.style.display = 'none';

    modal.classList.remove('hidden');

    const validateInput = () => {
        const newName = nameInput.value.trim();
        
        errorDiv.style.display = 'none';

        if (!newName) {
            confirmBtn.disabled = true;
            return;
        }

        const nameExists = state.myRepos.some(repo => repo.name.toLowerCase() === newName.toLowerCase());

        if (nameExists) {
            errorDiv.textContent = '该仓库名已存在';
            errorDiv.style.display = 'block';
            confirmBtn.disabled = true;
        } else {
            confirmBtn.disabled = false;
        }
    };

    validateInput();

    nameInput.addEventListener('input', validateInput);

    document.getElementById('forkRepoConfirmBtn').onclick = async () => {
        const newName = nameInput.value.trim();
        if (newName) {
            await forkRepository(repo, newName, confirmBtn);
        }
    };

    document.getElementById('closeForkRepoModalBtn').onclick = hideForkRepoModal;
    document.getElementById('forkRepoCancelBtn').onclick = hideForkRepoModal;
}

function hideForkRepoModal() {
    repoToFork = null;
    const modal = document.getElementById('forkRepoModal');
    modal.classList.add('hidden');
}


async function forkRepository(originalRepo, newName, button) {
    button.disabled = true;
    button.innerHTML = '<span>复刻中</span><i class="fa fa-spinner fa-spin"></i>';
    showToast(`正在复刻仓库 ${originalRepo.full_name}...`);

    try {
        const res = await fetch(`https://api.github.com/repos/${originalRepo.full_name}/forks`, {
            method: 'POST',
            headers: { 
                'Authorization': `token ${state.token}`,
                'Accept': 'application/vnd.github.v3+json',
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ name: newName })
        });

        if (res.status === 202) {
            hideForkRepoModal();
            showToast('复刻请求已发送！仓库正在后台创建，请稍后刷新您的仓库列表。', 'success', 3000);
            setTimeout(() => {
                fetchRepos(true); 
            }, 5000);
        } else {
            const errorData = await res.json();
            throw new Error(errorData.message || `复刻失败 (HTTP ${res.status})`);
        }
    } catch (error) {
        showToast(`复刻失败: ${error.message}`, 'error');
    } finally {
        button.disabled = false;
        button.innerHTML = '确认复刻';
    }
}







function getFileMimeType(filename) {
    const extension = filename.split('.').pop().toLowerCase();
    const mimeMap = {
        'apk': 'application/vnd.android.package-archive',
        'ipa': 'application/octet-stream', // iOS应用包也经常被识别为通用二进制
        'txt': 'text/plain',
        'html': 'text/html',
        'css': 'text/css',
        'js': 'application/javascript',
        'json': 'application/json',
        'xml': 'application/xml',
        'jpg': 'image/jpeg',
        'jpeg': 'image/jpeg',
        'png': 'image/png',
        'gif': 'image/gif',
        'svg': 'image/svg+xml',
        'mp4': 'video/mp4',
        'mp3': 'audio/mpeg',
        'zip': 'application/zip',
        'pdf': 'application/pdf'
    };
    return mimeMap[extension] || 'application/octet-stream';
}



function estimateLocalStorageUsage() {
    try {
        const data = Object.keys(localStorage).map(key => localStorage[key]);
        return new Blob(data).size;
    } catch (e) {
        let total = 0;
        for (let x in localStorage) {
            if (!localStorage.hasOwnProperty(x)) continue;
            total += (localStorage[x].length + x.length) * 2;
        }
        return total;
    }
}

async function autoClearCacheIfNeeded() {
    // 只有在数据量极大时才清理，这里简化为只清理过期的编辑缓存
    // IndexedDB 存储空间通常很大，不需要像 LocalStorage 那样激进清理
    try {
        const keys = await SimpleDB.keys();
        const now = Date.now();
        const EXPIRE_TIME = 3 * 24 * 60 * 60 * 1000; // 3天

        for (const key of keys) {
            // 清理编辑缓存
            if (key.startsWith('edit_cache_')) {
                const data = await SimpleDB.get(key);
                if (data && (now - data.timestamp > EXPIRE_TIME)) {
                    await SimpleDB.del(key);
                }
            }
            // 清理过期的仓库列表缓存 (如果数据结构异常或过期)
            else if (key === 'repos_cache_time') {
                 const time = await SimpleDB.get(key);
                 if (time && (now - parseInt(time) > 7 * 24 * 60 * 60 * 1000)) { // 7天强制清理一次列表
                     await SimpleDB.del('cached_repos');
                     await SimpleDB.del('repos_cache_time');
                 }
            }
        }
    } catch (e) {
        console.warn('自动清理缓存时出错:', e);
    }
    
    // 同时尝试清理 localStorage 中的旧垃圾数据，释放空间
    for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && (key.startsWith('edit_cache_') || key === 'cached_repos' || key === 'cached_starred_repos')) {
            localStorage.removeItem(key);
        }
    }
}

let db;
async function initDB() {
    return new Promise((resolve, reject) => {
        if (db) return resolve(db);
        const request = indexedDB.open('ImageCacheDB', 1);
        request.onerror = (event) => reject('数据库打开报错');
        request.onsuccess = (event) => {
            db = event.target.result;
            resolve(db);
        };
        request.onupgradeneeded = (event) => {
            const db = event.target.result;
            if (!db.objectStoreNames.contains('avatars')) {
                db.createObjectStore('avatars', { keyPath: 'key' });
            }
        };
    });
}






async function showRepoOverview(repoInput) {
    let repo = repoInput;
    const CACHE_KEY = `overview_cache_${repo.full_name}`;
    const modal = document.getElementById('repoOverviewModal');
    const avatar = document.getElementById('overviewAvatar');
    const nameEl = document.getElementById('overviewName');
    const descEl = document.getElementById('overviewDesc');
    const langEl = document.getElementById('overviewLang');
    const sizeEl = document.getElementById('overviewSize');
    const dateEl = document.getElementById('overviewDates');
    const readmeEl = document.getElementById('overviewReadme');
    const enterBtn = document.getElementById('overviewEnterBtn');
    let currentDocDir = '';
    const resolvePath = (baseDir, relativePath) => {
        let path = relativePath.split('#')[0].split('?')[0];
        try {
            path = decodeURIComponent(path);
        } catch (e) {}
        if (path.startsWith('/')) return path.substring(1);
        const stack = baseDir ? baseDir.split('/').filter(p => p) : [];
        const parts = path.split('/');
        for (const part of parts) {
            if (part === '' || part === '.') continue;
            if (part === '..') {
                if (stack.length > 0) stack.pop();
            } else {
                stack.push(part);
            }
        }
        return stack.join('/');
    };
    readmeEl.onclick = async (e) => {
        const link = e.target.closest('a');
        if (!link) return;
        const rawHref = link.getAttribute('href');
        if (!rawHref) return;
        if (rawHref.startsWith('#')) {
            e.preventDefault();
            const targetId = rawHref.substring(1);
            let targetEl = document.getElementById(targetId) || document.getElementById(decodeURIComponent(targetId));
            if (!targetEl) targetEl = readmeEl.querySelector(`[name="${targetId}"]`) || readmeEl.querySelector(`[id^="user-content-${targetId}"]`);
            if (targetEl) targetEl.scrollIntoView({
                behavior: 'smooth'
            });
            return;
        }
        let targetPath = null;
        let targetRepoFullName = repo.full_name;
        let targetBranch = repo.default_branch || 'main';
        const isUrl = rawHref.match(/^[a-zA-Z]+:\/\//) || rawHref.startsWith('//');
        if (isUrl) {
            const githubMatch = rawHref.match(/^https?:\/\/(?:www\.)?github\.com\/([^\/]+)\/([^\/]+)\/blob\/([^\/]+)\/(.+)$/);
            if (githubMatch) {
                e.preventDefault();
                targetRepoFullName = `${githubMatch[1]}/${githubMatch[2]}`;
                targetBranch = githubMatch[3];
                targetPath = githubMatch[4];
            } else {
                return;
            }
        } else {
            e.preventDefault();
            targetPath = resolvePath(currentDocDir, rawHref);
        }
        if (targetPath) {
            readmeEl.style.opacity = '0.6';
            try {
                const encodedPath = targetPath.split('/').map(encodeURIComponent).join('/');
                const rawUrl = `https://raw.githubusercontent.com/${targetRepoFullName}/${targetBranch}/${encodedPath}`;
                const fetchUrl = getProxiedUrl(rawUrl);
                const res = await fetch(fetchUrl);
                if (res.ok) {
                    const content = await res.text();
                    await LibraryLoader.load(LIBS.MARKED, 'marked');
if (typeof marked !== 'undefined') {
    readmeEl.innerHTML = marked.parse(content);
} else {
    readmeEl.innerHTML = content.replace(/\n/g, '<br>');
}
                    const lastSlash = targetPath.lastIndexOf('/');
                    if (lastSlash !== -1) {
                        currentDocDir = targetPath.substring(0, lastSlash);
                    } else {
                        currentDocDir = '';
                    }
                    if (targetRepoFullName !== repo.full_name) {
                        repo = {
                            full_name: targetRepoFullName,
                            default_branch: targetBranch,
                            owner: {
                                login: targetRepoFullName.split('/')[0]
                            }
                        };
                    } else {
                        repo.default_branch = targetBranch;
                    }
                    readmeEl.scrollTop = 0;
                } 
            } catch (err) {
                showToast(`加载失败: ${err.message}`, 'error');
            } finally {
                readmeEl.style.opacity = '1';
            }
        }
    };
    const renderRepoUI = (data, readmeContent = null) => {
        avatar.src = data.owner.avatar_url;
        nameEl.innerHTML = `<span style="opacity:0.7; font-weight:400; font-size:0.9em">${data.owner.login} /</span><br>${data.name}`;
        descEl.textContent = data.description || '暂无描述';
        langEl.textContent = data.language || 'Unknown';
        sizeEl.textContent = formatSize(data.size * 1024);
        const updatedTime = data.updated_at ? new Date(data.updated_at) : new Date();
        const createdTime = data.created_at ? new Date(data.created_at) : new Date();
        dateEl.innerHTML = `最近更新：${formatRelativeTime(updatedTime)} · 创建于：${createdTime.getFullYear()}`;
        document.getElementById('statIssues').textContent = formatNumber(data.open_issues_count || 0);
        document.getElementById('statStars').textContent = formatNumber(data.stargazers_count || 0);
        document.getElementById('statForks').textContent = formatNumber(data.forks_count || 0);
        const watchers = data.subscribers_count !== undefined ? data.subscribers_count : data.watchers_count;
        document.getElementById('statWatchers').textContent = formatNumber(watchers || 0);
        if (readmeContent) {
            readmeEl.innerHTML = readmeContent;
        } else {
            readmeEl.innerHTML = '<div class="loading-spinner small" style="display:flex; justify-content:flex-start; align-items:center; height:auto; min-height:0; padding:2px 0;"><div class="spinner-small"></div><span style="margin-left:8px; font-size:0.75rem;">正在获取 README...</span></div>';
        }
    };
    let cachedData = null;
    try {
        cachedData = await SimpleDB.get(CACHE_KEY);
    } catch (e) {}
    modal.classList.remove('hidden');
    uiStateStack.push(hideRepoOverview);
    currentDocDir = '';
    if (cachedData) {
        renderRepoUI(cachedData.repo, cachedData.readme);
    } else {
        renderRepoUI(repo);
    }
    (async () => {
        try {
            const resRepo = await fetch(`https://api.github.com/repos/${repo.full_name}`, {
                headers: {
                    'Authorization': `token ${state.token}`
                },
                cache: 'no-store'
            });
            let freshRepo = repo;
            if (resRepo.ok) {
                freshRepo = await resRepo.json();
                repo = freshRepo;
            }
            let readmeHtml = '';
            try {
                const resMeta = await fetch(`https://api.github.com/repos/${freshRepo.full_name}/readme`, {
                    headers: {
                        'Authorization': `token ${state.token}`
                    }
                });
                if (resMeta.ok) {
                    const meta = await resMeta.json();
                    const lastSlash = meta.path.lastIndexOf('/');
                    if (lastSlash !== -1) currentDocDir = meta.path.substring(0, lastSlash);
                    try {
                        const rawReadmeUrl = getProxiedUrl(meta.download_url);
                        const contentRes = await fetch(rawReadmeUrl);
                        if (contentRes.ok) {
                            const rawMarkdown = await contentRes.text();
                            if (typeof marked !== 'undefined') readmeHtml = marked.parse(rawMarkdown);
                            else readmeHtml = rawMarkdown.replace(/\n/g, '<br>');
                        } else throw new Error('Proxy fetch failed');
                    } catch (proxyError) {
                        const rawRes = await fetch(meta.url, {
                            headers: {
                                'Authorization': `token ${state.token}`,
                                'Accept': 'application/vnd.github.v3.raw'
                            }
                        });
                        if (rawRes.ok) {
                            const rawMarkdown = await rawRes.text();
                            await LibraryLoader.load(LIBS.MARKED, 'marked');
readmeHtml = marked.parse(rawMarkdown);
                        }
                    }
                } else {
                    readmeHtml = '<div style="padding:10px; color:#aaa; font-size:0.8rem;">该仓库没有 README 文件。</div>';
                }
            } catch (e) {
                readmeHtml = '<div style="padding:10px; color:#ef4444; font-size:0.8rem;">加载 README 失败，请检查网络。</div>';
            }
            if (!cachedData || readmeHtml !== cachedData.readme) {
                renderRepoUI(freshRepo, readmeHtml);
                if (readmeHtml && !readmeHtml.includes('加载 README 失败')) {
                    try {
                        const cachePayload = {
                            repo: freshRepo,
                            readme: readmeHtml,
                            timestamp: Date.now()
                        };
                        await SimpleDB.set(CACHE_KEY, cachePayload);
                    } catch (e) {}
                }
            }
        } catch (e) {
            if (!cachedData) readmeEl.innerHTML = '<div style="padding:10px; color:#ef4444; font-size:0.8rem;">无法获取仓库信息。</div>';
        }
    })();
    const directToggle = document.getElementById('overviewDirectEntryToggle');
    const directEntryList = JSON.parse(localStorage.getItem('direct_entry_repos') || '[]');
    const isDirectEntry = directEntryList.includes(String(repo.id));
    directToggle.checked = isDirectEntry;
    const directToggleNew = directToggle.cloneNode(true);
    directToggle.parentNode.replaceChild(directToggleNew, directToggle);
    directToggleNew.addEventListener('change', (e) => {
        const enabled = e.target.checked;
        const repoId = String(repo.id);
        let list = JSON.parse(localStorage.getItem('direct_entry_repos') || '[]');
        if (enabled) {
            if (!list.includes(repoId)) {
                list.push(repoId);
            }
        } else {
            list = list.filter(id => id !== repoId);
        }
        localStorage.setItem('direct_entry_repos', JSON.stringify(list));
        showToast(enabled ? '已开启：此仓库点击将直接进入' : '已关闭：此仓库点击将显示概览');
    });
    const toggleLabel = directToggleNew.parentElement;
    let refreshBtn = document.getElementById('overviewRefreshBtn');
    if (!refreshBtn) {
        refreshBtn = document.createElement('button');
        refreshBtn.id = 'overviewRefreshBtn';
        refreshBtn.className = 'btn-icon-sm';
        refreshBtn.style.marginRight = '8px';
        refreshBtn.innerHTML = '<i class="fa fa-refresh"></i>';
        refreshBtn.title = '刷新内容';
        toggleLabel.parentElement.insertBefore(refreshBtn, toggleLabel);
    }
    refreshBtn.onclick = async (e) => {
        e.stopPropagation();
        const icon = refreshBtn.querySelector('i');
        icon.classList.add('fa-spin');
        try {
            await SimpleDB.del(CACHE_KEY);
            await showRepoOverview(repo);
            showToast('刷新成功');
        } catch (err) {
            showToast('刷新失败', 'error');
        } finally {
            setTimeout(() => icon.classList.remove('fa-spin'), 500);
        }
    };
    const starBtnOld = document.getElementById('overviewStarBtn');
    const starBtn = starBtnOld.cloneNode(true);
    starBtnOld.parentNode.replaceChild(starBtn, starBtnOld);
    const isOwner = state.user && repo.owner.login === state.user.login;
    if (isOwner) {
        starBtn.innerHTML = '<i class="fa fa-pencil"></i> 修改信息';
        starBtn.className = 'btn btn-secondary';
        starBtn.onclick = () => {
            hideRepoOverview();
            showRenameRepoModal(repo);
        };
    } else {
        const updateBtnStyle = () => {
            const isCurrentlyStarred = state.starredRepos.some(r => r.full_name === repo.full_name);
            updateOverviewStarBtn(starBtn, isCurrentlyStarred);
            return isCurrentlyStarred;
        };
        updateBtnStyle();
        starBtn.onclick = async () => {
            starBtn.disabled = true;
            try {
                const isCurrentlyStarred = updateBtnStyle();
                if (isCurrentlyStarred) {
                    await unstarRepository(repo.full_name);
                    state.starredRepos = state.starredRepos.filter(r => r.full_name !== repo.full_name);
                    showToast('已取消关注');
                } else {
                    await starRepository(repo.full_name);
                    state.starredRepos.unshift(repo);
                    showToast('已关注仓库');
                }
                updateBtnStyle();
                renderRepoList();
            } catch (e) {
                showToast('操作失败: ' + e.message, 'error');
            } finally {
                starBtn.disabled = false;
            }
        };
    }
    const enterBtnNew = enterBtn.cloneNode(true);
    enterBtn.parentNode.replaceChild(enterBtnNew, enterBtn);
    enterBtnNew.onclick = () => {
        hideRepoOverview();
        state.repoListScrollPosition = el.main.scrollTop;
        state.shouldAnimateList = true;
        state.viewingOwner = repo.owner.login;
        const targetBranch = repo.default_branch || localStorage.getItem(`last_branch_${repo.full_name}`) || 'main';
        navigateToRepo(repo, targetBranch);
    };
}






// 辅助：关闭概览
function hideRepoOverview() {
    document.getElementById('repoOverviewModal').classList.add('hidden');
    const index = uiStateStack.indexOf(hideRepoOverview);
    if (index > -1) uiStateStack.splice(index, 1);
}

// 辅助：更新关注按钮样式
function updateOverviewStarBtn(btn, isStarred) {
    if (isStarred) {
        btn.innerHTML = '<i class="fa-solid fa-star" style="color:#facc15"></i> 已关注';
        btn.classList.add('active'); // 你可以在 CSS 定义 .active 样式
    } else {
        btn.innerHTML = '<i class="fa-regular fa-star"></i> 关注';
        btn.classList.remove('active');
    }
}

function initTokenGuide() {
    const modal = document.getElementById('tokenGuideModal');
    const showBtn = document.getElementById('showTokenGuideBtn');
    const closeBtn = document.getElementById('closeTokenGuideBtn');
    const knownBtn = document.getElementById('tokenGuideKnownBtn');

    if (!modal || !showBtn) return;

    const hideModal = () => {
        modal.classList.add('hidden');
        if (window.uiStateStack) {
            const index = window.uiStateStack.indexOf(hideModal);
            if (index > -1) window.uiStateStack.splice(index, 1);
        }
    };

    const showModal = () => {
        modal.classList.remove('hidden');
        if (window.uiStateStack) {
            window.uiStateStack.push(hideModal);
        }
    };

    showBtn.onclick = (e) => {
        e.preventDefault();
        showModal();
    };

    if (closeBtn) closeBtn.onclick = hideModal;
    if (knownBtn) knownBtn.onclick = hideModal;

    modal.onclick = (e) => {
        if (e.target === modal) hideModal();
    };
}








function setupEventListeners() {

function autoGrow(element) {

    
    
        element.style.height = 'auto';
        element.style.height = (element.scrollHeight) + 'px';
    }

    if (el.createRepoDescInput) {
        el.createRepoDescInput.addEventListener('input', function() {
            autoGrow(this);
        });
    }

    if (el.createFileContentInput) {
        el.createFileContentInput.addEventListener('input', function() {
            autoGrow(this);
        });
    }
    
    
    
    
el.currentRepo.addEventListener('click', () => {
    if (state.currentRepo && state.currentPath !== '') {
        navigateToPath('');
    }
});

el.ybp.onclick = () => {
    closeSideNav();
    showApiStatusPanel();
};
if (el.menuThemeToggle) {
    el.menuThemeToggle.onclick = () => {
        themeManager.toggle();
    };
    
    el.showPublishHelpBtn.onclick = showPublishHelpModal;
    el.closePublishHelpBtn.onclick = hidePublishHelpModal;
    el.publishHelpModal.onclick = (e) => {
        if (e.target === el.publishHelpModal) {
            hidePublishHelpModal();
        }
    };
    
    el.searchInFileBtn.addEventListener('click', () => toggleEditorSearch(true));
el.editorSearchCloseBtn.addEventListener('click', () => toggleEditorSearch(false));

el.editorSearchInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
        e.preventDefault();
        if (e.shiftKey) {
             navigateSearchMatches(-1);
        } else {
             navigateSearchMatches(1);
        }
    }
});
    el.fileList.addEventListener('click', (e) => {
        const item = e.target.closest('.file-item');
        if (!item) return;

        const filePath = item.dataset.filePath;
        const file = state.displayFiles.find(f => f.path === filePath);
        if (!file) return;

        const retryTrigger = e.target.closest('.retry-trigger');
        if (retryTrigger) {
            e.stopPropagation();
            const allFailedContainers = document.querySelectorAll('#fileList .file-thumbnail-container.error');
            if (allFailedContainers.length > 0) {
                showToast(`正在重试 ${allFailedContainers.length} 个失败的图片...`);
                allFailedContainers.forEach(container => {
                    container.classList.remove('error');
                    container.classList.add('loading');
                    loadThumbnailImage(container);
                });
            }
            return;
        }

        if (state.isMultiSelectMode) {
            item.classList.toggle('selected');
            if (state.selectedItems.has(file.path)) {
                state.selectedItems.delete(file.path);
            } else {
                state.selectedItems.add(file.path);
            }
            updateActionBar();
        } else {
            if (file.type === 'dir') {
                navigateToDir(file.name);
            } else {
                const fileExtension = file.name.split('.').pop()?.toLowerCase();
                const isMedia = IMAGE_EXTS.includes(fileExtension) || VIDEO_EXTS.includes(fileExtension) || AUDIO_EXTS.includes(fileExtension);
                if (!isMedia) {
                   editFile(file);
                }
            }
        }
    });

    el.fileList.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        const item = e.target.closest('.file-item');
        if (!item) return;
        const filePath = item.dataset.filePath;
        const file = state.displayFiles.find(f => f.path === filePath);
        if (!file) return;
        showContextMenu(e, file);
    });
el.editorSearchInput.addEventListener('input', performEditorSearch);
el.editorSearchPrevBtn.addEventListener('click', () => navigateSearchMatches(-1));
el.editorSearchNextBtn.addEventListener('click', () => navigateSearchMatches(1));
}
el.setAsSiteCloseBtn.onclick = hideSetAsSiteModal;
el.setAsSiteCancelBtn.onclick = hideSetAsSiteModal;

const setAsSiteSelector = document.getElementById('setAsSiteBranchSelector');
setAsSiteSelector.querySelector('.custom-branch-select-trigger').addEventListener('click', (e) => {
    e.stopPropagation();
    setAsSiteSelector.classList.toggle('open');
});

document.addEventListener('click', (e) => {
    if (!setAsSiteSelector.contains(e.target)) {
        setAsSiteSelector.classList.remove('open');
    }
});


el.manageAccountsBtn.addEventListener('click', showAccountManagerModal);
el.menuSwitchAccount.addEventListener('click', () => {
    closeSideNav();
    showAccountManagerModal();
});
el.closeAccountManagerModalBtn.addEventListener('click', closeAccountManagerModal);
el.showAddAccountModalBtn.addEventListener('click', () => showAddEditAccountModal());


el.closeAddEditAccountModalBtn.addEventListener('click', closeAddEditAccountModal);
el.addEditAccountCancelBtn.addEventListener('click', closeAddEditAccountModal);
el.addEditAccountSaveBtn.addEventListener('click', handleSaveAccount);

document.getElementById('repoDetailsCloseBtn').onclick = hideRepoDetailsModal;
el.repoDetailsModal.onclick = (e) => {
    if (e.target === el.repoDetailsModal) {
        hideRepoDetailsModal();
    }
};







let configuringDomainRepoFullName = null;

async function showCustomDomainModal(repoFullName) {
    state.configuringDomainRepoFullName = repoFullName;
    const repoName = repoFullName.split('/')[1];
    const repoToUpdate = state.repos.find(r => r.full_name === repoFullName);

    el.customDomainRepoName.textContent = `为仓库 "${repoName}" 设置域名`;
    el.customDomainInput.value = '';
    el.customDomainSaveBtn.disabled = true;
    el.customDomainError.style.display = 'none';
    el.customDomainModal.classList.remove('hidden');
    uiStateStack.push(hideCustomDomainModal);

    el.customDomainInput.disabled = true;

    try {
        const url = `https://api.github.com/repos/${repoFullName}/contents/CNAME`;
        const response = await fetch(url, {
            headers: { 'Authorization': `token ${state.token}` }
        });

        if (response.ok) {
            const data = await response.json();
            const currentDomain = atob(data.content);
            el.customDomainInput.value = currentDomain;
            if (repoToUpdate) repoToUpdate.customDomain = currentDomain;
        } else {
            
            if (repoToUpdate) repoToUpdate.customDomain = null;
        }

    } catch (error) {
        console.error('获取CNAME文件失败:', error);
        el.customDomainInput.placeholder = '加载域名失败，请重试';
    } finally {
        el.customDomainInput.disabled = false;
        el.customDomainInput.dispatchEvent(new Event('input'));
    }
}

function hideCustomDomainModal() {
    el.customDomainModal.classList.add('hidden');
    state.configuringDomainRepoFullName = null;
    const index = uiStateStack.indexOf(hideCustomDomainModal);
    if (index > -1) uiStateStack.splice(index, 1);
}

async function handleSaveCustomDomain() {
    const domain = el.customDomainInput.value.trim();
    if (!domain || !state.configuringDomainRepoFullName) return;

    const saveBtn = el.customDomainSaveBtn;
    const spinner = saveBtn.querySelector('i');
    saveBtn.disabled = true;
    spinner.classList.remove('hidden');
    el.customDomainError.style.display = 'none';

    try {
        const [owner, repoName] = state.configuringDomainRepoFullName.split('/');
        const filePath = 'CNAME';
        const url = `https://api.github.com/repos/${owner}/${repoName}/contents/${filePath}`;
        
        let existingFileSha = null;
        try {
            const checkRes = await fetch(url, { headers: { 'Authorization': `token ${state.token}` } });
            if (checkRes.ok) {
                existingFileSha = (await checkRes.json()).sha;
            }
        } catch (e) {}

        const encodedContent = btoa(unescape(encodeURIComponent(domain)));
        const requestBody = {
            message: `feat: Set custom domain to ${domain}`,
            content: encodedContent,
            branch: state.repos.find(r => r.full_name === state.configuringDomainRepoFullName)?.default_branch || 'main'
        };

        if (existingFileSha) {
            requestBody.sha = existingFileSha;
        }

        const res = await fetch(url, {
            method: 'PUT',
            headers: { 'Authorization': `token ${state.token}`, 'Content-Type': 'application/json' },
            body: JSON.stringify(requestBody)
        });

        if (!res.ok) {
            const errorData = await res.json();
            throw new Error(errorData.message || '配置域名失败');
        }

        const repoToUpdate = state.repos.find(r => r.full_name === state.configuringDomainRepoFullName);
        if (repoToUpdate) {
            repoToUpdate.customDomain = domain;
            try {
                const CACHE_KEY = 'custom_domains_cache';
                let cachedDomains = (await SimpleDB.get(CACHE_KEY)) || {};
                cachedDomains[repoToUpdate.full_name] = domain;
                await SimpleDB.set(CACHE_KEY, cachedDomains);
            } catch (e) {}
        }

        showToast(`仓库 ${repoName} 的域名已配置为 ${domain}`);
        hideCustomDomainModal();
        renderPublishManagerLists();

    } catch (error) {
        el.customDomainError.textContent = `错误: ${error.message}`;
        el.customDomainError.style.display = 'block';
    } finally {
        saveBtn.disabled = false;
        spinner.classList.add('hidden');
    }
}




function showRemoveCustomDomainConfirmation(repo) {
    showDeleteModal(
        null,
        false,
        '确认取消域名绑定',
        `确定要为仓库 "${repo.name}" 取消自定义域名绑定吗？<br><br>此操作将从您的仓库中删除 CNAME 文件。`,
        async () => {
            await handleRemoveCustomDomain(repo);
        },
        '确认取消',
        'btn-danger'
    );
}

async function handleRemoveCustomDomain(repo) {
    showToast('正在取消域名绑定...');
    try {
        const [owner, repoName] = repo.full_name.split('/');
        const url = `https://api.github.com/repos/${owner}/${repoName}/contents/CNAME`;

        const checkRes = await fetch(url + `?ref=${repo.default_branch}`, {
            headers: { 'Authorization': `token ${state.token}` }
        });

        if (!checkRes.ok) {
            if (checkRes.status === 404) {
                showToast('域名配置已不存在', 'info');
                repo.customDomain = null;
                try {
                    const CACHE_KEY = 'custom_domains_cache';
                    let cachedDomains = (await SimpleDB.get(CACHE_KEY)) || {};
                    delete cachedDomains[repo.full_name];
                    await SimpleDB.set(CACHE_KEY, cachedDomains);
                } catch (e) {}
                renderPublishManagerLists();
                return;
            }
            throw new Error('无法获取当前的域名配置');
        }

        const fileData = await checkRes.json();
        const existingFileSha = fileData.sha;

        const res = await fetch(url, {
            method: 'DELETE',
            headers: { 'Authorization': `token ${state.token}`, 'Content-Type': 'application/json' },
            body: JSON.stringify({
                message: `build: Remove custom domain`,
                sha: existingFileSha,
                branch: repo.default_branch
            })
        });

        if (!res.ok) {
            const errorData = await res.json();
            throw new Error(errorData.message || '取消绑定失败');
        }

        repo.customDomain = null;
        try {
            const CACHE_KEY = 'custom_domains_cache';
            let cachedDomains = (await SimpleDB.get(CACHE_KEY)) || {};
            delete cachedDomains[repo.full_name];
            await SimpleDB.set(CACHE_KEY, cachedDomains);
        } catch (e) {}
        
        showToast(`仓库 "${repo.name}" 的自定义域名已成功取消绑定`);
        renderPublishManagerLists();

    } catch (error) {
        showToast(`操作失败: ${error.message}`, 'error');
        console.error(error);
    }
}









function validateAccountForm() {
    const name = el.accountNameInput.value.trim();
    const token = el.accountTokenInput.value.trim();

    if (editingAccountId) {
        el.addEditAccountSaveBtn.disabled = !name;
    } else {
        el.addEditAccountSaveBtn.disabled = !token;
    }
}
el.accountNameInput.addEventListener('input', validateAccountForm);
el.accountTokenInput.addEventListener('input', validateAccountForm);

    el.menuUsageGuide.onclick = () => {
    closeSideNav();
    showUsageGuideModal();
};
    el.closeUsageGuideBtn.onclick = hideUsageGuideModal;
    el.usageGuideModal.onclick = (e) => {
        if (e.target === el.usageGuideModal) {
            hideUsageGuideModal();
        }
    };
    
    el.proxyQuickToggle.addEventListener('click', () => {
        setProxyGlobalState(!state.proxyGlobalEnable, true);
    });
    el.proxyGlobalEnableToggle.addEventListener('change', (e) => {
        setProxyGlobalState(e.target.checked, true);
    });
    el.refreshApiStatusBtn.addEventListener('click', handleRefreshApiStatus);
    el.ybp.onclick = () => {
    closeSideNav();
    showApiStatusPanel();
};
    el.closeApiStatusPanel.addEventListener('click', hideApiStatusPanel);
    el.apiStatusOverlay.addEventListener('click', hideApiStatusPanel);
    
    
    el.importBtn.addEventListener('click', importProxiesFromUrl);
    el.newFolderBtn.onclick = function() {
        if (!state.currentRepo) {
            showCreateRepoModal();
        } else {
            showCreateFolderModal();
        }
    };
   
el.authBtn.addEventListener('click', async () => {
    const token = el.tokenInput.value.trim();
    const btn = el.authBtn;
    const btnText = btn.querySelector('span');
    const spinner = btn.querySelector('i');
    btn.classList.remove('success', 'error');
    el.tokenInput.classList.remove('error');
    if (!token) {
        showToast('请输入GitHub访问令牌');
        el.tokenInput.classList.add('error');
        btn.classList.add('error');
        return;
    }
    btn.disabled = true;
    btnText.textContent = '正在验证';
    spinner.classList.remove('hidden');

    try {
        const res = await fetch('https://api.github.com/user', {
            headers: { Authorization: `token ${token}` }
        });

        if (!res.ok) {
            if (res.status === 401) {
                throw new Error('令牌无效或已过期');
            }
            throw new Error(`验证失败: ${res.statusText}`);
        }

        const scopesHeader = res.headers.get('x-oauth-scopes');

        if (scopesHeader !== null) {
            if (!scopesHeader.includes('repo')) {
                showToast('此经典令牌权限不足，大部分功能将无法使用。', 'error', 6000);
            }
        }

        const userData = await res.json(); 

        let existingAccount = state.accounts.find(acc => acc.token === token);
        if (!existingAccount) {
            const newAccount = {
                id: `gh_${Date.now()}`,
                name: `${userData.login}`, 
                token: token
            };
            state.accounts.push(newAccount);
            saveAccounts();
            existingAccount = newAccount;
            showToast('新账号已自动保存');
        }
        
        setActiveAccount(existingAccount.id);
        
        btn.classList.add('success');
        btnText.textContent = '登录成功 ✓';
        spinner.classList.add('hidden');
        state.shouldAnimateList = true;
        
        await Promise.all([
            fetchUserInfo(), 
            fetchRepos(true),
        ]);

        setTimeout(async () => {
            showApp();
            showToast('欢迎回来！');

            if (state.proxies.length === 0) {
                findAndSetBestProxy();
            } else if (state.autoSelectProxy) {
                findAndSetBestProxy();
            } else {
                state.activeProxyIndex = parseInt(localStorage.getItem('active_proxy_index') || '0');
                state.proxyGlobalEnable = JSON.parse(localStorage.getItem('proxy_global_enable') || 'true');
                saveProxyConfig();
            }

            btn.disabled = false;
            btnText.textContent = '登录';
            btn.classList.remove('success');
        }, 1000);

    } catch (error) {
        showToast(error.message || '网络连接失败，请重试');
        el.tokenInput.classList.add('error');
        btn.classList.add('error');
        btn.disabled = false;
        btnText.textContent = '登录';
        spinner.classList.add('hidden');
    }
});


    [el.sideNavToggleBtn, el.mainOverlay].forEach(element => {
    element.addEventListener('click', () => {
        el.sideNav.classList.toggle('open');
        el.mainOverlay.classList.toggle('open');
    });
});
    el.createBranchCancel.onclick = function() {
        hideCreateBranchModal();
    };
    el.cancelSelectBtn.addEventListener('click', () => toggleMultiSelectMode(false));
    el.selectAllBtn.addEventListener('click', () => {
        const allVisiblePaths = state.displayFiles.map(f => f.path);
        const areAllSelected = allVisiblePaths.length > 0 && allVisiblePaths.every(path => state.selectedItems.has(path));
        allVisiblePaths.forEach(path => {
            if (areAllSelected) {
                state.selectedItems.delete(path);
            } else {
                state.selectedItems.add(path);
            }
        });
        renderFileList();
    });
    el.invertSelectBtn.addEventListener('click', () => {
        const allVisiblePaths = state.displayFiles.map(f => f.path);
        allVisiblePaths.forEach(path => {
            if (state.selectedItems.has(path)) {
                state.selectedItems.delete(path);
            } else {
                state.selectedItems.add(path);
            }
        });
        renderFileList();
    });
    el.downloadBtn.addEventListener('click', downloadSelectedItemsAsZip);
    el.deleteBtn.addEventListener('click', () => {
        if (state.selectedItems.size === 0) return;
        const selectedFiles = state.files.filter(f => state.selectedItems.has(f.path));
        const fileCount = selectedFiles.filter(f => f.type === 'file').length;
        const dirCount = selectedFiles.filter(f => f.type === 'dir').length;
        let desc = `确定要删除这 ${state.selectedItems.size} 个项目吗？`;
        if (fileCount > 0 && dirCount > 0) desc += ` (包含 ${fileCount} 个文件和 ${dirCount} 个文件夹)`;
        else if (fileCount > 0) desc += ` (共 ${fileCount} 个文件)`;
        else if (dirCount > 0) desc += ` (共 ${dirCount} 个文件夹)`;
        showDeleteModal(null, false, '确认批量删除', desc, async function() {
            showToast(`开始删除 ${selectedFiles.length} 个项目...`);
            for (const item of selectedFiles) {
                await deleteSingleItem(item);
            }
            showToast('批量删除完成！');
            toggleMultiSelectMode(false);
            state.shouldAnimateList = true;
            fetchFiles(true);
        });
    });
    function handleInteractionToCloseMenu(e) {
        if (!el.contextMenu.classList.contains('hidden') && !el.contextMenu.contains(e.target)) {
            hideContextMenu();
        }
    }
    document.addEventListener('mousedown', handleInteractionToCloseMenu);
    document.addEventListener('touchstart', handleInteractionToCloseMenu, { passive: true });
    document.addEventListener('click', function(e) {
        if (!el.mainMenuPopup.classList.contains('hidden') && !el.mainMenuPopup.contains(e.target) && !e.target.closest('#mainMenuBtn')) {
            hideMainMenuPopup();
        }
        if (!el.customSortDropdown.classList.contains('hidden') && !el.customSortDropdown.contains(e.target) && !e.target.closest('#sortToggleBtn')) {
            hideSortDropdown();
        }
    });
    
    
    
el.menuLogout.onclick = () => {
    closeSideNav();
    
    const performLogout = () => {
        state.token = null; 
        setActiveAccount(null);
        localStorage.removeItem('user_avatar');
        localStorage.removeItem('cached_repos');
        localStorage.removeItem('repos_cache_time');
        state.repos = [];
        state.currentRepo = null;
        state.user = null;
        showAuth();
    };

    showDeleteModal(
        null,
        false,
        '确认退出',
        '您确定要退出当前账号吗？',
        performLogout,
        '确认退出',
        'btn-danger'
    );
};
    el.menuProxySettings.onclick = () => {
    closeSideNav();
    openProxySettingsModal();
};
    

el.menuBatchPublishSites.onclick = () => {
    closeSideNav();
    showPublishManagerModal();
};
    el.closeEditModal.onclick = hideEditModal;
    el.cancelEdit.onclick = hideEditModal;
    el.saveEdit.onclick = saveEditedFile;
    el.backBtn.onclick = goUp;
    el.newFileBtn.onclick = showCreateFileModal;
    // 更新原有绑定
    el.uploadBtn.onclick = handleUploadClick;
    
    // 新增面板按钮绑定
    el.preUploadAddBtn.onclick = () => el.fileUploadInput.click();
    
    el.preUploadClearBtn.onclick = () => {
        state.pendingUploadFiles = [];
        renderPreUploadList();
    };
    
    el.preUploadStartBtn.onclick = handleStartBatchUpload;
    el.fileUploadInput.addEventListener('change', handleFilesSelected);
    el.searchToggleBtn.addEventListener('click', () => {
        el.searchInput.classList.toggle('hidden');
        if (!el.searchInput.classList.contains('hidden')) {
            el.searchInput.focus();
            el.searchInput.style.display = 'block';
        } else {
            el.searchInput.value = '';
            state.searchQuery = '';
            applyFiltersAndSort();
            renderFileList();
            el.searchInput.style.display = 'none';
        }
    });
    if (el.searchInput) {
    el.searchInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            const query = el.searchInput.value.trim();
            if (query) {
                performRecursiveSearch(query);
            } else {
                state.isLocalSearchResultsView = false;
                applyFiltersAndSort();
                renderFileList();
            }
        }
    });

    el.searchInput.addEventListener('input', () => {
        if (el.searchInput.value.trim() === '') {
            state.isLocalSearchResultsView = false;
            applyFiltersAndSort();
            renderFileList();
        }
    });
}
    el.multiSelectToggleBtn.onclick = () => {
        toggleMultiSelectMode(!state.isMultiSelectMode);
    };
    el.sortToggleBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        if (el.customSortDropdown.classList.contains('hidden')) {
            showSortDropdown();
        } else {
            hideSortDropdown();
        }
    });
    el.customSortDropdown.addEventListener('click', (e) => {
        const item = e.target.closest('.dropdown-item');
        state.shouldAnimateList = true;
        if (!item) return;
        hideSortDropdown();
        const newSortBy = item.dataset.value;
        const newPriority = item.dataset.priority;
        if (newSortBy) {
            state.sortBy = newSortBy;
            localStorage.setItem('sort_by', state.sortBy);
        }
        if (newPriority) {
            state.directorySortPriority = newPriority;
            localStorage.setItem('directory_sort_priority', state.directorySortPriority);
        }
        updateSortDropdownUI();
        applyFiltersAndSort();
        renderFileList();
    });
    if (el.customSortDropdown) {
        Array.from(el.customSortDropdown.children).forEach(item => {
            if (item.dataset.value === state.sortBy) {
                item.classList.add('selected');
            }
        });
    }
    if (el.viewToggleBtn) {
    updateFileListViewMode();
    el.viewToggleBtn.addEventListener('click', () => {
        state.viewMode = state.viewMode === 'list' ? 'grid' : 'list';
        localStorage.setItem('view_mode', state.viewMode);
        updateFileListViewMode();
        
        if (state.isSearchResultsView) {
            renderGlobalSearchResults(state.lastSearchResults);
        } else {
            renderFileList();
        }
    });
}
    el.proxyCancelSettingsBtn.addEventListener('click', closeProxySettingsModal);
        el.proxyAutoSelectToggle.addEventListener('click', async () => {
    state.autoSelectProxy = !state.autoSelectProxy;
    localStorage.setItem('proxy_auto_select', JSON.stringify(state.autoSelectProxy));
    updateProxySettingsUI();

    if (state.autoSelectProxy) {
        await findAndSetBestProxy(true);
    } else {
        showToast('已关闭自动优选');
    }
});
    el.proxyAddBtn.addEventListener('click', () => openAddEditProxyModal());
    el.proxyTestAllBtn.addEventListener('click', testAllProxies);
    el.proxyClearAllBtn.addEventListener('click', showConfirmClearAllProxiesModal);
    el.addEditProxyUrlInput.addEventListener('input', validateAddEditProxyInput);
    el.confirmDeleteProxyCancelBtn.addEventListener('click', hideConfirmDeleteProxyModal);
    el.clearAllProxiesCancelBtn.addEventListener('click', hideConfirmClearAllProxiesModal);
    el.clearAllProxiesConfirmBtn.addEventListener('click', clearAllProxiesConfirmed);
    el.renameInput.oninput = function() {
        el.renameConfirm.disabled = !el.renameInput.value.trim() || el.renameInput.value.trim() === state.selectedFile?.name;
    };
    el.renameCancel.onclick = function() {
        hideRenameModal();
    };
    el.deleteCancel.onclick = function() {
        hideDeleteModal();
    };
    el.createRepoCancel.onclick = function() {
        hideCreateRepoModal();
    };
    el.createFolderInput.oninput = function() {
        el.createFolderConfirm.disabled = !el.createFolderInput.value.trim();
    };
    el.createFolderCancel.onclick = function() {
        hideCreateFolderModal();
    };
    el.createFileNameInput.oninput = function() {
        el.createFileConfirm.disabled = !el.createFileNameInput.value.trim() || el.createFileNameInput.value.trim().endsWith('/');
    };
    el.createFileCancel.onclick = function() {
        hideCreateFileModal();
    };
    el.createBranchNameInput.oninput = function() {
        el.createBranchConfirm.disabled = !el.createBranchNameInput.value.trim();
    }
    el.menuContextMenuSettings.onclick = () => {
    closeSideNav();
    openContextMenuSettingsModal();
};
    el.contextMenuSettingsCloseBtn.onclick = () => {
        hideContextMenuSettingsModal();
    };
    el.contextMenuSettingsModal.querySelector('.context-menu-settings-tabs').addEventListener('click', e => {
        if (e.target.matches('.tab-btn')) {
            const container = e.target.parentElement;
            container.querySelector('.active').classList.remove('active');
            e.target.classList.add('active');
            renderContextMenuSettings(e.target.dataset.tab);
        }
    });
    
        el.repoList.addEventListener('click', async (e) => {
        const starButton = e.target.closest('.star-text-btn:not(.js-view-releases-btn)');
    if (!starButton) return;

        e.preventDefault();
        e.stopPropagation();

        const repoFullName = starButton.dataset.repoFullname;
        const isCurrentlyStarred = starButton.classList.contains('starred');

        starButton.disabled = true;
        starButton.textContent = '处理中...';

        try {
            if (isCurrentlyStarred) {
                await unstarRepository(repoFullName);
                state.starredRepos = state.starredRepos.filter(r => r.full_name !== repoFullName);
                showToast(`已取消关注 ${repoFullName}`);
            } else {
                await starRepository(repoFullName);
                const repoInfoRes = await fetch(`https://api.github.com/repos/${repoFullName}`, {
                    headers: { 'Authorization': `token ${state.token}` }
                });
                if (repoInfoRes.ok) {
                    state.starredRepos.unshift(await repoInfoRes.json());
                }
                showToast(`已关注 ${repoFullName}`);
            }
            const isNowStarred = !isCurrentlyStarred;
            starButton.textContent = isNowStarred ? '取消关注' : '关注';
            starButton.classList.toggle('starred', isNowStarred);

        } catch (error) {
            showToast(error.message, 'error');
            starButton.textContent = isCurrentlyStarred ? '取消关注' : '关注';
        } finally {
            starButton.disabled = false;
        }
    });
    
    
    
    
    
   el.repoList.addEventListener('click', (e) => {
    const releasesButton = e.target.closest('.js-view-releases-btn');
    if (releasesButton) {
        e.preventDefault();
        e.stopPropagation();
        const repoFullName = releasesButton.dataset.repoFullname;
        if (repoFullName) {
            fetchAndDisplayReleases(repoFullName);
        }
        return;
    }

    const forkButton = e.target.closest('.fork-text-btn');
    if (forkButton) return;

    const starButton = e.target.closest('.star-text-btn');
    if (starButton) return;

    if (state.currentView === 'releases_list' || state.currentView === 'assets_list') return;

    const item = e.target.closest('.file-item');
    if (item) {
        e.preventDefault();
        e.stopPropagation();

        const repoId = String(item.dataset.repoId);

        let repo = null;
        if (state.currentRepoList && state.currentRepoList.length > 0) {
            repo = state.currentRepoList.find(r => String(r.id) === repoId);
        }

        if (!repo) {
            repo = (state.repos || []).find(r => String(r.id) === repoId);
        }
        if (!repo) {
            repo = (state.starredRepos || []).find(r => String(r.id) === repoId);
        }

        if (repo) {
            const isOwner = (state.user && repo.owner.login === state.user.login) || (state.currentView === 'own_repos');
            const directEntryList = JSON.parse(localStorage.getItem('direct_entry_repos') || '[]');
            const isDirectEntryEnabled = directEntryList.includes(String(repo.id));

            if (isOwner || isDirectEntryEnabled) {
                state.repoListScrollPosition = el.main.scrollTop;
                state.shouldAnimateList = true;
                state.viewingOwner = repo.owner.login;

                const lastBranch = localStorage.getItem(`last_branch_${repo.full_name}`);
                navigateToRepo(repo, lastBranch || repo.default_branch);
            } else {
                showRepoOverview(repo);
            }
        } else {
            showToast('数据同步中，请稍后点击', 'info');
        }
    }
});

    el.contextMenuSettingsContent.addEventListener('change', e => {
        if (e.target.matches('input[type="checkbox"]')) {
            const { category, action } = e.target.dataset;
            const isVisible = e.target.checked;
            state.contextMenuVisibility[category][action] = isVisible;
            if (action === 'setAsMainSite') {
                 state.contextMenuVisibility.repo.copyMainSiteLink = isVisible;
            }
            saveContextMenuSettings();
        }
    });
    
    el.closeCustomDomainModalBtn.onclick = hideCustomDomainModal;
el.customDomainCancelBtn.onclick = hideCustomDomainModal;
el.customDomainSaveBtn.onclick = handleSaveCustomDomain;
el.customDomainInput.addEventListener('input', () => {
    el.customDomainSaveBtn.disabled = el.customDomainInput.value.trim() === '';
});
el.publishManageList.addEventListener('click', (e) => {
    const configureBtn = e.target.closest('.configure-domain-btn');
    const copyLinkBtn = e.target.closest('.copy-site-link-btn');
    const setAsMainSiteBtn = e.target.closest('.set-as-main-site-btn');
    const removeBtn = e.target.closest('.remove-domain-btn');

    if (removeBtn) {
        const repoFullName = removeBtn.dataset.repoFullname;
        if (repoFullName) {
            const repo = state.repos.find(r => r.full_name === repoFullName);
            if (repo) {
                showRemoveCustomDomainConfirmation(repo);
            }
        }
        return;
    }

    if (configureBtn) {
        const repoFullName = configureBtn.dataset.repoFullname;
        if (repoFullName) {
            showCustomDomainModal(repoFullName);
        }
        return;
    }
    
    if (setAsMainSiteBtn) {
        const repoFullName = setAsMainSiteBtn.dataset.repoFullname;
        const repo = state.repos.find(r => r.full_name === repoFullName);
        if (repo) {
            showPublishBranchSelectorModal(repo, 'mainSite');
        }
        return;
    }

    if (copyLinkBtn) {
        const repoFullName = copyLinkBtn.dataset.repoFullname;
        if (repoFullName && state.user && state.user.login) {
            const [owner, repoName] = repoFullName.split('/');
            const isMainSiteRepo = repoName === `${state.user.login}.github.io`;
            const siteUrl = isMainSiteRepo
                ? `https://${owner}.github.io/`
                : `https://${owner}.github.io/${repoName}/`;
            navigator.clipboard.writeText(siteUrl).then(() => {
                showToast(isMainSiteRepo ? '主站链接已复制' : '项目链接已复制');
            });
        }
        return;
    }
});

        const viewStarredBtn = document.getElementById('viewStarredBtn');
if (viewStarredBtn) {
    viewStarredBtn.addEventListener('click', () => {
        const icon = viewStarredBtn.querySelector('i');
        state.repoListScrollPosition = 0;
        
        if (icon.classList.contains('fa-star')) {
            history.pushState({ view: 'starred_repos' }, '', window.location.pathname);
            state.currentView = 'starred_repos';
            el.currentRepo.textContent = '星标仓库';
            fetchStarredRepos();
            updatePaginationUI();
        
        } else {
            history.pushState({ view: 'own_repos' }, '', window.location.pathname);
            state.currentRepo = null;
            state.currentPath = '';
            state.currentView = 'own_repos';
            el.currentRepo.textContent = '选择仓库';
            
            state.repos = [...state.myRepos]; 
            
            showRepoListView();
            renderRepoList(state.repos); 
            
            fetchRepos(true, false);
            updatePaginationUI();
        }

        updateHomeStarredButtonState();
        updateGlobalSearchVisibility();
    });
}
// 在多个视图切换函数中调用状态更新
const originalShowRepoListView = window.showRepoListView;
window.showRepoListView = function() {
    originalShowRepoListView.apply(this, arguments);
    updateHomeStarredButtonState();
};

const originalNavigateToRepo = window.navigateToRepo;
window.navigateToRepo = function() {
    originalNavigateToRepo.apply(this, arguments);
    updateHomeStarredButtonState();
};

const originalFetchAndDisplayUserRepos = window.fetchAndDisplayUserRepos;
window.fetchAndDisplayUserRepos = function() {
    originalFetchAndDisplayUserRepos.apply(this, arguments);
    updateHomeStarredButtonState();
};

const globalSearchToggleBtn = document.getElementById('globalSearchToggleBtn');
const globalSearchContainer = document.getElementById('globalSearchContainer');
const globalSearchInput = document.getElementById('globalSearchInput');



globalSearchInput.addEventListener('focus', () => {
        renderSearchHistory();
    });


globalSearchInput.addEventListener('blur', () => {
        setTimeout(() => {
            document.getElementById('globalSearchHistoryContainer').classList.add('hidden');
        }, 150); // 延迟150毫秒
    });

globalSearchToggleBtn.addEventListener('click', () => {
    globalSearchContainer.classList.toggle('hidden');
    globalSearchToggleBtn.classList.toggle('active');
    if (!globalSearchContainer.classList.contains('hidden')) {
        globalSearchInput.focus();
    }
});

globalSearchInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
        handleGlobalSearch(globalSearchInput.value);
    }
});


 
    
    // 关闭弹窗
    if (el.closeReleaseManagerBtn) {
        el.closeReleaseManagerBtn.onclick = hideReleaseManagerModal;
    }
    
    // 取消按钮
    if (el.cancelReleaseBtn) {
        el.cancelReleaseBtn.onclick = hideReleaseManagerModal;
    }

    // 提交发布按钮
    if (el.submitReleaseBtn) {
        el.submitReleaseBtn.onclick = createRelease;
    }
    
    // 点击遮罩层关闭
    if (el.releaseManagerModal) {
        el.releaseManagerModal.onclick = (e) => {
            if (e.target === el.releaseManagerModal) hideReleaseManagerModal();
        };
    }


    const tokenGuideHeader = document.querySelector('.token-instructions h4.lp');
    if (tokenGuideHeader) {
        tokenGuideHeader.addEventListener('click', function() {
            this.classList.toggle('active');
            
            const content = this.nextElementSibling;
            if (content) {
                content.classList.toggle('active');
            }
        });
    }



// 绑定概览模态框的关闭事件
    document.getElementById('closeOverviewBtn').onclick = hideRepoOverview;
    document.getElementById('repoOverviewModal').onclick = (e) => {
        if (e.target === document.getElementById('repoOverviewModal')) {
            hideRepoOverview();
        }
    };



function initFooterEvents() {
    const footer = document.querySelector('footer');
    if (!footer || footer.dataset.init === 'true') return;
    
    footer.dataset.init = 'true';
    
    const btns = footer.querySelectorAll('button');
    btns.forEach(btn => {
        btn.style.touchAction = 'manipulation';
        btn.style.userSelect = 'none';
        btn.style.webkitUserSelect = 'none';
    });

    footer.addEventListener('click', (e) => {
        const btn = e.target.closest('button');
        if (!btn || btn.classList.contains('hidden') || btn.disabled) return;
        
        e.preventDefault();
        e.stopPropagation();

        if (navigator.vibrate) {
            navigator.vibrate(15);
        }

        const id = btn.id;
        const view = state.currentView;
        const isOwner = state.user && state.viewingOwner === state.user.login;

        if (id === 'backBtn') {
            if (view === 'own_repos' && state.myReposPage > 1) {
                handlePrevRepoPage();
            } else {
                goUp();
            }
        } 
        else if (id === 'newFolderBtn') {
            if (view === 'public_search_results') {
                handlePrevPage();
            } else if (view === 'file_list' && isOwner) {
                showCreateFolderModal();
            } else if (view === 'own_repos' || !view) {
                showCreateRepoModal();
            } else {
                handlePrevRepoPage();
            }
        } 
        else if (id === 'newFileBtn') {
            if (view === 'public_search_results') {
                handleNextPage();
            } else if (view === 'file_list' && isOwner) {
                showCreateFileModal();
            } else {
                handleNextRepoPage();
            }
        } 
        else if (id === 'uploadBtn') {
            if (view === 'file_list') {
                if (isOwner) {
                    handleUploadClick();
                } else {
                    handleScrollToggle();
                }
            }
        }
        else if (id === 'newReleaseBtn') {
            if (view === 'releases_list') {
                const [owner] = state.viewingReleasesForRepo.split('/');
                const repo = state.repos.find(r => r.full_name === state.viewingReleasesForRepo) || 
                             { full_name: state.viewingReleasesForRepo, owner: { login: owner }, default_branch: 'main' };
                showReleaseManagerModal(repo, true);
            } else if (view === 'assets_list') {
                showPreUploadModal();
            }
        }
    }, { passive: false });
}


(function initFeedbackSystem() {
    const renderHub = () => {
        const modalId = 'feedbackModal';
        if (document.getElementById(modalId)) return;

        const styleId = 'honor-badges-style';
        if (!document.getElementById(styleId)) {
            const style = document.createElement('style');
            style.id = styleId;
            style.innerHTML = `
                .honor-tags-container {
                    display: flex;
                    flex-wrap: wrap;
                    gap: 4px;
                    margin-top: 2px;
                }
                .honor-tag {
                    display: inline-flex;
                    align-items: center;
                    font-size: 0.6rem;
                    color: #fff;
                    padding: 1px 6px;
                    border-radius: 4px;
                    font-weight: 500;
                    letter-spacing: 0.3px;
                    line-height: 1.4;
                    text-shadow: 0 1px 2px rgba(0,0,0,0.1);
                    box-shadow: 0 1px 2px rgba(0,0,0,0.05);
                }
                .honor-tag.gold {
                    background: linear-gradient(135deg, #fbbf24 0%, #d97706 100%);
                    border: 1px solid rgba(251, 191, 36, 0.2);
                }
                .honor-tag.pink {
                    background: linear-gradient(135deg, #f472b6 0%, #db2777 100%);
                    border: 1px solid rgba(244, 114, 182, 0.2);
                }
                .honor-tag.cyan {
                    background-image: linear-gradient( 135deg, #FAB2FF 10%, #1904E5 100%);
                    border: 1px solid rgba(34, 211, 238, 0.2);
                    user-select: text; /* 核心属性：允许选中文本 */
  -webkit-user-select: text; /* Safari/Chrome */
  -moz-user-select: text; /* Firefox */
  -ms-user-select: text; /* IE/Edge */
  cursor: text; /* 可选：鼠标悬浮显示文本光标，提升交互体验 */
                }
                .honor-tag.indigo {
                    background: linear-gradient(135deg, #818cf8 0%, #4f46e5 100%);
                    border: 1px solid rgba(129, 140, 248, 0.2);
                }
                .honor-chip { 
                    cursor: default !important;
                    align-items: flex-start;
                }
                .honor-chip:active { 
                    transform: none !important; 
                }
                .honor-avatar {
                    margin-top: 4px;
                }
                .honor-badge-icon {
                    margin-top: 4px;
                }
                
            `;
            document.head.appendChild(style);
        }

        const modal = document.createElement('div');
        modal.id = modalId;
        modal.className = 'modal-overlay hidden';
        modal.innerHTML = `
            <div class="modal-form-container">
                <div class="hub-header">
                    <button class="hub-close-btn"><i class="fa fa-times"></i></button>
                </div>
                
                <div class="author-card" data-qq="1473460411">
                    <div class="author-avatar-wrapper">
                        <img src="https://q1.qlogo.cn/g?b=qq&nk=1473460411&s=640" class="author-avatar">
                        <div class="verified-badge"><i class="fa fa-check"></i></div>
                    </div>
                    <div class="author-info">
                        <div class="author-name">
                            牡丹君 <span class="author-tag">开发者</span>
                        </div>
                        <div class="author-contact">
                            <i class="fa-brands fa-qq"></i> 1473460411
                            <span class="copy-hint">点击复制</span>
                        </div>
                        
                    </div>
                </div>

                <div class="honor-section">
                    <div class="honor-title">Hall of Fame</div>
                    <div class="honor-grid" id="honorGrid"></div>
                </div>

                <div class="footer-note">感谢所有支持项目发展的朋友</div>
            </div>
        `;
        document.body.appendChild(modal);

        const donors = [
            { 
                qq: '2357885308', 
                name: 'MW', 
                style: 'chip-gold',
                icon: 'fa-crown',
                tags: [
                    { text: '第 2 位捐赠者', color: 'gold' },
                    { text: '¥5', color: 'pink' },
                    { text: '杰出贡献者', color: 'indigo' },
                    { text: 'QQ：2357885308', color: 'cyan' }
                ]
            },
            { 
                qq: '1091809621', 
                name: '惊鲵', 
                style: 'chip-pink',
                icon: 'fa-heart',
                tags: [
                    { text: '第 1 位捐赠者', color: 'gold' },
                    { text: '¥20', color: 'pink' },
                    { text: 'QQ：1091809621', color: 'cyan' }
                ]
            },
            { 
                qq: '2624777236', 
                name: '无名', 
                style: 'chip-cyan',
                icon: 'fa-star',
                tags: [
                    { text: '杰出贡献者', color: 'indigo' },
                    { text: 'QQ：2624777236', color: 'cyan' }
                ]
            }
        ];

        const grid = modal.querySelector('#honorGrid');
        donors.forEach(d => {
            const chip = document.createElement('div');
            chip.className = `honor-chip ${d.style}`;
            
            const tagsHtml = d.tags.map(t => 
                `<span class="honor-tag ${t.color}">${t.text}</span>`
            ).join('');

            chip.innerHTML = `
                <img src="https://q1.qlogo.cn/g?b=qq&nk=${d.qq}&s=100" class="honor-avatar" loading="lazy">
                <div class="honor-info">
                    <div class="honor-name">${d.name}</div>
                    <div class="honor-tags-container">
                        ${tagsHtml}
                    </div>
                </div>
                <i class="fa ${d.icon} honor-badge-icon"></i>
            `;
            grid.appendChild(chip);
        });

        modal.querySelector('.author-card').onclick = () => handleCopyQQ('1473460411');
        
        modal.querySelector('.hub-close-btn').onclick = () => {
            modal.classList.add('hidden');
            if (window.uiStateStack) {
                const idx = window.uiStateStack.indexOf(closeFunc);
                if (idx > -1) window.uiStateStack.splice(idx, 1);
            }
        };
        
        modal.onclick = (e) => {
            if (e.target === modal) modal.querySelector('.hub-close-btn').click();
        };
    };

    const handleCopyQQ = (qq) => {
        navigator.clipboard.writeText(qq).then(() => {
            if(window.showToast) showToast(`已复制QQ: ${qq}`, 'success');
            else alert(`已复制: ${qq}`);
        }).catch(() => {
            if(window.showToast) showToast('复制失败', 'error');
        });
    };

    const closeFunc = () => {
        document.getElementById('feedbackModal').classList.add('hidden');
    };

    const injectMenuItem = () => {
        const themeBtn = document.getElementById('menuEffectsManager'); 
        if (!themeBtn) return;
        
        const parentLi = themeBtn.parentElement;
        const newLi = document.createElement('li');
        newLi.id = 'menuFeedback';
        newLi.innerHTML = `<a href="javascript:void(0);"><i class="fa fa-heart"></i>反馈鸣谢</a>`;
        
        parentLi.parentElement.insertBefore(newLi, parentLi.nextSibling);

        newLi.onclick = () => {
            if (window.closeSideNav) window.closeSideNav();
            renderHub();
            const modal = document.getElementById('feedbackModal');
            modal.classList.remove('hidden');
            if (window.uiStateStack) window.uiStateStack.push(closeFunc);
        };
    };

    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', injectMenuItem);
    } else {
        injectMenuItem();
    }
})();



const selectAllEditorBtn = document.getElementById('selectAllEditorBtn');
if (selectAllEditorBtn) {
    selectAllEditorBtn.onclick = function() {
        if (window.aceEditorInstance) {
            window.aceEditorInstance.selectAll();
            window.aceEditorInstance.focus();
            showToast('已全选所有内容');
        }
    };
}

const revertEditBtn = document.getElementById('revertEditBtn');
if (revertEditBtn) {
    revertEditBtn.onclick = function() {
        if (!state.originalContent && state.originalContent !== '') return;

        const isRawMode = el.fileContent.classList.contains('active');

        showDeleteModal(
            null,
            false,
            '确认撤销更改',
            '此操作将清除当前所有未保存的修改，并将文件重置为打开时的初始状态。\n\n该操作不可恢复，确定要继续吗？',
            () => {
                if (isRawMode) {
                    el.fileContent.value = state.originalContent;
                } else if (window.aceEditorInstance) {
                    window.aceEditorInstance.setValue(state.originalContent, -1);
                    window.aceEditorInstance.session.getUndoManager().reset();
                }

                checkContentChanges();
                showToast('已恢复原始内容', 'success');
                hideDeleteModal();
            },
            '确认重置',
            'btn-danger'
        );
    };
}







//尾巴
}




async function performRecursiveSearch(query) {
    el.fileList.innerHTML = '<div class="loading-spinner"><div class="spinner"></div></div>';
    state.isLocalSearchResultsView = true;

    try {
        const [owner, repo] = state.currentRepo.split('/');
        const url = `https://api.github.com/repos/${owner}/${repo}/git/trees/${state.currentBranch}?recursive=1`;
        const res = await fetch(url, { headers: { Authorization: `token ${state.token}` } });
        if (!res.ok) throw new Error('API请求失败，可能结果过多');
        const data = await res.json();

        if (data.truncated) {
            showToast('文件过多，仅显示部分结果', 'info');
        }

        const queryLower = query.toLowerCase();
        const currentPath = state.currentPath;

        const results = data.tree.filter(item => {
            if (!item.path.startsWith(currentPath)) {
                return false;
            }
            const itemName = item.path.split('/').pop().toLowerCase();
            return itemName.includes(queryLower);
        }).map(item => {
            const isDir = item.type === 'tree';
            const relativePath = item.path.substring(currentPath.length);
            return {
                name: relativePath,
                path: item.path,
                sha: item.sha,
                size: item.size,
                type: isDir ? 'dir' : 'file',
                html_url: `https://github.com/${state.currentRepo}/${isDir ? 'tree' : 'blob'}/${state.currentBranch}/${item.path}`,
                download_url: isDir ? null : `https://raw.githubusercontent.com/${state.currentRepo}/${state.currentBranch}/${item.path}`,
            };
        });

        state.displayFiles = results;
        renderFileList();

    } catch (error) {
        showToast(`搜索失败: ${error.message}`, 'error');
        el.fileList.innerHTML = `<div class="empty-state"><p>${error.message}</p></div>`;
    }
}



(function() {
    const config = {
        minFontSize: 8,
        maxFontSize: 40,
        defaultFontSize: 13,
        storageKey: 'ace_font_size',
        scaleSensitivity: 0.8 
    };

    function getSavedFontSize() {
        return parseInt(localStorage.getItem(config.storageKey)) || config.defaultFontSize;
    }

    function saveFontSize(size) {
        localStorage.setItem(config.storageKey, size);
    }

    function createFontSizeDisplay() {
        const display = document.createElement('div');
        display.style.cssText = `
            position: absolute; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%); 
            color: white; 
            padding: 8px 16px; 
            border-radius: 20px; 
            font-size: 14px; 
            font-weight: 600; 
            z-index: 2000; 
            pointer-events: none; 
            opacity: 0; 
            transition: opacity 0.2s; 
            background-color: rgba(0,0,0,0.7);
            backdrop-filter: blur(4px);
        `;
        return display;
    }

    function showFontSizeTooltip(display, size) {
        display.textContent = `字体大小: ${size}px`;
        display.style.opacity = '1';
        clearTimeout(display.hideTimeout);
        display.hideTimeout = setTimeout(() => { display.style.opacity = '0'; }, 1200);
    }

    function initGestureControls() {
        const observer = new MutationObserver(() => {
            const editModal = document.getElementById('editModal');
            const fileContent = document.getElementById('aceEditorContainer'); 
            const editorContainer = document.querySelector('.editor-container');

            if (editModal && fileContent && editorContainer && !fileContent.hasGestureControl) {
                fileContent.hasGestureControl = true;
                
                const fontSizeDisplay = createFontSizeDisplay();
                editorContainer.appendChild(fontSizeDisplay);

                let initialDistance = 0;
                let initialFontSize = 0;
                let isPinching = false;

                const applyFontSize = (size) => {
                    if(window.aceEditorInstance) {
                        window.aceEditorInstance.setOption('fontSize', size + 'px');
                        window.aceEditorInstance.renderer.updateFull(); 
                    }
                };

                const currentSavedSize = getSavedFontSize();
                applyFontSize(currentSavedSize);

                function getTouchDistance(touches) { 
                    const dx = touches[0].clientX - touches[1].clientX;
                    const dy = touches[0].clientY - touches[1].clientY; 
                    return Math.hypot(dx, dy); 
                }

                function updateFontSize(newSize) {
                    newSize = Math.max(config.minFontSize, Math.min(config.maxFontSize, Math.round(newSize)));
                    const currentInstanceSize = window.aceEditorInstance ? parseInt(window.aceEditorInstance.getOption('fontSize')) : config.defaultFontSize;
                    
                    if (newSize === currentInstanceSize) return;

                    applyFontSize(newSize);
                    showFontSizeTooltip(fontSizeDisplay, newSize);
                    saveFontSize(newSize);
                }

                fileContent.addEventListener('touchstart', (e) => { 
                    if (e.touches.length === 2) { 
                        e.preventDefault(); 
                        isPinching = true; 
                        initialDistance = getTouchDistance(e.touches); 
                        initialFontSize = window.aceEditorInstance ? parseInt(window.aceEditorInstance.getOption('fontSize')) : config.defaultFontSize;
                    } 
                }, { passive: false });

                fileContent.addEventListener('touchmove', (e) => { 
                    if (isPinching && e.touches.length === 2) { 
                        e.preventDefault(); 
                        const currentDistance = getTouchDistance(e.touches); 
                        if (initialDistance > 0) {
                            const scale = currentDistance / initialDistance;
                            const delta = (scale - 1) * config.scaleSensitivity; 
                            const newSize = initialFontSize * (1 + delta); 
                            updateFontSize(newSize); 
                        }
                    } 
                }, { passive: false });

                fileContent.addEventListener('touchend', () => { 
                    if (isPinching) {
                        isPinching = false;
                        if(window.aceEditorInstance) {
                            window.aceEditorInstance.resize(true); 
                        }
                    }
                });

                const editModalObserver = new MutationObserver((mutations) => { 
                    mutations.forEach((mutation) => {
                        if (mutation.attributeName === 'class' && !editModal.classList.contains('hidden')) {
                            const saved = getSavedFontSize();
                            applyFontSize(saved);
                            setTimeout(() => {
                                if(window.aceEditorInstance) window.aceEditorInstance.resize(true);
                            }, 100);
                        }
                    });
                });
                editModalObserver.observe(editModal, { attributes: true });
            }
        });
        observer.observe(document.body, { childList: true, subtree: true });
    }

    
})();
(function() {
    'use strict';
    const config = { 
        buttonId: 'toggleMaximizeModal', 
        modalId: 'editModal', 
        maximizedClass: 'maximized', 
        expandIcon: 'fa-expand', 
        compressIcon: 'fa-compress', 
        buttonTitle: { maximize: '最大化', restore: '恢复' } 
    };
    
    let maximizeButton = null, editModal = null, isToggling = false;
    
    function performResize() {
        if (typeof window.adjustEditorDimensions === 'function') {
            window.adjustEditorDimensions();
        }
        if (window.aceEditorInstance) {
            window.aceEditorInstance.resize(true);
            window.aceEditorInstance.renderer.updateFull();
        }
    }

    function toggleMaximize() {
        if (!editModal || !maximizeButton || isToggling) return;
        isToggling = true;
        
        const icon = maximizeButton.querySelector('i');
        const isCurrentlyMaximized = editModal.classList.contains(config.maximizedClass);

        if (isCurrentlyMaximized) {
            editModal.classList.remove(config.maximizedClass);
            icon.classList.remove(config.compressIcon);
            icon.classList.add(config.expandIcon);
            maximizeButton.title = config.buttonTitle.maximize;
        } else {
            editModal.classList.add(config.maximizedClass);
            icon.classList.remove(config.expandIcon);
            icon.classList.add(config.compressIcon);
            maximizeButton.title = config.buttonTitle.restore;
        }

        const newState = !isCurrentlyMaximized;
        try { localStorage.setItem('editor-maximized', newState.toString()); } catch (e) {}

        performResize();
        
        setTimeout(performResize, 50);
        setTimeout(performResize, 300);

        setTimeout(() => { isToggling = false; }, 300);
    }

    function initializeButton() {
        if (maximizeButton) return; 
        editModal = document.getElementById(config.modalId);
        maximizeButton = document.getElementById(config.buttonId);
        if (!editModal || !maximizeButton) return;
        maximizeButton.addEventListener('click', toggleMaximize);
    }

    function init() {
        const observer = new MutationObserver(() => { 
            if (!maximizeButton || !document.getElementById(config.buttonId)) initializeButton(); 
        });
        observer.observe(document.body, { childList: true, subtree: true });
        
        initializeButton();
        initTokenGuide(); 
        window.addEventListener('resize', () => {
            if (!editModal || editModal.classList.contains('hidden')) return;
            requestAnimationFrame(performResize);
        });
    }
    init();
})();


function initImageObserver() {
    imageObserver = new IntersectionObserver((entries, observer) => {
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                const container = entry.target;
                loadThumbnailImage(container);
                observer.unobserve(container);
            }
        });
    }, { rootMargin: '0px 0px 200px 0px' });
}



async function startBackgroundPreloading() {
    if (!state.currentRepoList || state.currentRepoList.length === 0 || !state.token) return;
    if (window.isPreloadingActive) return;
    window.isPreloadingActive = true;
    const itemsToPreload = state.REPOS_PER_PAGE || 20;
    const queue = state.currentRepoList.slice(0, itemsToPreload);
    for (const repo of queue) {
        if (state.isRefreshing) {
            await new Promise(r => setTimeout(r, 3000));
        }
        const branch = repo.default_branch || 'main';
        const cacheKey = `full_tree_cache:${repo.full_name}:${branch}`;
        try {
            let etag = null;
            const cached = await SimpleDB.get(cacheKey);
            if (cached) {
                if (Date.now() - cached.timestamp < 60 * 60 * 1000) {
                    continue; 
                }
                etag = cached.etag;
            }
            const url = `https://api.github.com/repos/${repo.full_name}/git/trees/${branch}?recursive=1`;
            const headers = { 
                Authorization: `token ${state.token}`,
                'User-Agent': 'Mozilla/5.0'
            };
            if (etag) {
                headers['If-None-Match'] = etag;
            }
            const res = await fetch(url, { headers });
            if (res.status === 304) {
                continue;
            }
            if (res.status === 403 || res.status === 429) {
                await new Promise(r => setTimeout(r, 60000));
                continue;
            }
            if (res.ok) {
                const newEtag = res.headers.get('ETag');
                const data = await res.json();
                if (!data.truncated) {
                    await SimpleDB.set(cacheKey, {
                        tree: data.tree,
                        etag: newEtag,
                        timestamp: Date.now()
                    });
                }
            }
            await new Promise(r => setTimeout(r, 1500));
        } catch (e) {}
    }
    window.isPreloadingActive = false;
}



async function init() {
    if (!state.loadedImageMap) state.loadedImageMap = new Map();
    
    // 1. 基础配置初始化 (极快)
    try {
        const lastVersion = localStorage.getItem('last_app_version');
        if (lastVersion !== CURRENT_VERSION) {
            const keysToKeep = [
                'github_accounts', 'active_github_account_id', 'app_theme', 
                'context_menu_visibility', 'last_app_version'
            ];
            for (let i = localStorage.length - 1; i >= 0; i--) {
                const key = localStorage.key(i);
                if (!keysToKeep.includes(key)) localStorage.removeItem(key);
            }
            state.fileCache.clear();
            localStorage.setItem('last_app_version', CURRENT_VERSION);
        }
    } catch (e) {
        console.error(e);
    }

    themeManager.init();
    loadSearchHistory();
    loadContextMenuSettings();
    setupEventListeners(); // 绑定事件
    initImageObserver();
    updateSortDropdownUI();
    initializeActiveToken(); // 读取 Token


    if (state.token) {
        showApp();
        updateUserUI();
        el.repoList.innerHTML = '<div class="loading-spinner"><div class="spinner"></div></div>';

        Promise.allSettled([
            fetchUserInfo(),
            fetchRepos(false, true),
            fetchStarredRepos(false, false),
            smartPreloadCNAMEs(),
            autoClearCacheIfNeeded()
        ]).then(() => {
            state.myRepos = [...state.repos];
            
            setTimeout(() => {
    initProxySystem(); 
    
    checkServerInfo();

    setTimeout(() => {
        startBackgroundPreloading();
    }, 3000);

}, 1000);
        });
    } else {
        showAuth();
        setTimeout(checkServerInfo, 1500);
    }
    
    
    // 绑定发布管理相关按钮事件
    el.closePublishManagerBtn.onclick = hidePublishManagerModal;
    el.officialConfigTabBtn.onclick = () => {
        state.publishManagerActiveTab = 'official';
        renderPublishManagerLists();
    };
    el.customDomainTabBtn.onclick = () => {
        state.publishManagerActiveTab = 'custom';
        renderPublishManagerLists();
    };
}

// 启动入口
document.addEventListener('DOMContentLoaded', function() {
    // 禁用全局文本选择，提升 App 质感
    document.documentElement.style.userSelect = 'none';
    
    // 重置路由状态
    history.replaceState({ repo: null, path: '' }, '', window.location.pathname);
    
    // 执行初始化
    init();
    initMediaPreview();
    initPullToRefresh();

    // 绑定浏览器后退事件
    window.addEventListener('popstate', async (event) => {
        if (handleBackPress()) {
            return;
        }

        state.shouldAnimateList = true;
        const historyState = event.state || { view: 'own_repos' };

        if ((state.currentView === 'releases_list' || state.currentView === 'assets_list') && 
            (historyState.view === 'releases_list' || historyState.view === 'assets_list')) {
        } 
        else if (historyState.view === 'file_list') {
            state.viewingReleasesForRepo = null;
            state.currentRelease = null;
        }

        switch (historyState.view) {
            case 'file_list':
                let repoData = state.repos.find(r => r.full_name === historyState.repo) 
                            || state.starredRepos.find(r => r.full_name === historyState.repo)
                            || (state.currentRepoList && state.currentRepoList.find(r => r.full_name === historyState.repo));

                if (repoData) {
                    navigateToRepo(repoData, historyState.branch || repoData.default_branch, historyState.path || '', false);
                } else if (historyState.repo) {
                    try {
                        const res = await fetch(`https://api.github.com/repos/${historyState.repo}`, { headers: { Authorization: `token ${state.token}` } });
                        if (res.ok) {
                            const freshRepoData = await res.json();
                            navigateToRepo(freshRepoData, historyState.branch || freshRepoData.default_branch, historyState.path || '', false);
                        } else {
                            console.warn('无法获取仓库详细信息，尝试仅使用路径导航');
                            if (state.currentRepo === historyState.repo) {
                                 state.currentPath = historyState.path || '';
                                 state.currentBranch = historyState.branch || 'main';
                                 fetchFiles(false);
                                 renderPathNav();
                                 updatePaginationUI();
                            } else {
                                showToast('无法获取仓库信息，返回主列表', 'error');
                                state.currentView = 'own_repos';
                                showRepoListView();
                            }
                        }
                    } catch (e) {
                        if (state.currentRepo === historyState.repo) {
                             state.currentPath = historyState.path || '';
                             fetchFiles(false);
                             renderPathNav();
                        } else {
                            showToast('网络错误，返回主列表', 'error');
                            state.currentView = 'own_repos';
                            showRepoListView();
                        }
                    }
                } else {
                    state.currentView = 'own_repos';
                    showRepoListView();
                }
                break;
            
            case 'releases_list':
                if (historyState.repo) {
                    state.viewingReleasesForRepo = historyState.repo;
                    await fetchAndDisplayReleases(historyState.repo, false);
                }
                break;
                
            case 'assets_list':
                if (historyState.repo) state.viewingReleasesForRepo = historyState.repo;
                if (state.releases && state.releases.length > 0) {
                    const release = state.releases.find(r => r.id === historyState.releaseId);
                    if (release) {
                        fetchAndDisplayAssets(release, false);
                    } else {
                        await fetchAndDisplayReleases(historyState.repo, false);
                    }
                } else {
                    await fetchAndDisplayReleases(historyState.repo, false);
                }
                break;

            case 'starred_repos':
                state.currentView = 'starred_repos';
                showRepoListView();
                if (state.starredRepos.length === 0) {
                    await fetchStarredRepos(true);
                } else {
                    renderRepoList(state.starredRepos);
                }
                setTimeout(() => { el.main.scrollTop = state.repoListScrollPosition; }, 0);
                break;

            case 'other_user_repos':
                await _renderAndFetchUserRepos(historyState.owner);
                break;

            case 'search_results':
                await searchGlobalFiles(historyState.query, false);
                break;

            case 'public_search_results':
                await searchPublicRepositories(historyState.query, historyState.page || 1, false);
                setTimeout(() => { el.main.scrollTop = state.repoListScrollPosition; }, 0);
                break;

            case 'own_repos':
            default:
                state.currentView = 'own_repos';
                showRepoListView();
                state.repos = [...state.myRepos];
                renderRepoList(state.repos);
                setTimeout(() => { el.main.scrollTop = state.repoListScrollPosition; }, 0);
                break;
        }
        updatePaginationUI();
    });
});





const SmartUpdater = {
    configUrl: 'https://raw.githubusercontent.com/rjdsq/github-king/main/远程/远程更新.json',
    proxyPrefixes: [
        'https://gh.927223.xyz/',
        'https://ghproxy.net/',
        'https://ghfast.top/',
        'https://tvv.tw/'
    ],

    async check() {
        const timestamp = `?t=${Date.now()}`;
        const urls = [
            ...this.proxyPrefixes.map(p => p + this.configUrl + timestamp),
            this.configUrl + timestamp 
        ];

        try {
            const data = await this.smartFetch(urls);
            if (data) {
                this.handleData(data);
            }
        } catch (e) {
            console.warn('Update check failed completely.');
        }
    },

    smartFetch(urls) {
        return new Promise((resolve, reject) => {
            let failedCount = 0;
            const total = urls.length;
            let resolved = false;

            urls.forEach(url => {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 5000); 

                fetch(url, { cache: 'no-store', signal: controller.signal })
                    .then(res => {
                        if (!res.ok) throw new Error('Status ' + res.status);
                        return res.json();
                    })
                    .then(data => {
                        if (!resolved) {
                            resolved = true;
                            clearTimeout(timeoutId);
                            resolve(data);
                        }
                    })
                    .catch(() => {
                        failedCount++;
                        if (failedCount === total && !resolved) {
                            reject(new Error('All mirrors failed'));
                        }
                    })
                    .finally(() => clearTimeout(timeoutId));
            });
        });
    },

    handleData(info) {
        if (info.版本 && this.isNewer(info.版本, CURRENT_VERSION)) {
            this.renderUpdateModal(info);
        }
        if (info.公告开关 === '开' && info.公告) {
            this.renderAnnouncementModal(info);
        }
    },

    isNewer(remote, local) {
        const r = remote.split('.').map(Number);
        const l = local.split('.').map(Number);
        for (let i = 0; i < Math.max(r.length, l.length); i++) {
            const rv = r[i] || 0;
            const lv = l[i] || 0;
            if (rv > lv) return true;
            if (rv < lv) return false;
        }
        return false;
    },

    createModalBase(id, isForced = false) {
        if (document.getElementById(id)) return null;
        const overlay = document.createElement('div');
        overlay.id = id;
        overlay.className = 'modern-modal-overlay';
        
        const close = () => {
            if (isForced) {
                overlay.style.display = 'flex';
                return;
            }
            overlay.style.opacity = '0';
            const card = overlay.querySelector('.modern-card');
            if(card) card.style.transform = 'scale(0.95) translateY(10px)';
            setTimeout(() => overlay.remove(), 300);
        };

        overlay.addEventListener('click', (e) => {
            if (e.target === overlay && !overlay.dataset.forced) close();
        });

        if (isForced) {
            const observer = new MutationObserver((mutations) => {
                if (!document.body.contains(overlay)) {
                    document.body.appendChild(overlay);
                }
            });
            observer.observe(document.body, { childList: true });
        }

        return { overlay, close };
    },

    renderUpdateModal(info) {
        const base = this.createModalBase('updateModal', info.强制更新 === '开');
        if (!base) return;

        const isForced = info.强制更新 === '开';
        if (isForced) base.overlay.dataset.forced = 'true';

        base.overlay.innerHTML = `
            <div class="modern-card">
                <div class="modern-header">
                    <div class="header-icon-wrapper update-icon">
                        <i class="fa fa-rocket"></i>
                    </div>
                    <div class="header-text">
                        <div class="header-title">发现新版本</div>
                        <div class="header-subtitle">
                            <span class="version-badge">v${info.版本}</span>
                            <span>当前: v${CURRENT_VERSION}</span>
                        </div>
                    </div>
                    ${!isForced ? `<button class="modern-close-btn"><i class="fa fa-times"></i></button>` : ''}
                </div>
                <div class="modern-content">
                    <div class="content-block">${(info.更新日志 || '').replace(/\n/g, '<br>')}</div>
                </div>
                <div class="modern-footer">
                    <button class="modern-btn btn-secondary-action copy-link-btn">
                        <i class="fa fa-link"></i> 复制链接
                    </button>
                    <button class="modern-btn btn-primary-action download-btn">
                        <i class="fa fa-cloud-download"></i> 立即更新
                    </button>
                </div>
            </div>
        `;

        document.body.appendChild(base.overlay);

        if (!isForced) {
            base.overlay.querySelector('.modern-close-btn').onclick = base.close;
        }

        base.overlay.querySelector('.download-btn').onclick = () => {
            window.open(info.下载地址, '_blank');
        };

        base.overlay.querySelector('.copy-link-btn').onclick = () => {
            navigator.clipboard.writeText(info.下载地址).then(() => {
                if (window.showToast) showToast('下载链接已复制');
            });
        };
    },

    renderAnnouncementModal(info) {
        const isForcedAnnounce = info.强制公告 === '开';
        const base = this.createModalBase('announcementModal', isForcedAnnounce);
        
        if (!base) {
            if (isForcedAnnounce) {
                const existing = document.getElementById('announcementModal');
                if (existing) existing.style.display = 'flex';
            }
            return;
        }

        if (isForcedAnnounce) base.overlay.dataset.forced = 'true';

        const hasLink = info.公告链接 && info.公告链接.trim();
        const hasCopy = info.公告复制内容 && info.公告复制内容.trim();
        const copyText = info.公告复制按钮文本 || '复制';
        const linkText = info.公告链接按钮文本 || '查看详情';

        let buttonsHtml = '';
        if (hasCopy) {
            buttonsHtml += `<button class="modern-btn btn-secondary-action copy-announce-btn"><i class="fa fa-copy"></i> ${copyText}</button>`;
        }
        if (hasLink) {
            buttonsHtml += `<button class="modern-btn btn-primary-action link-announce-btn"><i class="fa fa-external-link"></i> ${linkText}</button>`;
        }

        base.overlay.innerHTML = `
            <div class="modern-card" style="border-top: 4px solid #f59e0b;">
                <div class="modern-header">
                    <div class="header-icon-wrapper announce-icon">
                        <i class="fa fa-bullhorn"></i>
                    </div>
                    <div class="header-text">
                        <div class="header-title">公告通知</div>
                        <div class="header-subtitle">System Announcement</div>
                    </div>
                    ${!isForcedAnnounce ? `<button class="modern-close-btn"><i class="fa fa-times"></i></button>` : ''}
                </div>
                <div class="modern-content">
                    <div class="content-block" style="background:rgba(245, 158, 11, 0.1); border-color:rgba(245, 158, 11, 0.2); color:#fcd34d;">${(info.公告 || '').replace(/\n/g, '<br>')}</div>
                </div>
                ${buttonsHtml ? `<div class="modern-footer">${buttonsHtml}</div>` : ''}
            </div>
        `;

        document.body.appendChild(base.overlay);
        
        if (!isForcedAnnounce) {
            base.overlay.querySelector('.modern-close-btn').onclick = base.close;
        }

        if (hasLink) {
            base.overlay.querySelector('.link-announce-btn').onclick = () => window.open(info.公告链接, '_blank');
        }
        if (hasCopy) {
            base.overlay.querySelector('.copy-announce-btn').onclick = () => {
                navigator.clipboard.writeText(info.公告复制内容).then(() => {
                    if (window.showToast) showToast('内容已复制');
                });
            };
        }
    }
};

window.checkServerInfo = () => SmartUpdater.check();





function isNewerVersion(remoteVersion, localVersion) {
    const remoteParts = remoteVersion.split('.').map(Number);
    const localParts = localVersion.split('.').map(Number);
    const len = Math.max(remoteParts.length, localParts.length);
    for (let i = 0; i < len; i++) {
        const remote = remoteParts[i] || 0;
        const local = localParts[i] || 0;
        if (remote > local) return true;
        if (remote < local) return false;
    }
    return false;
}









async function unzipFile(file) {
    const confirmUnzip = async () => {
        const [owner, repo] = state.currentRepo.split('/');
        
        try {
            showToast('正在下载压缩包...', 'loading', 0);
            
            const response = await fetch(getProxiedUrl(file.download_url));
            if (!response.ok) throw new Error(`下载失败: ${response.status}`);
            const blob = await response.blob();

            showToast('正在解析 ZIP...', 'loading', 0);
            const zip = await JSZip.loadAsync(blob);
            const filesInZip = Object.values(zip.files).filter(item => !item.dir);
            const totalFiles = filesInZip.length;
            let uploadedCount = 0;

            if (totalFiles === 0) {
                showToast('压缩包为空', 'error');
                return;
            }
            
            const currentDir = state.currentPath || '';

            for (const zipEntry of filesInZip) {
                const contentBase64 = await zipEntry.async('base64');
                const entryName = zipEntry.name;
                const fullPath = currentDir + entryName;
                
                const uploadUrl = `https://api.github.com/repos/${owner}/${repo}/contents/${fullPath}`;
                
                let sha = null;
                try {
                    const checkRes = await fetch(uploadUrl + `?ref=${state.currentBranch}`, {
                         headers: { 'Authorization': `token ${state.token}` }
                    });
                    if (checkRes.ok) sha = (await checkRes.json()).sha;
                } catch (e) {}

                const body = {
                    message: `Unzip ${file.name}`,
                    content: contentBase64,
                    branch: state.currentBranch,
                };
                if (sha) body.sha = sha;

                const upRes = await fetch(uploadUrl, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `token ${state.token}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(body)
                });

                if (upRes.ok) {
                    const resData = await upRes.json();
                    let entryParent = '';
                    if (entryName.includes('/')) {
                        entryParent = currentDir + entryName.substring(0, entryName.lastIndexOf('/') + 1);
                    } else {
                        entryParent = currentDir;
                    }

                    await updateGlobalCacheState('add', {
                        path: fullPath,
                        type: 'file',
                        sha: resData.content.sha,
                        size: resData.content.size,
                        parentPath: entryParent
                    });
                    
                    uploadedCount++;
                    showToast(`解压进度: ${uploadedCount}/${totalFiles}`, 'loading', 0);
                }
            }

            showToast(`解压完成，共 ${uploadedCount} 个文件`, 'success');
            
            // 仅仅重新应用补丁并渲染，不触发网络请求
            if (state.files) {
                const patched = ConsistencyManager.apply(state.files);
                state.files = patched;
                state.shouldAnimateList = false;
                applyFiltersAndSort();
                renderFileList();
            }

        } catch (error) {
            showToast(`解压出错: ${error.message}`, 'error');
        }
    };

    showDeleteModal(
        null, 
        false, 
        '确认解压', 
        `将 "${file.name}" 解压到当前目录？(同名文件将被覆盖)`, 
        confirmUnzip, 
        '解压', 
        'btn-primary'
    );
}





</script>























































<script>
const CloudEffectManager = {
    settings: {
        repoOwner: 'rjdsq',
        repoName: 'github-king',
        path: '插件'
    },
    activeEffects: new Map(),
    effectPreferences: new Map(),
    cachedGroups: [],
    currentTab: 0,
    loadingPromise: null,
    
    // 【已恢复】保持你原先的缩放设置，确保特效清晰度一致
    VIRTUAL_SCALE: 2.6, 

    init() {
        this.injectStyles();
        this.bindEvents();
        this.setupGlobalEventProxy(); 
        this.loadPreferences();
        this.restoreSettings();
        this.preload();
    },

    getUniqueKey(category, name) {
        return `${category}_${name}`;
    },

    loadPreferences() {
        try {
            const savedPrefs = JSON.parse(localStorage.getItem('cloud_effects_prefs') || '{}');
            this.effectPreferences = new Map(Object.entries(savedPrefs));
        } catch (e) {
            this.effectPreferences = new Map();
        }
    },

    savePreferences() {
        const prefsObj = Object.fromEntries(this.effectPreferences);
        localStorage.setItem('cloud_effects_prefs', JSON.stringify(prefsObj));
    },

    getPreferredLayer(uniqueKey) {
        if (this.effectPreferences.has(uniqueKey)) {
            return this.effectPreferences.get(uniqueKey);
        }
        return undefined;
    },

    setPreferredLayer(uniqueKey, isTop) {
        this.effectPreferences.set(uniqueKey, isTop);
        this.savePreferences();
    },

    injectStyles() {
        if (document.getElementById('cloud-effect-styles')) return;
        const style = document.createElement('style');
        style.id = 'cloud-effect-styles';
        style.innerHTML = `
            /* 确保 App 主体有层级，但允许底部点击穿透 */
            #app, main { position: relative; z-index: 1; }
            
            .effect-tabs-container { margin: 0 0 15px 0; }
            .effect-tabs { display: flex; flex-wrap: wrap; gap: 8px; }
            .effect-tab-btn {
                background: rgba(255, 255, 255, 0.05); border: 1px solid rgba(255, 255, 255, 0.1);
                color: #9ca3af; font-size: 0.8rem; font-weight: 500; padding: 6px 12px;
                border-radius: 8px; cursor: pointer; transition: all 0.2s ease;
            }
            .effect-tab-btn.active {
                background: #6366f1; border-color: #6366f1; color: #ffffff;
                box-shadow: 0 2px 8px rgba(99, 102, 241, 0.3);
            }
            .effect-item {
                display: flex; align-items: center; justify-content: space-between;
                padding: 12px 16px; margin-bottom: 8px; background-color: rgba(255, 255, 255, 0.03);
                border: 1px solid rgba(255, 255, 255, 0.08); border-radius: 12px;
                cursor: pointer; transition: background-color 0.2s;
            }
            .effect-item:hover { background-color: rgba(255, 255, 255, 0.08); }
            .effect-item.active {
                background: linear-gradient(90deg, rgba(16, 185, 129, 0.15), rgba(16, 185, 129, 0.05));
                border-color: rgba(16, 185, 129, 0.4);
            }
            .effect-name { font-size: 0.85rem; color: #e0e7ff; font-weight: 600; }
            .effect-controls { display: flex; align-items: center; gap: 12px; }
            .effect-toggle-indicator {
                width: 36px; height: 20px; background-color: #374151; border-radius: 20px;
                position: relative; transition: background-color 0.3s;
            }
            .effect-toggle-indicator::after {
                content: ''; position: absolute; top: 2px; left: 2px; width: 16px; height: 16px;
                background-color: #9ca3af; border-radius: 50%;
                transition: transform 0.3s, background-color 0.3s;
            }
            .effect-item.active .effect-toggle-indicator { background-color: #10b981; }
            .effect-item.active .effect-toggle-indicator::after {
                transform: translateX(16px); background-color: #ffffff;
            }

            .layer-toggle-btn {
                appearance: none; display: flex; align-items: center; justify-content: center;
                padding: 4px 10px; font-size: 0.75rem; border-radius: 6px; font-weight: 600;
                border: 1px solid #4b5563; background-color: transparent; color: #9ca3af;
                cursor: pointer; transition: all 0.2s; z-index: 2;
            }
            .layer-toggle-btn:hover { color: #e0e7ff; border-color: #6b7280; }
            
            .layer-toggle-btn.is-top {
                border-color: #10b981; background-color: rgba(16, 185, 129, 0.15); 
                color: #34d399; box-shadow: 0 0 5px rgba(16, 185, 129, 0.2);
            }

            body.light-theme .effect-tab-btn { background: #f3f4f6; border-color: #e5e7eb; color: #4b5563; }
            body.light-theme .effect-tab-btn.active { background: #4f46e5; border-color: #4f46e5; color: #ffffff; }
            body.light-theme .effect-item { background-color: #ffffff; border-color: #e5e7eb; }
            body.light-theme .effect-item.active { background-color: #f0fdf4; border-color: #86efac; }
            body.light-theme .effect-name { color: #1f2937; }
            body.light-theme .effect-toggle-indicator { background-color: #e5e7eb; }
            
            body.light-theme .layer-toggle-btn {
                background-color: #f9fafb; border-color: #d1d5db; color: #6b7280;
            }
            body.light-theme .layer-toggle-btn:hover { border-color: #9ca3af; color: #374151; }
            body.light-theme .layer-toggle-btn.is-top {
                background-color: #dcfce7; border-color: #15803d; color: #15803d;
                box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
            }
        `;
        document.head.appendChild(style);
    },

    setupGlobalEventProxy() {
        let isTicking = false;
        
        const handlePointerEvent = (e) => {
            if (this.activeEffects.size === 0) return;
            
            if (e.type === 'pointermove' || e.type === 'touchmove' || e.type === 'mousemove') {
                if (isTicking) return;
                isTicking = true;
                requestAnimationFrame(() => {
                    this.broadcastEvent(e);
                    isTicking = false;
                });
            } else {
                this.broadcastEvent(e);
            }
        };

        const handleScrollEvent = () => {
            if (this.activeEffects.size === 0) return;
            const mainEl = document.querySelector('main');
            if (!mainEl) return;

            const scrollData = {
                type: 'scroll',
                scrollTop: mainEl.scrollTop,
                scrollHeight: mainEl.scrollHeight,
                clientHeight: mainEl.clientHeight,
                progress: mainEl.scrollTop / (mainEl.scrollHeight - mainEl.clientHeight || 1)
            };

            this.broadcastData(scrollData);
        };

        window.addEventListener('pointerdown', handlePointerEvent, { passive: true });
        window.addEventListener('pointermove', handlePointerEvent, { passive: true });
        window.addEventListener('pointerup', handlePointerEvent, { passive: true });
        window.addEventListener('click', handlePointerEvent, { passive: true });
        
        const mainEl = document.querySelector('main');
        if (mainEl) {
            mainEl.addEventListener('scroll', handleScrollEvent, { passive: true });
        }
    },

    broadcastEvent(e) {
        // 【已恢复】坐标乘以缩放比例，保证交互位置准确
        const x = (e.clientX || (e.touches && e.touches[0] ? e.touches[0].clientX : 0)) * this.VIRTUAL_SCALE;
        const y = (e.clientY || (e.touches && e.touches[0] ? e.touches[0].clientY : 0)) * this.VIRTUAL_SCALE;
        
        let type = e.type;
        if (type === 'pointerdown') type = 'mousedown';
        if (type === 'pointermove') type = 'mousemove';
        if (type === 'pointerup') type = 'mouseup';

        const message = { type, x, y };
        this.broadcastData(message);
    },

    broadcastData(data) {
        this.activeEffects.forEach(effect => {
            const uniqueKey = this.getUniqueKey(effect.category, effect.name);
            const hash = this.hashString(uniqueKey);
            const iframe = document.getElementById(`effect-frame-${hash}`);
            
            if (iframe && iframe.contentWindow) {
                iframe.contentWindow.postMessage(data, '*');
            }
        });
    },

    bindEvents() {
        const btn = document.getElementById('menuEffectsManager');
        const modal = document.getElementById('effectsManagerModal');
        const closeBtn = document.getElementById('closeEffectsManagerBtn');
        const refreshBtn = document.getElementById('refreshEffectsManagerBtn');

        if (btn) {
            btn.onclick = () => {
                if (typeof closeSideNav === 'function') closeSideNav();
                modal?.classList.remove('hidden');
                this.loadData();
            };
        }
        if (closeBtn) {
            closeBtn.onclick = () => modal?.classList.add('hidden');
        }
        if (refreshBtn) {
            let isRefreshing = false;
            refreshBtn.onclick = (e) => {
                e.stopPropagation();
                if (isRefreshing) return;
                isRefreshing = true;
                
                const icon = refreshBtn.querySelector('i');
                icon.classList.add('fa-spin');
                this.refresh();
                setTimeout(() => {
                    icon.classList.remove('fa-spin');
                    isRefreshing = false;
                }, 1000);
            };
        }
    },

    restoreSettings() {
        try {
            const savedData = JSON.parse(localStorage.getItem('cloud_effects_data') || '[]');
            if (Array.isArray(savedData)) {
                savedData.forEach(item => {
                    const category = item.category || '背景';
                    const uniqueKey = this.getUniqueKey(category, item.name);
                    const isBgOrTheme = category.includes('背景') || category.includes('主题');
                    
                    let isTop = item.isTop;
                    const pref = this.getPreferredLayer(uniqueKey);
                    
                    if (pref !== undefined) {
                        isTop = pref;
                    } else if (isBgOrTheme) {
                        isTop = false;
                    } else if (isTop === undefined) {
                        isTop = true;
                    }
                    
                    this.toggleEffect(item.id, item.name, item.url, category, false, isTop, true);
                });
            }
        } catch (e) {}
    },

    async preload() {
        if (this.loadingPromise) return;

        const headers = {};
        if (typeof state !== 'undefined' && state.token) {
            headers['Authorization'] = `token ${state.token}`;
        }

        const rootApiUrl = `https://api.github.com/repos/${this.settings.repoOwner}/${this.settings.repoName}/contents/${this.settings.path}`;

        this.loadingPromise = (async () => {
            const rootRes = await fetch(rootApiUrl, { headers });
            if (!rootRes.ok) throw new Error(rootRes.status);
            const rootItems = await rootRes.json();

            const folders = rootItems
                .filter(item => item.type === 'dir')
                .sort((a, b) => (parseInt(a.name) || 999) - (parseInt(b.name) || 999));

            const groups = await Promise.all(folders.map(async (folder) => {
                const folderRes = await fetch(folder.url, { headers });
                if (!folderRes.ok) return null;
                const files = await folderRes.json();
                const jsFiles = files.filter(f => f.name.endsWith('.js'));
                
                if (jsFiles.length === 0) return null;

                return {
                    id: folder.name,
                    displayName: folder.name.replace(/[^\u4e00-\u9fa5]/g, '') || folder.name,
                    originalName: folder.name,
                    files: jsFiles
                };
            }));

            this.cachedGroups = groups.filter(g => g !== null);
            return this.cachedGroups;
        })();

        return this.loadingPromise;
    },

    refresh() {
        this.cachedGroups = [];
        this.loadingPromise = null;
        this.currentTab = 0;
        const listEl = document.getElementById('effectsList');
        if (listEl) listEl.innerHTML = '';
        this.loadData();
    },

    async loadData() {
        const listEl = document.getElementById('effectsList');
        if (!listEl) return;

        if (this.cachedGroups && this.cachedGroups.length > 0) {
            this.renderInterface(listEl);
            return;
        }

        listEl.innerHTML = '<div class="loading-spinner"><div class="spinner"></div></div>';

        try {
            if (!this.loadingPromise) this.preload();
            await this.loadingPromise;
            this.renderInterface(listEl);
        } catch (e) {
            listEl.innerHTML = `<div class="empty-state"><p>加载失败</p><button class="btn btn-secondary btn-sm" style="margin-top:10px" onclick="CloudEffectManager.retryLoad()">重试</button></div>`;
        }
    },

    retryLoad() {
        this.loadingPromise = null;
        this.loadData();
    },

    renderInterface(container) {
        container.innerHTML = '';
        
        if (!this.cachedGroups.length) {
            container.innerHTML = '<div class="empty-state"><p>暂无数据</p></div>';
            return;
        }

        const tabsWrapper = document.createElement('div');
        tabsWrapper.className = 'effect-tabs-container';
        const tabsContainer = document.createElement('div');
        tabsContainer.className = 'effect-tabs';
        tabsWrapper.appendChild(tabsContainer);

        const contentContainer = document.createElement('div');
        contentContainer.className = 'effect-content-list';

        this.cachedGroups.forEach((group, index) => {
            const btn = document.createElement('button');
            btn.className = `effect-tab-btn ${index === this.currentTab ? 'active' : ''}`;
            btn.textContent = group.displayName;
            btn.onclick = () => {
                this.currentTab = index;
                this.updateTabs(tabsContainer);
                this.renderContent(contentContainer, group);
            };
            tabsContainer.appendChild(btn);
        });

        container.appendChild(tabsWrapper);
        container.appendChild(contentContainer);

        this.renderContent(contentContainer, this.cachedGroups[this.currentTab]);
    },

    updateTabs(container) {
        Array.from(container.children).forEach((btn, index) => {
            if (index === this.currentTab) btn.classList.add('active');
            else btn.classList.remove('active');
        });
    },

    renderContent(container, group) {
        container.innerHTML = '';
        const categoryName = group.displayName;
        const isBackgroundOrTheme = categoryName.includes('背景') || categoryName.includes('主题');

        group.files.forEach(file => {
            const name = file.name.replace('.js', '');
            const rawUrl = file.download_url || `https://raw.githubusercontent.com/${this.settings.repoOwner}/${this.settings.repoName}/master/${this.settings.path}/${group.originalName}/${file.name}`;
            this.renderItem(container, file.sha, name, rawUrl, categoryName, isBackgroundOrTheme);
        });
    },

    renderItem(container, id, name, url, category, showLayerControl) {
        const uniqueKey = this.getUniqueKey(category, name);
        const isActive = this.activeEffects.has(uniqueKey);
        let preferredIsTop = this.getPreferredLayer(uniqueKey);
        
        if (preferredIsTop === undefined) {
            preferredIsTop = !showLayerControl;
        }

        const item = document.createElement('div');
        item.className = `effect-item ${isActive ? 'active' : ''}`;
        
        let html = `<span class="effect-name">${name}</span><div class="effect-controls">`;
        if (showLayerControl) {
            html += `
                <button class="layer-toggle-btn ${preferredIsTop ? 'is-top' : ''}" type="button" data-preset="${preferredIsTop}">
                    ${preferredIsTop ? '顶层' : '底层'}
                </button>
            `;
        }
        html += `<div class="effect-toggle-indicator"></div></div>`;
        item.innerHTML = html;

        if (showLayerControl) {
            const layerBtn = item.querySelector('.layer-toggle-btn');
            layerBtn.onclick = (e) => {
                e.stopPropagation();
                
                const currentIsTop = layerBtn.classList.contains('is-top');
                const newIsTop = !currentIsTop;
                
                layerBtn.classList.toggle('is-top', newIsTop);
                layerBtn.textContent = newIsTop ? '顶层' : '底层';
                layerBtn.dataset.preset = newIsTop;
                
                this.setPreferredLayer(uniqueKey, newIsTop);

                if (this.activeEffects.has(uniqueKey)) {
                    this.toggleLayer(uniqueKey, newIsTop);
                }
            };
        }

        item.onclick = () => {
            let isTop = true;
            let currentPref = this.getPreferredLayer(uniqueKey);
            
            if (currentPref !== undefined) {
                isTop = currentPref;
            } else {
                isTop = !showLayerControl;
            }

            const isNowActive = this.toggleEffect(id, name, url, category, true, isTop);
            item.classList.toggle('active', isNowActive);
        };

        container.appendChild(item);
    },

    toggleLayer(uniqueKey, isTop) {
        const effect = this.activeEffects.get(uniqueKey);
        if (!effect) return;

        effect.isTop = isTop;
        const hash = this.hashString(uniqueKey);
        const frameId = `effect-frame-${hash}`;
        const iframe = document.getElementById(frameId);
        if (iframe) {
            iframe.style.zIndex = isTop ? 2147483647 : 0;
            iframe.style.backgroundColor = 'transparent';
        }
        
        this.saveActiveState();
    },

    toggleEffect(id, name, url, category, shouldSave = true, isTop = true, isSilent = false) {
        const uniqueKey = this.getUniqueKey(category, name);
        
        if (this.activeEffects.has(uniqueKey)) {
            this.activeEffects.delete(uniqueKey);
            this.stopEffect(uniqueKey);
            if (shouldSave) this.saveActiveState();
            return false;
        } else {
            this.activeEffects.set(uniqueKey, { id, name, url, category, isTop });
            this.startEffect(uniqueKey, url, category, isTop, isSilent);
            if (shouldSave) this.saveActiveState();
            return true;
        }
    },

    saveActiveState() {
        const data = Array.from(this.activeEffects.values());
        localStorage.setItem('cloud_effects_data', JSON.stringify(data));
    },

    async startEffect(uniqueKey, url, category, isTop, isSilent = false) {
        const hash = this.hashString(uniqueKey);
        if (document.getElementById(`effect-frame-${hash}`)) return;

        let jsCode = '';
        let retryCount = 0;
        const maxRetries = 2;
        let success = false;

        const finalUrl = typeof getProxiedUrl === 'function' ? getProxiedUrl(url) : url;

        while (retryCount <= maxRetries && !success) {
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 8000);
                
                const res = await fetch(finalUrl, { 
                    signal: controller.signal,
                    cache: 'default' 
                });
                
                clearTimeout(timeoutId);
                
                if (!res.ok) throw new Error(`HTTP ${res.status}`);
                
                jsCode = await res.text();
                
                // [核心修复] 校验内容是否为 HTML (代理错误页面)
                // 这能防止把 HTML 注入 script 导致的 SyntaxError
                if (jsCode.trim().startsWith('<') || jsCode.includes('<!DOCTYPE')) {
                    throw new Error('Invalid Content (HTML received)');
                }
                
                success = true;
            } catch (e) {
                retryCount++;
                if (retryCount <= maxRetries) {
                    await new Promise(r => setTimeout(r, 1000));
                }
            }
        }

        if (!success) {
            if (!isSilent) {
                this.toast(`插件加载失败 (网络或代理错误)`, 'error');
            }
            this.activeEffects.delete(uniqueKey);
            this.saveActiveState();
            
            // 尝试移除 UI 上的激活状态
            const listEl = document.getElementById('effectsList');
            if (listEl) {
                const items = listEl.querySelectorAll('.effect-item.active');
                items.forEach(el => {
                    if (el.textContent.includes(name)) el.classList.remove('active');
                });
            }
            return;
        }

        this.injectIframeEffect(uniqueKey, jsCode, isTop);
    },

    stopEffect(uniqueKey) {
        const hash = this.hashString(uniqueKey);
        const frame = document.getElementById(`effect-frame-${hash}`);
        if (frame) frame.remove();
        const script = document.getElementById(`effect-script-${hash}`);
        if (script) script.remove();
    },

    injectIframeEffect(uniqueKey, code, isTop) {
        const hash = this.hashString(uniqueKey);
        const frameId = `effect-frame-${hash}`;
        if (document.getElementById(frameId)) return;

        const iframe = document.createElement('iframe');
        iframe.id = frameId;
        
        // [修复] 背景层级为 0，防止被遮盖，同时背景透明
        const zIndex = isTop ? 2147483647 : 0;

        // [恢复] 使用 2.6 倍的缩放逻辑
        const scale = 1 / this.VIRTUAL_SCALE;
        const dimension = 100 * this.VIRTUAL_SCALE;

        iframe.style.cssText = `
            position: fixed; top: 0; left: 0; 
            width: ${dimension}%; height: ${dimension}%; border: none; 
            z-index: ${zIndex}; pointer-events: none; background: transparent;
            transform: scale(${scale}); transform-origin: 0 0;
        `;
        
        document.body.appendChild(iframe);

        const doc = iframe.contentWindow.document;
        doc.open();
        
        doc.write(`
            <!DOCTYPE html><html><head>
            <meta charset="utf-8">
            <style>
                * { margin: 0; padding: 0; box-sizing: border-box; } 
                body, html { width: 100%; height: 100%; overflow: hidden; background: transparent; } 
                canvas { display: block; outline: none; }
            </style>
            </head><body><script>
            window.onerror = function() { return true; };
            
            let lastTriggerTime = 0;
            const DOUBLE_TRIGGER_THRESHOLD = 50; 

            window.addEventListener('message', function(e) {
                if (!e.data || !e.data.type) return;
                
                const { type, x, y } = e.data;
                const target = document.elementFromPoint(x, y) || document.body;

                if (type === 'scroll') {
                    window.dispatchEvent(new CustomEvent('parentScroll', { detail: e.data }));
                    document.body.style.setProperty('--scroll-top', e.data.scrollTop + 'px');
                    document.body.style.setProperty('--scroll-progress', e.data.progress);
                    return;
                }

                const opts = {
                    bubbles: true, cancelable: true, view: window,
                    clientX: x, clientY: y, screenX: x, screenY: y, pageX: x, pageY: y
                };

                let evt;
                
                if (type === 'mousedown') {
                    lastTriggerTime = Date.now();
                    evt = new MouseEvent('mousedown', opts);
                } 
                else if (type === 'click') {
                    if (Date.now() - lastTriggerTime > DOUBLE_TRIGGER_THRESHOLD) {
                        evt = new MouseEvent('click', opts);
                    }
                } 
                else if (type.startsWith('mouse')) {
                    evt = new MouseEvent(type, opts);
                }

                if (evt) target.dispatchEvent(evt);
            });

            setTimeout(() => { 
                try { ${code} } catch(e) { console.warn('Effect Error:', e) } 
            }, 10);
            <\/script></body></html>
        `);
        doc.close();
    },

    hashString(str) {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            hash = ((hash << 5) - hash) + str.charCodeAt(i);
            hash |= 0;
        }
        return Math.abs(hash);
    },

    toast(msg, type = 'info') {
        if (typeof showToast === 'function') showToast(msg, type);
    }
};

document.addEventListener('DOMContentLoaded', () => {
    CloudEffectManager.init();
});
</script>


<script>
const LibraryLoader = {
    loaded: {},
    load: function(url, globalName) {
        if (this.loaded[url]) return Promise.resolve(window[globalName]);
        return new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.src = url;
            script.onload = () => {
                this.loaded[url] = true;
                resolve(window[globalName]);
            };
            script.onerror = reject;
            document.head.appendChild(script);
        });
    }
};

const LIBS = {
    JSZIP: 'https://cdn.bootcdn.net/ajax/libs/jszip/3.10.1/jszip.min.js',
    MARKED: 'https://cdn.bootcdn.net/ajax/libs/marked/9.1.2/marked.min.js'
};


</script>
</body>
</html>
