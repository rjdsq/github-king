
<!DOCTYPE html>
<html lang="zh-CN">
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
		<title>
			GitHub仓库管理器
		</title>
		<link rel="stylesheet" href="./style.css">
		<link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/font-awesome/7.0.0/css/all.min.css">
	</head>
	<style>



	</style>
	<body>

<script>
  (function() {
    try {
      const savedTheme = localStorage.getItem('app_theme');
      if (savedTheme === 'light') {
        document.documentElement.classList.add('light-theme-loading');
        document.body.classList.add('light-theme');
      }

      const activeAccountId = localStorage.getItem('active_github_account_id');
      if (activeAccountId) {
        document.documentElement.classList.add('app-visible-loading');
      } else {
        document.documentElement.classList.add('auth-visible-loading');
      }
    } catch (e) {
      document.documentElement.classList.add('auth-visible-loading');
    }
  })();
</script>
	<canvas id="particle-canvas"></canvas>
		<!-- 认证页面 -->
		
		<div id="authScreen">
		
			<div class="auth-header">
			
				<i class="fa-brands fa-github"></i>
			
				<h1>
					GitHub仓库管理器
				</h1>
				<p>
					全方位的仓库管理工具
				</p>
			</div>
			
			
<div class="login-container">
    <div class="auth-form">
        <input type="text" id="tokenInput" placeholder="输入GitHub访问令牌">
        
        <div class="auth-buttons-container">
            
<button class="auth-button" id="manageAccountsBtn">
    
    <span>账号管理</span>
</button>
            <button id="authBtn"><span>登录</span><i class="fa fa-spinner fa-spin hidden"></i></button>
        </div>
    </div>
    
    
    
    

    <div class="token-instructions">
        <h4 class="lp"><i class="fa fa-key"></i> 令牌获取指南 <i class="fa-solid fa-chevron-down"></i></h4>
        <div class="token-content">
        <ol>
            <li>复制下面官网链接，直达令牌生成界面：
            <small>https://github.com/settings/tokens/new </small></li>
            <li>在浏览器中粘贴链接并登录账号
                <small>如果注册登录后，若未跳转到令牌生成页，请重新粘贴一次链接直达令牌生成界面</small>
            </li>
            <li>进入令牌 Token设置页面后，按以下步骤操作：
                <ul>
                    <li><strong>勾选：</strong>下滑页面，勾选所有权限选框</li>
                    <li><strong>效期：</strong>选择一个合适的有效期</li>
                    <li><strong>生成：</strong>点击底部绿色按钮生成令牌</li>
                </ul>
            </li>
            <li><strong>复制</strong> 生成的令牌粘贴到输入框内完成登录</li>
            
            <li><strong>提示：</strong>Github官网若无法访问，请使用小飞机</li>
        </ol>
</div>
    </div>
</div>
		</div>
		
		
	<!-- 提示消息框 -->
<!-- 提示消息框 -->
<div id="toast">
    <span id="toastMessage"></span>
</div>
		<!-- 主应用容器 -->
		<div id="app" class="hidden">
			<!-- 头部栏 -->
			<header>
				<div class="header-left">
				<!-- class github图标 -->
					
					<h1 id="currentRepo">
						选择仓库
					</h1>
					<div id="branchSwitcherContainer" class="hidden">
					</div>
					<div id="pathNav">
					</div>
					<div id="pathNavContainer">
					</div>
				</div>
				<div class="header-right">
			<button id="menuThemeToggle">
    <i class="fa-regular fa-cloud"></i>
    <span>切换主题
</span>
</button>
					<button id="mainMenuBtn" title="菜单">
						<i class="fa-regular fa-user"></i>
					</button>
				</div>
			</header>
			<!-- 主内容区 -->
			<main>
			<div id="pull-to-refresh">
					
					<div class="ptr-spinner spinner"></div>
				</div>
				
				<!-- 全局加载动画 -->
				<div id="mainLoader" class="loading-overlay hidden">
					<div class="spinner">
					</div>
				</div>
				<!-- 文件工具栏 -->
				<div id="toolbar" class="hidden">
					<div class="toolbar-left">
						<input id="searchInput" placeholder="搜索文件/文件夹..." class="hidden">
					</div>
					<button id="searchToggleBtn" class="btn-icon" title="搜索">
						<i class="fa fa-search">
						</i>
					</button>
					<button id="proxyQuickToggle" title="代理状态">
						<i class="fa fa-power-off">
						</i>
					</button>
					<div class="toolbar-right">
						<div class="custom-select-container">
							<button id="sortToggleBtn" class="btn-icon" title="排序">
							<i class="fa-solid fa-up-down"></i>
							</button>
							<!-- 排序下拉菜单 -->
							<div id="customSortDropdown" class="hidden custom-dropdown">      
    <div class="dropdown-item" data-priority="dirs_first">
        <i class="fa-regular fa-folder"></i>
        文件夹优先
    </div>
    <div class="dropdown-item" data-priority="files_first">
        <i class="fa-regular fa-file"></i>
        文件优先
    </div>
    <div class="dropdown-divider"></div>
    <div class="dropdown-item" data-value="type_name_asc">
        按类型
    </div>
    <div class="dropdown-item" data-value="name_asc">
        名称 A→Z
    </div>
    <div class="dropdown-item" data-value="name_desc">
        名称 Z→A
    </div>
    
    <div class="dropdown-item" data-value="size_desc">
        大小 大→小
    </div>
    <div class="dropdown-item" data-value="size_asc">
        大小 小→大
    </div>
</div>
						</div>
						<button id="multiSelectToggleBtn" class="btn-icon" title="多项选择">
						<i class="fa-regular fa-circle-check"></i>
						</button>
						<button id="viewToggleBtn" title="切换视图">
							<i class="fa fa-th-large">
							</i>
						</button>
					</div>
				</div>
				<!-- 仓库列表 -->
				<div id="repoList">
					<div class="loading-spinner">
						<div class="spinner">
						</div>
					</div>
				</div>
				<!-- 文件列表 -->
				<div id="fileList" class="hidden">
					<div class="loading-spinner">
						<div class="spinner">
						</div>
					</div>
				</div>
			</main>
						<!-- 重命名弹窗 -->
			<div id="renameModal" class="modal-overlay hidden">
				<div class="modal-form-container">
					<h3 id="renameTitle">
						<span class="modal-title-text">
							重命名
						</span>
						<button class="btn-icon-sm" onclick="hideRenameModal()"
						title="关闭">
							<i class="fa fa-times">
							</i>
						</button>
					</h3>
					<input type="text" id="renameInput" value="" autocomplete="off">
					
					<!-- 【核心新增】在这里添加一个空的容器，作为“插槽” -->
					<div id="renameModalExtraSettings"></div>

					<div id="renameWarn" class="text-red-400" >
					</div>
					<div class="modal-buttons">
						<button id="renameCancel" class="btn btn-cancel">
							取消
						</button>
						<button id="renameConfirm" class="btn btn-primary" disabled>
							确认
						</button>
					</div>
				</div>
			</div>
			
			<!-- 文件编辑弹窗 -->
						<!-- 文件编辑弹窗 -->
			<div id="editModal" class="hidden">
				<div class="modal-content">
					<div class="modal-header">
    <h5 id="editFileName">
        编辑文件
    </h5>
    <button id="closeEditModal">
        <i class="fa fa-times">
        </i>
    </button>
</div>
					<div id="editStatus">
					</div>
					<div class="editor-container">
						<!-- 新增的搜索面板 -->
						<div id="editorSearchPanel" class="hidden">
							<input type="text" id="editorSearchInput" placeholder="搜索...">
							<span id="editorSearchMatchCount"></span>
							<button id="editorSearchPrevBtn" title="上一个"><i class="fa fa-chevron-up"></i></button>
							<button id="editorSearchNextBtn" title="下一个"><i class="fa fa-chevron-down"></i></button>
							<button id="editorSearchCloseBtn" title="关闭搜索"><i class="fa fa-times"></i></button>
						</div>

						<div id="editorOverlay">
							<div class="spinner-container">
								<i class="fa fa-spinner fa-spin">
								</i>
							</div>
						</div>
						<div id="saveNotification">
							<i class="fa fa-check">
							</i>
							保存成功
						</div>
						<textarea id="fileContent">
						</textarea>
					</div>
					<div class="modal-footer">
					
    <button id="revertEditBtn" title="撤销修改" disabled>
        <i class="fa fa-undo"></i>
        <span>撤销</span>
    </button>
    <button id="searchInFileBtn">
        <i class="fa fa-search"></i>
        <span>搜索</span>
    </button>
    
    <button id="toggleMaximizeModal" title="最大化">
        <i class="fa fa-expand"></i>
        <span>全屏</span>
    </button>
    <button id="cancelEdit">
        <i class="fa fa-times"></i>
        <span>取消</span>
    </button>
    <button id="saveEdit">
        <i class="fa-solid fa-check"></i>
        <span>保存</span>
    </button>
</div>
				</div>
			</div>
			
			
			<!-- 右键/长按菜单 -->
			<div id="contextMenu" class="hidden">
				<div id="contextMenuItems">
				</div>
			</div>
			
			<!-- 隐藏的文件上传输入框 -->
			<input type="file" id="fileUploadInput" multiple class="hidden">
			<!-- 主菜单弹窗 -->
			<div id="mainMenuPopup" class="hidden">
    <div class="user-profile-header">
        <!-- 用户头像容器 -->
        <div id="avatarContainer" title="点击更换头像">
            <i id="userAvatarPlaceholder" class="fa fa-github"></i>
            <img id="userAvatar" src="" alt="User Avatar" class="fa fa-github hidden">
        </div>
        <span id="userName">
            name
        </span>
    </div>
    
				<div class="menu-items-container">
					
					<button id="menuProxySettings">
					<i class="fa-solid fa-gears"></i>
						代理设置
					</button>
					<button id="menuContextMenuSettings">
<i class="fa-regular fa-hand-pointer"></i>
    菜单设置
</button>
<button id="menuBatchPublishSites">
        <i class="fa-solid fa-layer-group"></i>
        网站部署
    </button>
					<button id="menuClearCache">
						<i class="fa-regular fa-trash-can"></i>
						清除缓存
					</button>
					<button id="menuSwitchAccount">
        <i class="fa fa-exchange"></i>
        <span>切换账号</span>
    </button>
					<button id="menuLogout">
						<i class="fa fa-sign-out">
						</i>
						退出登录
					</button>
				</div>
			</div>
			<!-- 底部操作栏 -->
			<footer>
				<button id="backBtn" title="返回上级">
					<i class="fa-solid fa-arrow-up"></i>
				</button>
				<button id="newFolderBtn" title="新建仓库">
					<i class="fa-regular fa-folder-open"></i>
				</button>
				<button id="newFileBtn" title="新建文件">
					<i class="fa-regular fa-file"></i>
				</button>
				<button id="uploadBtn" title="上传文件">
					<i class="fa-solid fa-arrow-up-from-bracket"></i>
				</button>
			</footer>
			<!-- 媒体文件预览容器 -->
			<div id="mediaPreview" class="hidden">
				<img id="mediaPreviewImg" style="display:none;" alt="预览图片">
				<video id="mediaPreviewVideo" style="display:none;" controls>
				</video>
			</div>
			
			
			
			
			
			</div>
			
			
			
			
			
			
			<!-- 新建仓库弹窗 -->
			<div id="createRepoModal" class="modal-overlay hidden">
				<div class="modal-form-container">
					<h3>
						<span class="modal-title-text">
							新建仓库
						</span>
						<button class="btn-icon-sm" onclick="hideCreateRepoModal()"
						title="关闭">
							<i class="fa fa-times">
							</i>
						</button>
					</h3>
					<input id="createRepoNameInput" placeholder="输入仓库名称（仅支持英文、数字、连字符）">
					<div id="repoNameError" class="text-red-400" style="font-size: 0.75rem; margin-top: -0.4rem; margin-bottom: 0.4rem; display: none;">
					</div>
					<textarea id="createRepoDescInput" placeholder="仓库描述（可选）">
					</textarea>
					<div class="checkbox-container">
						<input type="checkbox" id="createRepoPrivate">
						<label for="createRepoPrivate">
							公开仓库
						</label>
					</div>
					<div class="modal-buttons">
						<button id="createRepoCancel" class="btn btn-cancel">
							取消
						</button>
						<button id="createRepoConfirm" class="btn btn-primary" disabled>
							创建仓库
						</button>
					</div>
				</div>
			</div>
			<!-- 新建文件夹弹窗 -->
			<div id="createFolderModal" class="modal-overlay hidden">
				<div class="modal-form-container">
					<h3>
						<span class="modal-title-text">
							新建文件夹
						</span>
						<button class="btn-icon-sm" onclick="hideCreateFolderModal()"
						title="关闭">
							<i class="fa fa-times">
							</i>
						</button>
					</h3>
					<input id="createFolderInput" placeholder="输入文件夹名称">
					<div class="modal-buttons">
						<button id="createFolderCancel" class="btn btn-cancel">
							取消
						</button>
						<button id="createFolderConfirm" class="btn btn-primary" disabled>
							确认
						</button>
					</div>
				</div>
			</div>
			<!-- 新建文件弹窗 -->
			<div id="createFileModal" class="modal-overlay hidden">
				<div class="modal-form-container">
					<h3>
						<span class="modal-title-text">
							新建文件
						</span>
						<button class="btn-icon-sm" onclick="hideCreateFileModal()"
						title="关闭">
							<i class="fa fa-times">
							</i>
						</button>
					</h3>
					<input id="createFileNameInput" placeholder="输入文件名，如 example.txt">
					<textarea id="createFileContentInput" placeholder="文件内容（可选）">
					</textarea>
					<div class="modal-buttons">
						<button id="createFileCancel" class="btn btn-cancel">
							取消
						</button>
						<button id="createFileConfirm" class="btn btn-primary" disabled>
							确认
						</button>
					</div>
				</div>
			</div>
			
			
			<!-- 新建分支弹窗 -->
			<div id="createBranchModal" class="modal-overlay hidden">
				<div class="modal-form-container">
					<h3>
						<span class="modal-title-text">
							分支管理
						</span>
						<button class="btn-icon-sm" onclick="hideCreateBranchModal()"
						title="关闭">
							<i class="fa fa-times">
							</i>
						</button>
					</h3>
					<div class="form-group">
						<label for="createBranchNameInput">
							新分支名称:
						</label>
						<input id="createBranchNameInput" placeholder="输入新分支名称">
					</div>
					<div class="form-group">
						<label>
							基于分支:
						</label>
						<div class="branch-select-container">
							<div id="sourceBranchSelector" class="custom-branch-select-wrapper">
								<button class="custom-branch-select-trigger">
									<span>
									</span>
									<i class="fa fa-chevron-down">
									</i>
									
								</button>
								<div class="custom-branch-select-options">
								</div>
							</div>
							<button id="renameBranchBtn" class="btn-icon" title="重命名所选分支">
								<i class="fa fa-pencil">
								</i>
							</button>
							<button id="deleteBranchBtn" class="btn-icon danger" title="删除所选分支">
								<i class="fa-regular fa-trash-can">
								</i>
							</button>
						</div>
					</div>
					<div class="modal-buttons">
						<button id="createBranchCancel" class="btn btn-cancel">
							取消
						</button>
						<button id="createBranchConfirm" class="btn btn-primary" disabled>
							创建分支
						</button>
					</div>
				</div>
			</div>
	
	
<div id="setAsSiteModal" class="modal-overlay hidden">
    <div class="modal-form-container">
        <h3>
            <span class="modal-title-text">发布主网站</span>
            <button class="btn-icon-sm" id="setAsSiteCloseBtn" title="关闭"><i class="fa fa-times"></i></button>
        </h3>
        <p>选择一个分支作为您网站的发布源。</p>
        <div class="form-group">
            <label for="setAsSiteBranchSelector">选择分支:</label>
            <div id="setAsSiteBranchSelector" class="custom-branch-select-wrapper">
                <button class="custom-branch-select-trigger">
                    <span></span>
                    <i class="fa fa-chevron-down"></i>
                </button>
                <div class="custom-branch-select-options">
                    <!-- Branches will be populated here -->
                </div>
            </div>
        </div>
        <div class="modal-buttons">
            <button id="setAsSiteCancelBtn" class="btn btn-cancel">取消</button>
            <button id="setAsSiteConfirmBtn" class="btn btn-primary">确认发布</button>
        </div>
    </div>
</div>
		<!-- 文件上传面板 -->
		<div id="uploadPanel" class="hidden">
			<div id="uploadItems" class="scmz">
			</div>
		</div>
		<!-- 代理设置弹窗 -->
<div id="proxySettingsModal" class="modal-overlay hidden">
    <div class="modal-form-container">
        <!-- 弹窗头部 -->
        <h3>
            <span class="modal-title-text">代理设置</span>
            <div class="proxy-header-actions">
                <label class="switch" title="点击切换全局代理状态">
                    <input type="checkbox" id="proxyGlobalEnableToggle">
                    <span class="slider round"></span>
                </label>
                <button id="proxyCancelSettingsBtn" class="btn-icon-sm" title="关闭设置">
                    <i class="fa fa-times"></i>
                </button>
            </div>
        </h3>

        <!-- 代理列表区域 -->
        <div class="proxy-list-container" id="proxyListContainer">
            <div class="empty-state hidden" id="proxyListEmpty">
                <i class="fa fa-plug"></i>
                <p>暂无代理节点</p>
                <span>点击右下角的 <i class="fa fa-plus-circle"></i> 添加，或从工具栏 <i class="fa fa-cloud-download"></i> 导入</span>
            </div>
            <!-- 代理项动态生成 -->
        </div>

        <!-- 底部操作区 -->
        <div class="proxy-footer-actions">
            <div class="proxy-footer-toolbar">
                <button id="importBtn" class="btn-icon" title="从订阅链接导入并刷新">
    <i class="fa fa-cloud-download"></i>
    <span class="spinner-small hidden" id="importSpinner"></span>
</button>
                <button id="proxyTestAllBtn" class="btn-icon" title="全部测试延迟">
                    <i class="fa-solid fa-bolt"></i>
                    <span class="spinner-small hidden" id="proxyTestAllSpinner"></span>
                </button>
                <button id="proxyAutoSelectToggle" class="btn-icon" title="点击切换自动选择最低延迟代理">
                    <i class="fa fa-magic"></i>
                </button>
                <button id="proxyClearAllBtn" class="btn-icon danger" title="清空所有代理">
                    <i class="fa-regular fa-trash-can"></i>
                </button>
                <button id="proxyAddBtn" class="btn-icon" title="添加代理">
            <i class="fa fa-plus"></i>
        </button>
            </div>
            
            
        </div>
    </div>
</div>
		<!-- 添加/编辑代理弹窗 -->
<div id="addEditProxyModal" class="modal-overlay hidden">
    <div class="modal-form-container">
        <h3 id="addEditProxyTitle">
            <span class="modal-title-text">添加新代理</span>
            <button class="btn-icon-sm" onclick="closeAddEditProxyModal()" title="关闭">
                <i class="fa fa-times"></i>
            </button>
        </h3>

        <input id="addEditProxyUrlInput" type="url" placeholder="请输入代理域名或URL" autocomplete="off">
        
        <div id="addEditProxyError" class="text-red-400" style="font-size: 0.75rem; margin-top: -0.4rem; margin-bottom: 0.4rem; display: none;">
            
        </div>

      

        
        <div class="modal-buttons" style="margin-top:0.6rem;">
            <button id="addEditProxyCancelBtn" class="btn btn-cancel">取消</button>
            <button id="addEditProxySaveBtn" class="btn btn-primary" disabled>保存</button>
        </div>
    </div>
</div>
		<!-- 确认删除代理弹窗 -->
		<div id="confirmDeleteProxyModal" class="modal-overlay hidden">
			<div class="modal-form-container">
				<h3 id="confirmDeleteProxyTitle">
					<span class="modal-title-text">
						确认删除
					</span>
					<button class="btn-icon-sm" onclick="hideConfirmDeleteProxyModal()" title="取消">
						<i class="fa fa-times">
						</i>
					</button>
				</h3>
				<p id="confirmDeleteProxyMessage">
				</p>
				<div class="modal-buttons">
					<button id="confirmDeleteProxyCancelBtn" class="btn btn-cancel">
						取消
					</button>
					<button id="confirmDeleteProxyConfirmBtn" class="btn btn-danger">
						确认删除
					</button>
				</div>
			</div>
		</div>
		<!-- 确认清空代理弹窗 -->
		<div id="confirmClearAllProxiesModal" class="modal-overlay hidden">
			<div class="modal-form-container">
				<h3>
					<span class="modal-title-text">
						确认清空所有代理
					</span>
					<button class="btn-icon-sm" onclick="hideConfirmClearAllProxiesModal()"
					title="取消">
						<i class="fa fa-times">
						</i>
					</button>
				</h3>
				<p>
					这将删除所有代理
				</p>
				<div class="modal-buttons">
					<button id="clearAllProxiesCancelBtn" class="btn btn-cancel">
						取消
					</button>
					<button id="clearAllProxiesConfirmBtn" class="btn btn-danger">
						确认清空
					</button>
				</div>
			</div>
		</div>
		
		
		
		<!-- 多选操作栏 -->
		<div id="multi-select-bar">
			<button class="action-btn cancel-btn" id="cancel-select-btn" title="取消">
				<i class="fa fa-times">
				</i>
			</button>
			<div id="selected-count">
				未选择项目
			</div>
			<div class="action-buttons">
				<button class="action-btn delete-btn" id="delete-btn" title="删除" disabled>
					<i class="fa-regular fa-trash-can"></i>
				</button>
				
				<button class="action-btn" id="download-btn" title="下载" disabled>
					<i class="fa-regular fa-circle-down"></i>
				</button>
				<button class="action-btn" id="invert-select-btn" title="反选" disabled>
					<i class="fa-solid fa-repeat"></i>
				</button>
				<button class="action-btn" id="select-all-btn" title="全选">
					<i class="fa-regular fa-square-minus">
					</i>
				</button>
			</div>
		</div>
		<!-- API状态侧边栏 -->
<div id="apiStatusOverlay" class="api-status-overlay hidden"></div>
<div id="apiStatusPanel" class="api-status-panel">
    <div class.api-status-header">

    <!-- 头部操作按钮 -->
    <div class="api-status-header-actions">
        <h5>数据监控 仪表盘</h5>
        <!-- 刷新按钮 -->
        <button id="refreshApiStatusBtn" class="btn-icon-sm" title="刷新">
            <i class="fa fa-refresh"></i>
        </button>
        <!-- 关闭按钮 -->
        <button id="closeApiStatusPanel" class="btn-icon-sm" title="关闭">
            <i class="fa fa-times"></i>
        </button>
    </div>
</div>


    <div id="apiStatusContent" class="api-status-content"> 
        <!-- 内容动态生成 -->
        <div class="loading-spinner" style="height: auto; padding: 2rem 0;">
            <div class="spinner">
            </div>
        </div>
    </div>
    
</div>
		<!-- 右键菜单设置弹窗 -->
<div id="contextMenuSettingsModal" class="modal-overlay hidden">
    <div class="modal-form-container">
        <h3>
            <span class="modal-title-text">长按菜单项设置</span>
            <button class="btn-icon-sm" id="contextMenuSettingsCloseBtn" title="关闭"><i class="fa fa-times"></i></button>
        </h3>
        <p style="font-size:0.7rem; margin-top:-0.4rem; margin-bottom:0.4rem;">选择在长按时希望看到的快捷操作</p>
        <div class="context-menu-settings-tabs">
        <button class="tab-btn  active" data-tab="file">文件</button>
        <button class="tab-btn" data-tab="folder">文件夹</button>
            <button class="tab-btn" data-tab="repo">仓库</button>
            
            
        </div>
        <div id="contextMenuSettingsContent">
            <!-- 设置项动态生成 -->
        </div>
    </div>
</div>


<!-- 隐藏的头像上传输入框 -->
    <input type="file" id="avatarUploadInput" class="hidden" accept="image/*">
    
    <div id="editorScaleHint" class="hidden">双指缩放来调整大小</div>
    
    
    
    
    <!-- [添加] 账号管理模态框 -->
<div id="accountManagerModal" class="modal-overlay hidden">
    <div class="modal-form-container">
        <h3>
            <span class="modal-title-text">账号管理</span>
            <button class="btn-icon-sm" id="closeAccountManagerModalBtn" title="关闭"><i class="fa fa-times"></i></button>
        </h3>
        
        <!-- 这个容器用于动态显示已保存的账号列表 -->
        <div id="accountListContainer" class="scmz">
            <!-- 账号列表项会由 JavaScript 动态生成并插入到这里 -->
        </div>

        <!-- 当没有保存任何账号时，显示此提示信息 -->
        <div id="accountListEmpty" class="empty-state hidden">
            <i class="fa fa-key"></i>
            <p>您还没有保存任何账号</p>
        </div>

        <!-- 弹窗底部的按钮区域 -->
        <div class="modal-buttons">
            <button id="showAddAccountModalBtn" class="btn btn-primary">
                <i class="fa fa-plus-circle"></i> 添加新账号
            </button>
        </div>
    </div>
</div>




<!-- ====================================================== -->
<!--              添加与编辑账号的弹窗 (模态框)              -->
<!-- ====================================================== -->
<div id="addEditAccountModal" class="modal-overlay hidden">
    <div class="modal-form-container">
        <h3 id="addEditAccountTitle">
            <span class="modal-title-text">添加新账号</span>
            <button class="btn-icon-sm" id="closeAddEditAccountModalBtn" title="关闭"><i class="fa fa-times"></i></button>
        </h3>
        
        <!-- 输入框：用于设置账号的自定义名称 -->
        <input id="accountNameInput" type="text" placeholder="设置一个名称" autocomplete="off">
        
        <!-- 输入框：用于粘贴用户的 GitHub 访问令牌 -->
        <input id="accountTokenInput" type="text" placeholder="粘贴你的GitHub访问令牌" autocomplete="off">
        
        <!-- 用于显示错误信息的容器 -->
        <div id="addEditAccountError" class="text-red-400"></div>
        
        <!-- 弹窗底部的按钮区域 -->
        <div class="modal-buttons">
            <button id="addEditAccountCancelBtn" class="btn btn-cancel">取消</button>
            <button id="addEditAccountSaveBtn" class="btn btn-primary" disabled>
                <span>保存</span><i class="fa fa-spinner fa-spin hidden"></i>
            </button>
        </div>
    </div>
</div>


<!-- 网站发布管理弹窗 -->
<div id="publishManagerModal" class="modal-overlay hidden">
    <div class="modal-form-container">
       <h3>
    <span class="modal-title-text">网站管理</span>
    <div style="display: flex; align-items: center;">
        <button class="btn-icon-sm" id="showPublishHelpBtn" title="帮助说明" style="margin-right: 0.5rem;"><i class="fa fa-question-circle"></i></button>
        <button class="btn-icon-sm" id="closePublishManagerBtn" title="关闭"><i class="fa fa-times"></i></button>
    </div>
</h3>
        
        <div id="publishManageList" class="publish-list">
            <!-- 统一的仓库列表将在这里生成 -->
        </div>

        <div class="modal-buttons">
                    <div class="modal-buttons publish-manager-tabs">
            <button id="officialConfigTabBtn" class="btn btn-tab active">
                官方配置
            </button>
            <button id="customDomainTabBtn" class="btn btn-tab">
                 自定义域名
            </button>
        </div>
        </div>
    </div>
</div>


<!-- 删除确认弹窗 -->
			<div id="deleteModal" class="modal-overlay hidden">
				<div class="modal-form-container">
					<h3 id="deleteTitle">
						<span class="modal-title-text">
							确认删除
						</span>
						<button class="btn-icon-sm" onclick="hideDeleteModal()"
						title="关闭">
							<i class="fa fa-times">
							</i>
						</button>
					</h3>
					<p id="deleteDesc">
					</p>
					<div class="modal-buttons">
						<button id="deleteCancel" class="btn btn-cancel">
							取消
						</button>
						<button id="deleteConfirm" class="btn btn-danger">
							确认删除
						</button>
					</div>
				</div>
			</div>
			
			<!-- 配置自定义域名弹窗 -->
<div id="customDomainModal" class="modal-overlay hidden">
    <div class="modal-form-container">
        <h3>
            <span class="modal-title-text">配置自定义域名</span>
            <button class="btn-icon-sm" id="closeCustomDomainModalBtn" title="关闭"><i class="fa fa-times"></i></button>
        </h3>
        <p id="customDomainRepoName" style="font-size: 0.8rem; color: #a2a7c7; margin-bottom: 0.8rem;"></p>
        <input id="customDomainInput" type="text" placeholder="例如: 123.baidu.com" autocomplete="off">
        <div id="customDomainError" class="text-red-400" style="font-size: 0.75rem; margin-top: -0.4rem; margin-bottom: 0.4rem; display: none;"></div>
        <div class="modal-buttons">
            <button id="customDomainCancelBtn" class="btn btn-cancel">取消</button>
            <button id="customDomainSaveBtn" class="btn btn-primary" disabled>
                <span>确认</span><i class="fa fa-spinner fa-spin hidden"></i>
            </button>
        </div>
    </div>
</div>



<!-- ====================================================== -->
<!--                  网站部署 - 帮助说明模态框             -->
<!-- ====================================================== -->
<div id="publishHelpModal" class="modal-overlay hidden">
    <div class="publish-help-dialog">
        <div class="publish-help-header">
            <h3><i class="fa-solid fa-circle-info"></i> 网站部署功能指南</h3>
            <button class="btn-icon-sm" id="closePublishHelpBtn" title="关闭"><i class="fa fa-times"></i></button>
        </div>
        <div class="publish-help-content scmz">
        <p style="color:red;">
            主站和项目网站类别，只能一类配置自定义域名，否则网站会无法访问。你的用户名.github.io，这是主站。如果有其他项目网站已经发布，就取消掉再进行操作，反之同理。
            
            </p>
           
            <h4><i class="fa-solid fa-bolt"></i> 功能解释</h4>
            <p>
                此功能利用 GitHub Pages 服务，将您的仓库一键发布为可公开访问的静态网站。
            </p>
            <ul>
                <li><b>官方配置：</b>管理所有公开仓库的发布状态。您可以将任何公开仓库发布为项目网站，或将特定仓库设置为您的个人主站，并使用官方的域名进行访问。<code>你可以在这个面板里点击仓库名来复制链接，自定义域名同理</code></li>
                <li><b>自定义域名：</b>为您已发布的网站绑定您自己的域名，让访问更专业、更便捷。</li>
            </ul>

            <h4><i class="fa-solid fa-link"></i> 域名解析指南</h4>
            <p>
                要将您的域名指向 GitHub Pages 网站，您需要到您的域名提供商（如阿里云、腾讯云、GoDaddy等）的后台添加 DNS 解析记录。
            </p>
            
            
            <ul>
               
                <li><b>记录类型：</b>选择 <code>CNAME</code></li>
                <li><b>主机记录：</b>通常填 <code>www</code> 或您想使用的子域名（例如 <code>blog</code>)  示例：<code>blog.baidu.com</code></li>
                <li>
                    <b>记录值 (指向)：</b>
                    <ul style="margin-top:0.4rem;">
                        <li>(例如 <code>你的用户名+.github+.io</code>)，示例：<code>rjdsq.github.io</code></li>
                        
                    </ul>
                </li>
            </ul>
            <p style="margin-top:0.8rem;">
                解析设置成功后，一般需要几分钟到几小时才能全球生效。
            </p>

<p style="color:red;">
            然后必须在cloudflare官网，添加你的域名，不然无法访问，成功添加域名后，他会提示你后续操作，不用理会，已经成功了。主要用处就是让域名能访问你的网站，并且自动添加代理，别人访问时候不会被墙。
            
            </p>
           
            <ul>
            <li><b>配置地址：</b><code style="user-select: text;">https://dash.cloudflare.com</code> <br><li><b>推荐添加顶级域名</b> 示例：<code>baidu.com</code></li><li>后续如果你添加，<code>blog.baidu.com</code>之类的就不用再添加域名</li></li>
            </ul>
            
            <h4><i class="fa-solid fa-triangle-exclamation"></i> 注意事项</h4>
            <ul>
                <li>只有<b>公开 (Public)</b> 仓库才能被发布为网站。</li>
                <li><b>主站：</b>一个 GitHub 账号只能有一个主站，其仓库名必须是 <code>您的GitHub用户名.github.io</code>。设为主站操作会自动为您重命名仓库。</li>
                <li><b>取消发布：</b>对于项目网站，此操作会禁用其 GitHub Pages 功能；对于主站，为了安全，会将其重命名为一个备份名称来使其下线。</li>
                <li><b>自定义域名：</b>配置成功后，会在您的仓库根目录下创建一个名为 <code>CNAME</code> 的文件，请勿随意删除。</li>
                <li><b>主站按钮：</b>将此仓库设置为<code>用户名.github.io</code></li>
                <li><b>发布按钮：</b>发布项目为<code>用户名.github.io/仓库名</code></li>
                
            </ul>
        </div>
    </div>
</div>


<script>
let imageObserver = null;
const CURRENT_VERSION = "3.7";
document.documentElement.style.userSelect = 'none';
const toastQueue = [];
let isToastVisible = false;
let modalLastTapTime = 0;
let modalLastTappedRepoId = null;
let currentFetchController = null;
let isContextMenuClosing = false;
const PROXY_TEST_URL = 'https://raw.githubusercontent.com/rjdsq/rjdsq.github.io/main/github/代理.txt';
const IMAGE_EXTS = ['png', 'jpg', 'jpeg', 'gif', 'webp', 'bmp', 'svg'];
const VIDEO_EXTS = ['mp4', 'webm', 'ogg', 'mov', 'avi', 'mkv'];
const AUDIO_EXTS = ['mp3', 'wav', 'ogg', 'flac', 'm4a'];
const ZIP_EXTS = ['zip',];
const uiStateStack = [];

const state = {
    accounts: JSON.parse(localStorage.getItem('github_accounts') || '[]'),
    activeAccountId: localStorage.getItem('active_github_account_id') || null,
    token: null,
    localAvatar: null,
    
    currentRepo: null,
    currentPath: '',
    currentBranch: null,
    branches: [],
    files: [],
    displayFiles: [],
    repos: [],
    selectedFile: null,
    selectedRepo: null,
    uploadQueue: [],
lastTestResult: null,
lastTestUrl: null,
    editingFile: null,
    fileSha: '',
        publishManagerActiveTab: 'official',
    configuringDomainRepoFullName: null,
    
    originalContent: '',
    proxies: JSON.parse(localStorage.getItem('proxies') || '[]'),
    activeProxyIndex: parseInt(localStorage.getItem('active_proxy_index') || '0'),
    proxyGlobalEnable: JSON.parse(localStorage.getItem('proxy_global_enable') || 'true'),
    autoSelectProxy: JSON.parse(localStorage.getItem('proxy_auto_select') || 'false'),
    editingProxyIndex: null,
    user: null,
    fileCache: new Map(),
    viewMode: localStorage.getItem('view_mode') || 'list',
    sortBy: localStorage.getItem('sort_by') || 'name_asc',
    directorySortPriority: localStorage.getItem('directory_sort_priority') || 'dirs_first',
    searchQuery: '',
    editorContainer: document.querySelector('.editor-container'),
    isMultiSelectMode: false,
    selectedItems: new Set(),
    contextMenuVisibility: {},
    shouldAnimateList: true,
    editorSearchState: {
    query: '',
    matches: [],
    currentIndex: -1
},

editorSearchState: {
        query: '',
        matches: [],
        currentIndex: -1
    },
    pullToRefresh: {
        active: false,
        startY: 0,
        pullDistance: 0,
        threshold: 60, // 触发刷新的下拉距离
        el: null,
        indicator: null
    }
};

if (state.proxies.length === 0) {
    state.activeProxyIndex = -1;
} else if (state.activeProxyIndex < 0 || state.activeProxyIndex >= state.proxies.length) {
    state.activeProxyIndex = 0;
}


initializeActiveToken(); 
const CONTEXT_MENU_DEFINITIONS = {
    repo: [
    { action: 'togglePin', icon: 'fa-thumbtack', text: '置顶/取消' },
    { action: 'renameRepo', icon: 'fa-pencil', text: '仓库设置' },
    { action: 'createBranch', icon: 'fa-code-fork', text: '分支管理' },
    { action: 'downloadRepoDirect', icon: 'fa-regular fa-circle-down', text: '代理下载' },
    { action: 'copyMainSiteLink', icon: 'fa-link', text: '主站链接' },
    { action: 'copyProjectSiteLink', icon: 'fa-link', text: '网站链接' },
    { action: 'copyCustomDomainLink', icon: 'fa-link', text: '域名链接' },
    { action: 'copyRepoGitHubLink', icon: 'fa-link', text: '仓库链接' },
    
    { action: 'deleteRepo', icon: 'fa-trash', text: '删除', className: 'text-red-400' }
],
    
    folder: [{ action: 'copyPagesLink', icon: 'fa-globe', text: '网站链接' },{ action: 'copyGitHubLink', icon: 'fa-link', text: '仓库链接' },{ action: 'rename', icon: 'fa-pencil', text: '重命名' },{ action: 'downloadFolder', icon: 'fa-regular fa-circle-down', text: '下载 ZIP' },{ action: 'delete', icon: 'fa-trash', text: '删除', className: 'text-red-400' }],
    file: [{ action: 'edit', icon: 'fa-edit', text: '编辑' },{ action: 'rename', icon: 'fa-pencil', text: '重命名' },{ action: 'download', icon: 'fa-download', text: '代理下载' },{ action: 'copyPagesLink', icon: 'fa-link', text: '网站链接' },{ action: 'copyCustomDomainLink', icon: 'fa-link', text: '域名链接' },{ action: 'copyGitHubLink', icon: 'fa-link', text: '仓库链接' },{ action: 'copyLink', icon: 'fa-link', text: '复制raw链接' },{ action: 'copyProxy', icon: 'fa-link', text: '复制代理链接' },{ action: 'unzip', icon: 'fa-regular fa-circle-down', text: '解压缩(仅ZIP)' },{ action: 'delete', icon: 'fa-trash', text: '删除', className: 'text-red-400' }]
};

const DEFAULT_MENU_VISIBILITY = {
    repo: CONTEXT_MENU_DEFINITIONS.repo.reduce((acc, item) => ({ ...acc, [item.action]: true }), {}),
    folder: CONTEXT_MENU_DEFINITIONS.folder.reduce((acc, item) => ({ ...acc, [item.action]: true }), {}),
    file: CONTEXT_MENU_DEFINITIONS.file.reduce((acc, item) => ({ ...acc, [item.action]: true }), {})
};

const el = {

main: document.querySelector('main'), 
    authScreen: document.getElementById('authScreen'),
    app: document.getElementById('app'),
    tokenInput: document.getElementById('tokenInput'),
    authBtn: document.getElementById('authBtn'),
    fileList: document.getElementById('fileList'),
    repoList: document.getElementById('repoList'),
    pathNav: document.getElementById('pathNav'),
    pathNavContainer: document.getElementById('pathNavContainer'),
    currentRepo: document.getElementById('currentRepo'),
    branchSwitcherContainer: document.getElementById('branchSwitcherContainer'),
    backBtn: document.getElementById('backBtn'),
    newFolderBtn: document.getElementById('newFolderBtn'),
    uploadBtn: document.getElementById('uploadBtn'),
    modalOverlay: document.getElementById('modalOverlay'),
    modalContent: document.getElementById('modalContent'),
    contextMenu: document.getElementById('contextMenu'),
    contextMenuItems: document.getElementById('contextMenuItems'),
    toast: document.getElementById('toast'),
    toastMessage: document.getElementById('toastMessage'),
    uploadPanel: document.getElementById('uploadPanel'),
    uploadItems: document.getElementById('uploadItems'),
    editModal: document.getElementById('editModal'),
    editFileName: document.getElementById('editFileName'),
    fileContent: document.getElementById('fileContent'),
    closeEditModal: document.getElementById('closeEditModal'),
    cancelEdit: document.getElementById('cancelEdit'),
    saveEdit: document.getElementById('saveEdit'),
    editStatus: document.getElementById('editStatus'),
    editorOverlay: document.getElementById('editorOverlay'),
    saveNotification: document.getElementById('saveNotification'),
    setAsSiteModal: document.getElementById('setAsSiteModal'),
setAsSiteCloseBtn: document.getElementById('setAsSiteCloseBtn'),
setAsSiteCancelBtn: document.getElementById('setAsSiteCancelBtn'),
setAsSiteConfirmBtn: document.getElementById('setAsSiteConfirmBtn'),
    fileUploadInput: document.getElementById('fileUploadInput'),
    mainLoader: document.getElementById('mainLoader'),
    mainMenuPopup: document.getElementById('mainMenuPopup'),
    menuLogout: document.getElementById('menuLogout'),
    menuProxySettings: document.getElementById('menuProxySettings'),
    proxyTestAllBoltIcon: document.querySelector('#proxyTestAllBtn > i'),
    menuClearCache: document.getElementById('menuClearCache'),
    menuBatchPublishSites: document.getElementById('menuBatchPublishSites'),
    newFileBtn: document.getElementById('newFileBtn'),
    mainMenuBtn: document.getElementById('mainMenuBtn'),
     publishManageList: document.getElementById('publishManageList'),
       customDomainTabBtn: document.getElementById('customDomainTabBtn'),

    customDomainModal: document.getElementById('customDomainModal'),
    closeCustomDomainModalBtn: document.getElementById('closeCustomDomainModalBtn'),
    customDomainRepoName: document.getElementById('customDomainRepoName'),
    customDomainInput: document.getElementById('customDomainInput'),
    customDomainError: document.getElementById('customDomainError'),
    customDomainCancelBtn: document.getElementById('customDomainCancelBtn'),
    customDomainSaveBtn: document.getElementById('customDomainSaveBtn'),

    customDomainTabBtn: document.getElementById('customDomainTabBtn'),
    toolbar: document.getElementById('toolbar'),
    searchInput: document.getElementById('searchInput'),
    viewToggleBtn: document.getElementById('viewToggleBtn'),
    proxyQuickToggle: document.getElementById('proxyQuickToggle'),
    proxySettingsModal: document.getElementById('proxySettingsModal'),
    proxyAutoSelectToggle: document.getElementById('proxyAutoSelectToggle'),
    userName: document.getElementById('userName'),
    importBtn: document.getElementById('importBtn'),
    proxyGlobalEnableToggle: document.getElementById('proxyGlobalEnableToggle'),
    proxyAddBtn: document.getElementById('proxyAddBtn'),
    proxyListContainer: document.getElementById('proxyListContainer'),
    proxyListEmpty: document.getElementById('proxyListEmpty'),
    proxyTestAllBtn: document.getElementById('proxyTestAllBtn'),
    proxyTestAllSpinner: document.getElementById('proxyTestAllSpinner'),
    proxyClearAllBtn: document.getElementById('proxyClearAllBtn'),
    proxyCancelSettingsBtn: document.getElementById('proxyCancelSettingsBtn'),
    addEditProxyModal: document.getElementById('addEditProxyModal'),
    addEditProxyTitle: document.getElementById('addEditProxyTitle'),
    addEditProxyUrlInput: document.getElementById('addEditProxyUrlInput'),
    addEditProxyError: document.getElementById('addEditProxyError'),
    addEditProxySaveBtn: document.getElementById('addEditProxySaveBtn'),
    confirmDeleteProxyModal: document.getElementById('confirmDeleteProxyModal'),
    confirmDeleteProxyTitle: document.getElementById('confirmDeleteProxyTitle'),
        importSpinner: document.getElementById('importSpinner'),
    confirmDeleteProxyMessage: document.getElementById('confirmDeleteProxyMessage'),
    confirmDeleteProxyCancelBtn: document.getElementById('confirmDeleteProxyCancelBtn'),
    confirmDeleteProxyConfirmBtn: document.getElementById('confirmDeleteProxyConfirmBtn'),
    confirmClearAllProxiesModal: document.getElementById('confirmClearAllProxiesModal'),
    clearAllProxiesCancelBtn: document.getElementById('clearAllProxiesCancelBtn'),
    clearAllProxiesConfirmBtn: document.getElementById('clearAllProxiesConfirmBtn'),
    renameModal: document.getElementById('renameModal'),
    renameTitle: document.getElementById('renameTitle'),
    renameInput: document.getElementById('renameInput'),
    renameWarn: document.getElementById('renameWarn'),
    renameCancel: document.getElementById('renameCancel'),
    renameConfirm: document.getElementById('renameConfirm'),
    renameBranchBtn: document.getElementById('renameBranchBtn'),
    deleteModal: document.getElementById('deleteModal'),
    deleteTitle: document.getElementById('deleteTitle'),
    deleteDesc: document.getElementById('deleteDesc'),
    deleteCancel: document.getElementById('deleteCancel'),
    deleteConfirm: document.getElementById('deleteConfirm'),
    createRepoModal: document.getElementById('createRepoModal'),
    createRepoNameInput: document.getElementById('createRepoNameInput'),
    createRepoDescInput: document.getElementById('createRepoDescInput'),
    createRepoPrivate: document.getElementById('createRepoPrivate'),
    repoNameError: document.getElementById('repoNameError'),
    createRepoCancel: document.getElementById('createRepoCancel'),
    createRepoConfirm: document.getElementById('createRepoConfirm'),
    createFolderModal: document.getElementById('createFolderModal'),
    createFolderInput: document.getElementById('createFolderInput'),
    createFolderCancel: document.getElementById('createFolderCancel'),
    createFolderConfirm: document.getElementById('createFolderConfirm'),
    createFileModal: document.getElementById('createFileModal'),
    createFileNameInput: document.getElementById('createFileNameInput'),
    createFileContentInput: document.getElementById('createFileContentInput'),
    createFileCancel: document.getElementById('createFileCancel'),
    createFileConfirm: document.getElementById('createFileConfirm'),
    createBranchModal: document.getElementById('createBranchModal'),
    createBranchNameInput: document.getElementById('createBranchNameInput'),
    createBranchCancel: document.getElementById('createBranchCancel'),
    createBranchConfirm: document.getElementById('createBranchConfirm'),
    deleteBranchBtn: document.getElementById('deleteBranchBtn'),
    searchToggleBtn: document.getElementById('searchToggleBtn'),
    sortToggleBtn: document.getElementById('sortToggleBtn'),
    customSortDropdown: document.getElementById('customSortDropdown'),
    avatarContainer: document.getElementById('avatarContainer'),
    avatarUploadInput: document.getElementById('avatarUploadInput'),
    userAvatar: document.getElementById('userAvatar'),
    userAvatarPlaceholder: document.getElementById('userAvatarPlaceholder'),
    multiSelectToggleBtn: document.getElementById('multiSelectToggleBtn'),
    multiSelectBar: document.getElementById('multi-select-bar'),
    cancelSelectBtn: document.getElementById('cancel-select-btn'),
    selectAllBtn: document.getElementById('select-all-btn'),
    invertSelectBtn: document.getElementById('invert-select-btn'),
    downloadBtn: document.getElementById('download-btn'),
    deleteBtn: document.getElementById('delete-btn'),
    selectedCountSpan: document.getElementById('selected-count'),
    menuContextMenuSettings: document.getElementById('menuContextMenuSettings'),
    contextMenuSettingsModal: document.getElementById('contextMenuSettingsModal'),
    contextMenuSettingsCloseBtn: document.getElementById('contextMenuSettingsCloseBtn'),
    contextMenuSettingsContent: document.getElementById('contextMenuSettingsContent'),
    currentRepo: document.getElementById('currentRepo'),
    apiStatusPanel: document.getElementById('apiStatusPanel'),
    apiStatusOverlay: document.getElementById('apiStatusOverlay'),
    apiStatusContent: document.getElementById('apiStatusContent'),
    closeApiStatusPanel: document.getElementById('closeApiStatusPanel'),
    refreshApiStatusBtn: document.getElementById('refreshApiStatusBtn'),
    revertEditBtn: document.getElementById('revertEditBtn'),
    editorScaleHint: document.getElementById('editorScaleHint'),
    searchInFileBtn: document.getElementById('searchInFileBtn'),
editorSearchPanel: document.getElementById('editorSearchPanel'),
editorSearchInput: document.getElementById('editorSearchInput'),
editorSearchMatchCount: document.getElementById('editorSearchMatchCount'),
editorSearchPrevBtn: document.getElementById('editorSearchPrevBtn'),
editorSearchNextBtn: document.getElementById('editorSearchNextBtn'),
editorSearchCloseBtn: document.getElementById('editorSearchCloseBtn'),
    manageAccountsBtn: document.getElementById('manageAccountsBtn'),
    menuSwitchAccount: document.getElementById('menuSwitchAccount'),
    accountManagerModal: document.getElementById('accountManagerModal'),
    closeAccountManagerModalBtn: document.getElementById('closeAccountManagerModalBtn'),
    accountListContainer: document.getElementById('accountListContainer'),
    accountListEmpty: document.getElementById('accountListEmpty'),
    showAddAccountModalBtn: document.getElementById('showAddAccountModalBtn'),
    addEditAccountModal: document.getElementById('addEditAccountModal'),
    addEditAccountTitle: document.getElementById('addEditAccountTitle'),
    closeAddEditAccountModalBtn: document.getElementById('closeAddEditAccountModalBtn'),
    accountNameInput: document.getElementById('accountNameInput'),
    accountTokenInput: document.getElementById('accountTokenInput'),
    addEditAccountError: document.getElementById('addEditAccountError'),
    addEditAccountCancelBtn: document.getElementById('addEditAccountCancelBtn'),
    addEditAccountSaveBtn: document.getElementById('addEditAccountSaveBtn'),
    menuThemeToggle: document.getElementById('menuThemeToggle'),
    publishManagerModal: document.getElementById('publishManagerModal'),
    closePublishManagerBtn: document.getElementById('closePublishManagerBtn'),
    publishManageList: document.getElementById('publishManageList'),
    officialConfigTabBtn: document.getElementById('officialConfigTabBtn'),
    showPublishHelpBtn: document.getElementById('showPublishHelpBtn'),
    publishHelpModal: document.getElementById('publishHelpModal'),
    closePublishHelpBtn: document.getElementById('closePublishHelpBtn')
    
};

function handleBackPress() {
    if (uiStateStack.length > 0) {
        const closeFunction = uiStateStack.pop();
        if (typeof closeFunction === 'function') {
            closeFunction();
        }
        history.pushState(history.state, '', window.location.href);
        return true;
    }
    return false;
}

const themeManager = {
    apply(theme) {
        const themeToggle = document.getElementById('menuThemeToggle');
        if (!themeToggle) return;
        const icon = themeToggle.querySelector('i');
        
        document.documentElement.classList.remove('light-theme-loading');

        if (theme === 'light') {
            document.body.classList.add('light-theme');
            if (icon) icon.className = 'fa-regular fa-moon';
        } else {
            document.body.classList.remove('light-theme');
            if (icon) icon.className = 'fa-regular fa-cloud';
        }
    },
    toggle() {
        const currentTheme = document.body.classList.contains('light-theme') ? 'light' : 'dark';
        const newTheme = currentTheme === 'light' ? 'dark' : 'light';
        this.apply(newTheme);
        try {
            localStorage.setItem('app_theme', newTheme);
        } catch (e) {
            console.error('无法保存主题设置:', e);
        }
    },
    init() {
        try {
            const savedTheme = localStorage.getItem('app_theme') || 'light';
            this.apply(savedTheme);
        } catch (e) {
            console.error('无法加载主题设置:', e);
            this.apply('light');
        }
    }
};

function initializeActiveToken() {
    state.token = null; 
    if (state.activeAccountId && state.accounts.length > 0) {
        const activeAccount = state.accounts.find(acc => acc.id === state.activeAccountId);
        if (activeAccount) {
            state.token = activeAccount.token;
        } else {

            state.activeAccountId = null;
            localStorage.removeItem('active_github_account_id');
        }
    }
}



function showAccountManagerModal() {
    renderAccountList();
    el.accountManagerModal.classList.remove('hidden');
    uiStateStack.push(closeAccountManagerModal);
}

function closeAccountManagerModal() {
    el.accountManagerModal.classList.add('hidden');
    const index = uiStateStack.indexOf(closeAccountManagerModal);
    if (index > -1) uiStateStack.splice(index, 1);
}


function showAddEditAccountModal(accountId = null) {
    editingAccountId = accountId;
    const title = el.addEditAccountTitle.querySelector('.modal-title-text');
    const saveBtn = el.addEditAccountSaveBtn;

    el.addEditAccountError.style.display = 'none';
    saveBtn.disabled = true;

    if (accountId) { 
        
        const account = state.accounts.find(acc => acc.id === accountId);
        title.textContent = '编辑账号'; 
        el.accountNameInput.style.display = 'block'; 
        el.accountNameInput.value = account.name;
        el.accountTokenInput.value = account.token; 

    } else { 
        
        title.textContent = '添加新账号';
        el.accountNameInput.style.display = 'none'; 
        el.accountNameInput.value = '';
        el.accountTokenInput.value = '';
    }
    
    el.addEditAccountModal.classList.remove('hidden');
    uiStateStack.push(closeAddEditAccountModal);
}

function closeAddEditAccountModal() {
    el.addEditAccountModal.classList.add('hidden');
    const index = uiStateStack.indexOf(closeAddEditAccountModal);
    if (index > -1) uiStateStack.splice(index, 1);
}


async function handleSaveAccount() {
    const name = el.accountNameInput.value.trim(); 
    const token = el.accountTokenInput.value.trim();
    const saveBtn = el.addEditAccountSaveBtn;
    const spinner = saveBtn.querySelector('i');
    
    saveBtn.disabled = true;
    spinner.classList.remove('hidden');
    el.addEditAccountError.style.display = 'none';

    try {
        if (editingAccountId) {
            
            const account = state.accounts.find(acc => acc.id === editingAccountId);
            
            if (token !== account.token) {
                
                const res = await fetch('https://api.github.com/user', { headers: { Authorization: `token ${token}` } });
                if (!res.ok) throw new Error('新令牌无效或已过期');
                
                
                account.token = token;
            }
            
            account.name = name; 
            saveAccounts();

            if (state.activeAccountId === editingAccountId) {
                initializeActiveToken();
            }

            renderAccountList();
            closeAddEditAccountModal();
            showToast('账号信息已更新');

        } else {
            
            const res = await fetch('https://api.github.com/user', { headers: { Authorization: `token ${token}` } });
            if (!res.ok) throw new Error('令牌无效或已过期');
            
            const userData = await res.json(); 
            const githubUsername = userData.login; 

            const newAccount = {
                id: `gh_${Date.now()}`,
                name: githubUsername, 
                token: token
            };
            state.accounts.push(newAccount);
            saveAccounts();
            renderAccountList();
            closeAddEditAccountModal();
            showToast(`账号 "${githubUsername}" 添加成功`);
        }
    } catch (error) {
        el.addEditAccountError.textContent = error.message;
        el.addEditAccountError.style.display = 'block';
    } finally {
        saveBtn.disabled = false;
        spinner.classList.add('hidden');
    }
}

function getFileIcon(filename) {
    const ext = filename.split('.').pop().toLowerCase();
    const icons = {
    js: 'fa-solid fa-code', html: 'fa-brands fa-html5', css: 'fa-brands fa-css3', php: 'fa-regular fa-file-code', py: 'fa-regular fa-file-code',
    java: 'fa-regular fa-file-code', rb: 'fa-regular fa-file-code', cpp: 'fa-regular fa-file-code', c: 'fa-regular fa-file-code',
    cs: 'fa-regular fa-file-code', swift: 'fa-regular fa-file-code', go: 'fa-regular fa-file-code', xml: 'fa-regular fa-file-code',
    json: 'fa-regular fa-file-code', yml: 'fa-regular fa-file-code', yaml: 'fa-regular fa-file-code', sql: 'fa-solid fa-database',
    csv: 'fa-regular fa-file-excel', ini: 'fa-solid fa-gear', conf: 'fa-solid fa-gear', log: 'fa-regular fa-file-lines',
    md: 'fa-regular fa-file-lines', txt: 'fa-regular fa-file-lines', rtf: 'fa-regular fa-file-word', pdf: 'fa-regular fa-file-pdf',
    doc: 'fa-regular fa-file-word', docx: 'fa-regular fa-file-word', xls: 'fa-regular fa-file-excel', xlsx: 'fa-regular fa-file-excel',
    ppt: 'fa-regular fa-file-powerpoint', pptx: 'fa-regular fa-file-powerpoint', png: 'fa-regular fa-file-image',
    jpg: 'fa-regular fa-file-image', jpeg: 'fa-regular fa-file-image', gif: 'fa-regular fa-file-image', svg: 'fa-regular fa-file-image',
    bmp: 'fa-regular fa-file-image', ico: 'fa-regular fa-file-image', webp: 'fa-regular fa-file-image', mp3: 'fa-regular fa-file-audio',
    wav: 'fa-regular fa-file-audio', ogg: 'fa-regular fa-file-audio', flac: 'fa-regular fa-file-audio', m4a: 'fa-regular fa-file-audio',
    mp4: 'fa-regular fa-file-video', webm: 'fa-regular fa-file-video', mov: 'fa-regular fa-file-video', mkv: 'fa-regular fa-file-video',
    avi: 'fa-regular fa-file-video', flv: 'fa-regular fa-file-video', zip: 'fa-regular fa-file-zipper', rar: 'fa-regular fa-file-zipper',
    '7z': 'fa-regular fa-file-zipper', tar: 'fa-regular fa-file-zipper', gz: 'fa-regular fa-file-zipper', git: 'fa-brands fa-git-alt',
    apk: 'fa-brands fa-android', exe: 'fa-solid fa-gears', dmg: 'fa-brands fa-apple', ttf: 'fa-solid fa-font', otf: 'fa-solid fa-font',
    woff: 'fa-solid fa-font', woff2: 'fa-solid fa-font'
}
    return icons[ext] || 'fa-file';
}


function getFileCategory(file) {
    if (file.type === 'dir') {
        return 'folder';
    }
    const ext = file.name.split('.').pop().toLowerCase();
    if (IMAGE_EXTS.includes(ext)) {
        return 'image';
    }
    if (VIDEO_EXTS.includes(ext)) {
        return 'video';
    }
    if (AUDIO_EXTS.includes(ext)) {
        return 'audio';
    }
    const archiveExts = ['zip', 'rar', '7z', 'tar', 'gz'];
    if (archiveExts.includes(ext)) {
        return 'archive';
    }
    const docExts = ['pdf', 'doc', 'docx', 'xls', 'xlsx', 'ppt', 'pptx', 'txt', 'md'];
    if (docExts.includes(ext)) {
        return 'document';
    }
    return 'z_other';
}

function formatSize(bytes) {
    if (!bytes && bytes !== 0) return '';
    const k = 1024;
    const sizes = ['B', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.max(0, Math.log(bytes || 1) / Math.log(k)));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

function formatRelativeTime(date) {
    const diffMs = new Date() - date;
    const diffMins = Math.floor(diffMs / 60000);
    const diffHours = Math.floor(diffMins / 60);
    const diffDays = Math.floor(diffHours / 24);
    if (diffMins < 1) return '刚刚';
    if (diffMins < 60) return `${diffMins}分钟前`;
    if (diffHours < 24) return `${diffHours}小时前`;
    if (diffDays < 30) return `${diffDays}天前`;
    return date.toLocaleDateString();
}

function escapeHtml(unsafe) {
    return unsafe.replace(/&/g, "&amp;").replace(/</g, "&lt;")
        .replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
}

function getDomainFromUrl(url) {
    try {
        const urlObj = new URL(url.startsWith('http') ? url : `https://${url}`);
        return urlObj.hostname;
    } catch (e) {
        return '';
    }
}

function getProxiedUrl(originalUrl) {
    if (!state.proxyGlobalEnable || state.proxies.length === 0 || state.activeProxyIndex === -1) {
        return originalUrl;
    }
    const activeProxy = state.proxies[state.activeProxyIndex];
    if (!activeProxy || !activeProxy.url || activeProxy.status === 'fail' || !activeProxy.type) {
        return originalUrl;
    }
    const isRawGitHubUserContent = originalUrl.startsWith('https://raw.githubusercontent.com/');
    if (!isRawGitHubUserContent) {
        return originalUrl;
    }
    let proxiedUrl = originalUrl;
    const proxyInputUrl = (activeProxy.url || '').trim();
    const proxyDomain = getDomainFromUrl(proxyInputUrl);
    if (activeProxy.type === 'prefix') {
        let base = proxyInputUrl;
        if (!base.endsWith('/')) {
            base += '/';
        }
        proxiedUrl = base + originalUrl;
    } else if (activeProxy.type === 'raw_domain_replace') {
        proxiedUrl = originalUrl.replace(/^(https?:\/\/raw\.)githubusercontent\.com(\/.*)$/i, `$1${proxyDomain}$2`);
        if (!proxiedUrl.startsWith('http')) {
            proxiedUrl = 'https://' + proxiedUrl;
        }
    } else {
        proxiedUrl = originalUrl;
    }
    return proxiedUrl;
}

function applyFiltersAndSort() {
    let arr = Array.isArray(state.files) ? [...state.files] : [];
    const q = (state.searchQuery || '').toLowerCase();
    if (q) {
        arr = arr.filter(f => (f.name || '').toLowerCase().includes(q));
    }
    const getSortableExtension = (file) => {
        if (file.type === 'dir') return '!';
        const parts = file.name.split('.');
        if (parts.length > 1 && parts[0] !== '') {
            return parts.pop().toLowerCase();
        }
        return ' ';
    };
    const directorySorter = (a, b) => {
        if (a.type === b.type) return 0;
        if (state.directorySortPriority === 'files_first') {
            return a.type === 'file' ? -1 : 1;
        }
        return a.type === 'dir' ? -1 : 1;
    };
    const by = state.sortBy;
    const sorters = {
    name_asc: (a, b) => {
        const dirCompare = directorySorter(a, b);
        return dirCompare !== 0 ? dirCompare : a.name.localeCompare(b.name);
    },
    name_desc: (a, b) => {
        const dirCompare = directorySorter(a, b);
        return dirCompare !== 0 ? dirCompare : b.name.localeCompare(a.name);
    },
    size_desc: (a, b) => {
        const dirCompare = directorySorter(a, b);
        if (dirCompare !== 0) return dirCompare;
        return (b.size || 0) - (a.size || 0);
    },
    size_asc: (a, b) => {
        const dirCompare = directorySorter(a, b);
        if (dirCompare !== 0) return dirCompare;
        return (a.size || 0) - (b.size || 0);
    },
    type_name_asc: (a, b) => {
        const dirCompare = directorySorter(a, b);
        if (dirCompare !== 0) return dirCompare;
        const categoryA = getFileCategory(a);
        const categoryB = getFileCategory(b);
        if (categoryA !== categoryB) {
            return categoryA.localeCompare(categoryB);
        }
        return a.name.localeCompare(b.name);
    }
};
    (sorters[by] || sorters.name_asc) && arr.sort(sorters[by]);
    state.displayFiles = arr;
}




let editingAccountId = null; 

function saveAccounts() {
    localStorage.setItem('github_accounts', JSON.stringify(state.accounts));
}

function setActiveAccount(accountId) {
    state.activeAccountId = accountId;
    localStorage.setItem('active_github_account_id', accountId);
    initializeActiveToken(); 
}

function renderAccountList() {
    const container = el.accountListContainer;
    container.innerHTML = '';

    if (state.accounts.length === 0) {
        el.accountListEmpty.classList.remove('hidden');
        return;
    }
    el.accountListEmpty.classList.add('hidden');

    state.accounts.forEach(account => {
        const item = document.createElement('div');
        item.className = 'account-item';
        item.dataset.id = account.id;
        if (account.id === state.activeAccountId) {
            item.classList.add('active');
        }

        item.innerHTML = `
            <span class="account-name">${escapeHtml(account.name)}</span>
            <div class="account-actions">
                <button class="btn-icon-sm edit-account-btn" title="编辑名称"><i class="fa fa-pencil"></i></button>
                <button class="btn-icon-sm delete-account-btn danger" title="删除账号"><i class="fa-regular fa-trash-can"></i></button>
            </div>
        `;

        
        item.addEventListener('click', () => {
    if (el.app.classList.contains('hidden')) {
        const selectedToken = state.accounts.find(acc => acc.id === account.id).token;
        if (selectedToken) {
            el.tokenInput.value = selectedToken;
            showToast(`已选择账号: ${account.name}，正在自动登录...`);
            closeAccountManagerModal();
            el.authBtn.click();
        }
    } else {
        if (account.id === state.activeAccountId) {
            closeAccountManagerModal();
            return;
        }
        switchAccount(account.id);
    }
});
        
        item.querySelector('.edit-account-btn').addEventListener('click', (e) => {
            e.stopPropagation();
            showAddEditAccountModal(account.id);
        });

        item.querySelector('.delete-account-btn').addEventListener('click', (e) => {
            e.stopPropagation();
            showDeleteModal(null, false, '确认删除账号', `确定要删除账号 "${escapeHtml(account.name)}" 吗？`, async () => {
                state.accounts = state.accounts.filter(acc => acc.id !== account.id);
                if (state.activeAccountId === account.id) {
                    setActiveAccount(null); 
                }
                saveAccounts();
                renderAccountList();
                showToast('账号已删除');
            });
        });

        container.appendChild(item);
    });
}

async function switchAccount(accountId) {
    closeAccountManagerModal();
    hideMainMenuPopup();
    el.mainLoader.classList.remove('hidden');
    showToast('正在切换账号...');

    setActiveAccount(accountId);

    state.currentRepo = null;
    state.repos = [];
    state.fileCache.clear();

    try {
        state.shouldAnimateList = true;
        await Promise.all([
            fetchUserInfo(),
            fetchRepos(true)
        ]);
        showRepoListView(); 
    } catch (error) {
        showToast(`切换失败: ${error.message}`);
        showAuth(); 
    } finally {
        el.mainLoader.classList.add('hidden');
        renderPublishManagerLists();
    }
}

function updateFileListViewMode() {
    if (!el.fileList) return;
    if (state.viewMode === 'grid') {
        el.fileList.classList.add('grid');
        el.viewToggleBtn && el.viewToggleBtn.classList.add('active');
        if (el.viewToggleBtn) {
            el.viewToggleBtn.title = '切换为列表视图';
            el.viewToggleBtn.innerHTML = '<i class="fa fa-align-justify"></i>';
        }
    } else {
        el.fileList.classList.remove('grid');
        el.viewToggleBtn && el.viewToggleBtn.classList.remove('active');
        if (el.viewToggleBtn) {
            el.viewToggleBtn.title = '切换为网格视图';
            el.viewToggleBtn.innerHTML = '<i class="fa-regular fa-chart-bar"></i>';
        }
    }
}



function updateAllProxySwitchUI() {
    const isEnabled = !!state.proxyGlobalEnable;
    const currentProxy = state.proxies[state.activeProxyIndex];
    const title = isEnabled && currentProxy ? `代理已开启 (${currentProxy.url})` : '代理已关闭';
    if (el.proxyQuickToggle) {
        el.proxyQuickToggle.classList.toggle('active', isEnabled);
        el.proxyQuickToggle.title = title;
    }
    if (el.proxyGlobalEnableToggle) {
        el.proxyGlobalEnableToggle.checked = isEnabled;
        const label = el.proxyGlobalEnableToggle.parentElement;
        if (label) {
            label.title = isEnabled ? '点击关闭全局代理' : '点击开启全局代理';
        }
    }
}

function updateProxyUI() {
    updateAllProxySwitchUI();
}

async function setProxyGlobalState(isEnabled, shouldRefreshFiles = false) {
    if (state.proxyGlobalEnable === isEnabled) {
        return;
    }
    state.proxyGlobalEnable = isEnabled;
    localStorage.setItem('proxy_global_enable', JSON.stringify(isEnabled));
    updateAllProxySwitchUI();
    showToast(isEnabled ? '全局代理已开启' : '全局代理已关闭');
    if (shouldRefreshFiles && state.currentRepo && !el.fileList.classList.contains('hidden')) {
        el.fileList.innerHTML = '<div class="loading-spinner"><div class="spinner"></div></div>';
        await fetchFiles(true);
    }
}

function toggleView(showRepoList) {
    if (showRepoList) {
        el.main.classList.remove('has-toolbar'); 
        el.repoList.classList.remove('hidden');
        el.fileList.classList.add('hidden');
        el.toolbar.classList.add('hidden');
        el.pathNavContainer.classList.add('hidden');
        el.branchSwitcherContainer.classList.add('hidden');
        el.currentRepo.textContent = '选择仓库';
        el.newFolderBtn.title = '新建仓库';
        el.newFolderBtn.innerHTML = '<i class="fa-regular fa-folder-open"></i>';
    } else {
        el.main.classList.add('has-toolbar'); 
        el.repoList.classList.add('hidden');
        el.fileList.classList.remove('hidden');
        el.toolbar.classList.remove('hidden');
        el.pathNavContainer.classList.remove('hidden');
        el.branchSwitcherContainer.classList.remove('hidden');
        el.newFolderBtn.title = '新建文件夹';
        el.newFolderBtn.innerHTML = '<i class="fa-regular fa-folder"></i>';
        updateFileListViewMode();
    }
}

function showAuth() {
    el.authScreen.classList.remove('hidden');
    el.app.classList.add('hidden');
    document.documentElement.classList.remove('app-visible-loading');
    document.documentElement.classList.add('auth-visible-loading');
}

function showApp() {
    el.authScreen.classList.add('hidden');
    el.app.classList.remove('hidden');
    document.documentElement.classList.remove('auth-visible-loading');
    document.documentElement.classList.add('app-visible-loading');
    document.body.classList.remove('app-visible-loading');
}

function showEditorScaleHintOnce() {
    const hintKey = 'editor_scale_hint_shown';
    try {
        if (localStorage.getItem(hintKey)) {
            return;
        }
        const hintElement = el.editorScaleHint;
        if (!hintElement) {
            return;
        }
        
        hintElement.classList.remove('hidden');
        
        setTimeout(() => {
            hintElement.style.transition = 'opacity 0.5s ease-out';
            hintElement.style.opacity = '0';
            setTimeout(() => {
                hintElement.classList.add('hidden');
                hintElement.style.opacity = '';
                hintElement.style.transition = '';
            }, 500);
        }, 3000);

        localStorage.setItem(hintKey, 'true');
    } catch (e) {
        console.error("Could not show editor scale hint:", e);
    }
}


function showToast(message, type = 'info', duration = 1800) {
    toastQueue.push({ message, type, duration });
    processToastQueue();
}

function processToastQueue() {
    if (isToastVisible || toastQueue.length === 0) {
        return;
    }
    isToastVisible = true;
    const { message, type, duration } = toastQueue.shift();
    
    const toastEl = document.getElementById('toast');
    const messageEl = document.getElementById('toastMessage');

    toastEl.className = '';

    messageEl.innerHTML = message.replace(/\n/g, '<br>');
    toastEl.classList.add(`toast-${type}`);

    toastEl.classList.add('show');

    setTimeout(() => {
        toastEl.classList.remove('show');
        setTimeout(() => {
            isToastVisible = false;
            processToastQueue();
        }, 400);
    }, duration);
}

function showSaveNotification() {
    el.saveNotification.classList.add('show');
    setTimeout(() => el.saveNotification.classList.remove('show'), 3000);
}

async function fetchUserInfo() {
    try {
        const res = await fetch('https://api.github.com/user', {
            headers: {
                Authorization: `token ${state.token}`,
                'User-Agent': 'Mozilla/5.0'
            }
        });
        if (res.ok) {
            state.user = await res.json();
            updateUserUI();
        }
    } catch (e) {
        console.error("Failed to fetch user info", e);
    }
}

function updateUserUI() {
    if (state.localAvatar) {
        el.userAvatar.src = state.localAvatar;
        el.userAvatar.classList.remove('hidden');
        el.userAvatarPlaceholder.classList.add('hidden');
        el.userName.textContent = state.user ? state.user.login : 'User';
    }
    else if (state.user && state.user.avatar_url) {
        el.userName.textContent = state.user.login;
        el.userAvatar.src = state.user.avatar_url;
        el.userAvatar.classList.remove('hidden');
        el.userAvatarPlaceholder.classList.add('hidden');
    }
    else {
        el.userName.textContent = 'User';
        el.userAvatar.classList.add('hidden');
        el.userAvatarPlaceholder.classList.remove('hidden');
    }
}


async function fetchRepos(forceRefresh = false, updateView = true) {
    const cacheKey = 'cached_repos';
    const cacheTimeKey = 'repos_cache_time';
    const CACHE_LIFETIME = 5 * 60 * 1000; 

    if (!forceRefresh && localStorage.getItem(cacheKey) && (Date.now() - parseInt(localStorage.getItem(cacheTimeKey)) < CACHE_LIFETIME)) {
        try {
            state.repos = JSON.parse(localStorage.getItem(cacheKey));
            if (updateView) {
                renderRepoList();
                showRepoListView();
            }
            return;
        } catch (e) {
            console.error('缓存数据解析失败，将从网络获取:', e);
        }
    }

    const MAX_RETRIES = 2;
    const RETRY_DELAY = 1000;
    let lastError = null;

    for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
        try {
            const res = await fetch('https://api.github.com/user/repos?timestamp=' + Date.now(), {
                headers: { Authorization: `token ${state.token}`, 'User-Agent': 'Mozilla/5.0' },
                cache: 'no-store'
            });

            if (!res.ok) {
                let errorMsg = `获取仓库失败 (HTTP ${res.status})`;
                if (res.status === 401) errorMsg = '令牌无效或已过期，请重新登录。';
                if (res.status === 403) errorMsg = 'API请求频率超限，请稍后再试。';
                throw new Error(errorMsg);
            }

            const repos = await res.json();
            state.repos = repos;
            localStorage.setItem(cacheKey, JSON.stringify(state.repos));
            localStorage.setItem(cacheTimeKey, Date.now().toString());
            
            if (updateView) {
                renderRepoList();
                showRepoListView();
            }
            return; 
        } catch (err) {
            lastError = err;
            if (attempt < MAX_RETRIES) {
                await new Promise(res => setTimeout(res, RETRY_DELAY));
            }
        }
    }

    if (localStorage.getItem(cacheKey)) {
        if (updateView) showToast('网络请求失败，已加载本地缓存数据。');
        try {
            state.repos = JSON.parse(localStorage.getItem(cacheKey));
        } catch (e) {
            state.repos = [];
        }
    } else {
        if (updateView) showToast(`加载仓库失败: ${lastError.message}`);
        state.repos = [];
    }
    
    if (updateView) {
        renderRepoList();
        showRepoListView();
    }
}

function invalidateCacheForPathAndParents(path) {
    if (typeof path !== 'string') return;
    let currentPath = path;
    while (true) {
        const cacheKey = `${state.currentRepo}:${state.currentBranch}:${currentPath}`;
        state.fileCache.delete(cacheKey);
        if (currentPath === '') {
            break;
        }
        let tempPath = currentPath.endsWith('/') ? currentPath.slice(0, -1) : currentPath;
        let lastSlashIndex = tempPath.lastIndexOf('/');
        if (lastSlashIndex === -1) {
            currentPath = '';
        } else {
            currentPath = tempPath.substring(0, lastSlashIndex) + '/';
        }
    }
}

function renderRepoList() {
    const pinnedRepoIds = JSON.parse(localStorage.getItem('pinned_repos') || '[]');

    let mainSiteRepo = null;
    if (state.user && state.user.login) {
        const mainSiteName = `${state.user.login}.github.io`;
        mainSiteRepo = state.repos.find(repo => repo.name === mainSiteName);
    }
    
    const allRepos = [...state.repos];
    
    const pinnedRepos = allRepos
        .filter(r => pinnedRepoIds.includes(r.id))
        .sort((a, b) => new Date(b.updated_at) - new Date(a.updated_at));
        
    const unpinnedRepos = allRepos
        .filter(r => !pinnedRepoIds.includes(r.id))
        .sort((a, b) => new Date(b.updated_at) - new Date(a.updated_at));

    const reposToRender = [...pinnedRepos, ...unpinnedRepos];

    el.repoList.innerHTML = reposToRender.length === 0 ? '<div class="empty-state"><i class="fa-brands fa-github"></i><p>没有找到仓库</p></div>' : '';
    
    reposToRender.forEach((repo, index) => {
        const isMainSiteRepo = mainSiteRepo && repo.id === mainSiteRepo.id;
        const item = document.createElement('div');
        item.className = 'file-item';

        if (state.shouldAnimateList) {
            item.classList.add('file-item-enter');
            item.style.animationDelay = `${index * 30}ms`;
        } else {
            item.style.opacity = 1;
        }

        const mainSiteBadge = '';
        const pinIconHTML = '';

        item.innerHTML = `
            <div class="file-icon"><i class="fa-brands fa-github"></i></div>
            <div class="file-info">
                <p class="file-name">${pinIconHTML}${repo.name} ${mainSiteBadge}</p>
                <p class="file-meta">
                    ${repo.private ? '私有仓库' : '公开仓库'} ${repo.size || repo.updated_at ? ' · ' : ''}
                    ${repo.size ? formatSize(repo.size * 1024) : ''}
                    ${repo.size && repo.updated_at ? ' · ' : ''}
                    ${formatRelativeTime(new Date(repo.updated_at))}
                </p>
                <p class="file-meta">${repo.description || ''}</p>
            </div>
        `;
        let pressTimer = null;
        let isLongPress = false;
        item.addEventListener('touchstart', (e) => {
            isLongPress = false;
            pressTimer = setTimeout(() => {
                isLongPress = true;
            }, 500);
        }, { passive: true });
        item.addEventListener('touchmove', () => {
            clearTimeout(pressTimer);
        });
        item.addEventListener('touchend', () => {
            clearTimeout(pressTimer);
        });
        item.addEventListener('click', async (e) => {
    if (isLongPress) return;

    state.shouldAnimateList = true;

    try {
        const lastBranch = localStorage.getItem(`last_branch_${repo.full_name}`);
        const branchToLoad = lastBranch || repo.default_branch;
        const newState = { repo: repo.full_name, path: '', branch: branchToLoad };
        history.pushState(newState, '', `#/${repo.full_name}`);

        state.currentRepo = repo.full_name;
        state.currentPath = '';
        state.currentBranch = branchToLoad;
        el.currentRepo.textContent = repo.name;

        toggleView(false);
        el.fileList.innerHTML = '<div class="loading-spinner"><div class="spinner"></div></div>';
        renderPathNav();

        await Promise.all([
            fetchBranches(repo),
            fetchFiles()
        ]);
        
        renderBranchSwitcher();

    } catch (error) {
        showToast('加载仓库失败');
        console.error(error);
        showRepoListView(); 
    }
});
        item.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            clearTimeout(pressTimer);
            isLongPress = true;
            state.selectedRepo = repo;
            showRepoContextMenu(e, repo);
        });
        el.repoList.appendChild(item);
    });

    if (state.shouldAnimateList) {
        state.shouldAnimateList = false;
    }
}



function showRepoListView() {
state.shouldAnimateList = true; 
    el.repoList.classList.remove('hidden');
    el.fileList.classList.add('hidden');
    el.pathNavContainer.classList.add('hidden');
    el.branchSwitcherContainer.classList.add('hidden');
    el.currentRepo.textContent = '选择仓库';
    toggleView(true);
    state.currentRepo = null;
    state.currentPath = '';
    state.currentBranch = null;
    state.branches = [];
}

async function fetchBranches(repo) {
    try {
        const res = await fetch(`https://api.github.com/repos/${repo.full_name}/branches`, {
            headers: {
                Authorization: `token ${state.token}`,
                'User-Agent': 'Mozilla/5.0'
            }
        });
        if (res.ok) {
            state.branches = await res.json();
            state.branches.reverse();
        } else {
            state.branches = [];
            showToast('获取分支列表失败');
        }
    } catch (e) {
        state.branches = [];
        showToast('获取分支列表失败');
        console.error(e);
    }
}

function renderBranchSwitcher() {
    const container = el.branchSwitcherContainer;
    container.innerHTML = '';
    if (!state.branches || state.branches.length === 0) {
        container.classList.add('hidden');
        return;
    }
    const wrapper = document.createElement('div');
    wrapper.className = 'custom-branch-select-wrapper';
    const trigger = document.createElement('button');
    trigger.className = 'custom-branch-select-trigger';
    trigger.innerHTML = `
        <span>${escapeHtml(state.currentBranch)}</span>
        <i class="fa fa-chevron-down"></i>
    `;
    const optionsPanel = document.createElement('div');
    optionsPanel.className = 'custom-branch-select-options';
    state.branches.forEach(branch => {
        const option = document.createElement('div');
        option.className = 'custom-branch-select-option';
        if (branch.name === state.currentBranch) {
            option.classList.add('selected');
        }
        option.textContent = branch.name;
        option.dataset.branchName = branch.name;
        option.addEventListener('click', () => {
            const selectedBranch = option.dataset.branchName;
            if (selectedBranch === state.currentBranch) {
                wrapper.classList.remove('open');
                return;
            }
            state.shouldAnimateList = true;
            const previouslySelected = optionsPanel.querySelector('.custom-branch-select-option.selected');
            if (previouslySelected) {
                previouslySelected.classList.remove('selected');
            }
            option.classList.add('selected');
            state.currentBranch = selectedBranch;
            state.currentPath = '';
            localStorage.setItem(`last_branch_${state.currentRepo}`, state.currentBranch);
            el.fileList.innerHTML = '<div class="loading-spinner"><div class="spinner"></div></div>';
            const newState = { repo: state.currentRepo, path: '', branch: state.currentBranch };
            history.replaceState(newState, '', `#/${state.currentRepo}/`);
            renderPathNav();
            fetchFiles(true);
            trigger.querySelector('span').textContent = selectedBranch;
            wrapper.classList.remove('open');
        });
        optionsPanel.appendChild(option);
    });
    wrapper.appendChild(trigger);
    wrapper.appendChild(optionsPanel);
    container.appendChild(wrapper);
    container.classList.remove('hidden');
    trigger.addEventListener('click', (e) => {
        e.stopPropagation();
        wrapper.classList.toggle('open');
    });
    document.addEventListener('click', (e) => {
        if (!wrapper.contains(e.target)) {
            wrapper.classList.remove('open');
        }
    });
}

async function fetchFiles(forceRefresh = false, showLoader = true) {
    if (!state.currentRepo || !state.currentBranch) return;

    const pathForFetch = state.currentPath;
    const cacheKey = `${state.currentRepo}:${state.currentBranch}:${pathForFetch}`;
    
    if (!forceRefresh && state.fileCache.has(cacheKey)) {
        state.files = state.fileCache.get(cacheKey);
        applyFiltersAndSort();
        renderFileList();
        return;
    }
    
    if (showLoader) {
        el.fileList.innerHTML = '<div class="loading-spinner"><div class="spinner"></div></div>';
    }
    await fetchFilesFromNetwork(true, pathForFetch);
}
async function fetchFilesFromNetwork(isInitialLoad = false, pathForFetch) {
    try {
        const timestamp = Date.now();
        const url = `https://api.github.com/repos/${state.currentRepo}/contents/${pathForFetch}?ref=${state.currentBranch}&t=${timestamp}`;
        const res = await fetch(url, {
            headers: {
                Authorization: `token ${state.token}`,
                'User-Agent': 'Mozilla/5.0'
            },
            cache: 'no-store'
        });

        if (!res.ok) {
            if (res.status === 404) {
                if (pathForFetch === state.currentPath) {
                    state.files = [];
                    applyFiltersAndSort();
                    renderFileList();
                }
                return;
            }
            throw new Error('加载文件失败');
        }

        const data = await res.json();
        if (data.message) throw new Error(data.message);

        let fetchedFiles = Array.isArray(data) ? data : [];
        
        const filesWithImageState = fetchedFiles.map(file => {
            const isImage = IMAGE_EXTS.includes(file.name.split('.').pop()?.toLowerCase());
            if (isImage) {
                return { ...file, isImageLoaded: false };
            }
            return file;
        });

        fetchedFiles = filesWithImageState;
        fetchedFiles.sort((a, b) => a.type === 'dir' && b.type !== 'dir' ? -1 : a.type !== 'dir' && b.type === 'dir' ? 1 : a.name.localeCompare(b.name));
        
        const cacheKey = `${state.currentRepo}:${state.currentBranch}:${pathForFetch}`;
        state.fileCache.set(cacheKey, [...fetchedFiles]);

        if (pathForFetch === state.currentPath) {
            state.files = fetchedFiles;
            applyFiltersAndSort();
            
            if (isInitialLoad) {
                state.shouldAnimateList = true;
            } else {
                state.shouldAnimateList = false;
            }
            renderFileList();
        }

    } catch (err) {
        if (err.name === 'AbortError') {
            return;
        }
        if (pathForFetch === state.currentPath) {
            showToast('加载文件失败: ' + err.message);
        }
        console.error(err);
    }
}


function renderFileList() {
    const list = (state.displayFiles && state.displayFiles.length >= 0) ? state.displayFiles : state.files;
    const fragment = document.createDocumentFragment();
    const imageExtensions = ['png', 'jpg', 'jpeg', 'gif', 'webp', 'bmp', 'svg'];
    const isGridView = state.viewMode === 'grid';
    if (!list || list.length === 0) {
        const emptyState = document.createElement('div');
        emptyState.className = 'empty-state';
        const emptyMessage = state.currentPath ? '文件夹为空' : '此分支为空';
        emptyState.innerHTML = `<i class="fa-brands fa-github"></i><p>${emptyMessage}</p>`;
        fragment.appendChild(emptyState);
    } else {
        list.forEach((file, index) => {
            const isDir = file.type === 'dir';
            const icon = isDir ? 'fa-folder' : getFileIcon(file.name);
            const item = document.createElement('div');
            const fileExtension = file.name.split('.').pop()?.toLowerCase();
            const isImage = !isDir && imageExtensions.includes(fileExtension);
            item.className = 'file-item';
            
            if (state.shouldAnimateList) {
                item.classList.add('file-item-enter');
                item.style.animationDelay = `${index * 30}ms`;
            } else {
                item.style.opacity = 1;
            }
            
            if (state.selectedItems.has(file.path)) {
                item.classList.add('selected');
            }
            if (isGridView && isImage) {
                item.classList.add('is-image-grid');
            }
            const checkboxHTML = `
                <div class="select-checkbox-wrapper">
                    <div class="select-checkbox-bg"></div>
                    <i class="fa fa-check"></i>
                </div>
            `;
            let innerHTML = '';
            const fileMetaHTML = `
                <p class="file-meta">
                    ${isDir ? '文件夹' : formatSize(file.size)}
                    ${(isDir || file.size) && file.last_modified ? ' · ' : ''}
                    ${file.last_modified ? formatRelativeTime(new Date(file.last_modified)) : ''}
                </p>
            `;
            if (isGridView) {
                let gridContentHTML = '';
                if (isImage) {
                    const rawUrl = file.download_url || file.html_url.replace('github.com', 'raw.githubusercontent.com').replace('/blob/', '/');
                    const imageUrl = getProxiedUrl(rawUrl);
                    gridContentHTML = `
                        <div class="file-thumbnail-container loading" data-image-url="${escapeHtml(imageUrl)}" data-image-name="${escapeHtml(file.name)}">
                             <i class="fa fa-spinner fa-spin thumbnail-loader-icon"></i>
                             <div class="thumbnail-error retry-trigger" title="点击重试"><i class="fa fa-repeat"></i></div>
                        </div>
                        <div class="file-info">
                            <p class="file-name">${escapeHtml(file.name)}</p>
                            ${fileMetaHTML}
                        </div>
                    `;
                } else {
                    gridContentHTML = `
                        <div class="file-icon"><i class="fa ${icon}"></i></div>
                        <div class="file-info">
                            <p class="file-name">${escapeHtml(file.name)}</p>
                            ${fileMetaHTML}
                        </div>
                    `;
                }
                innerHTML = checkboxHTML + gridContentHTML;
            } else {
                let listContentHTML = '';
                if (isImage) {
                     const rawUrl = file.download_url || file.html_url.replace('github.com', 'raw.githubusercontent.com').replace('/blob/', '/');
                     const imageUrl = getProxiedUrl(rawUrl);
                     listContentHTML = `
                        <div class="file-thumbnail-container loading" data-image-url="${escapeHtml(imageUrl)}" data-image-name="${escapeHtml(file.name)}">
                           <i class="fa fa-spinner fa-spin thumbnail-loader-icon"></i>
                           <div class="thumbnail-error retry-trigger" title="点击重试"><i class="fa fa-repeat"></i></div>
                        </div>
                     `;
                } else {
                    listContentHTML = `<div class="file-icon"><i class="fa ${icon}"></i></div>`;
                }
                listContentHTML += `
                    <div class="file-info">
                        <p class="file-name">${escapeHtml(file.name)}</p>
                        ${fileMetaHTML}
                    </div>
                `;
                innerHTML = checkboxHTML + listContentHTML;
            }
            item.innerHTML = innerHTML;
            let pressTimer = null;
            let isLongPress = false;
            item.addEventListener('touchstart', (e) => {
                isLongPress = false;
                pressTimer = setTimeout(() => { isLongPress = true; }, 500);
            }, { passive: true });
            item.addEventListener('touchmove', () => { clearTimeout(pressTimer); });
            item.addEventListener('touchend', () => { clearTimeout(pressTimer); });
            
            
            item.addEventListener('click', (e) => {
                const retryTrigger = e.target.closest('.retry-trigger');
                if (retryTrigger) {
                    e.stopPropagation(); 
                    const allFailedContainers = document.querySelectorAll('#fileList .file-thumbnail-container.error');
                    
                    if (allFailedContainers.length > 0) {
                        showToast(`正在重试 ${allFailedContainers.length} 个失败的图片...`);
                        
                        
                        allFailedContainers.forEach(container => {
                            container.classList.remove('error');
                            container.classList.add('loading');
                            loadThumbnailImage(container);
                            
                        });
                    }
                    return; 
                }

                if (isLongPress) return;

                if (state.isMultiSelectMode) {
                    item.classList.toggle('selected');
                    if (state.selectedItems.has(file.path)) {
                        state.selectedItems.delete(file.path);
                    } else {
                        state.selectedItems.add(file.path);
                    }
                    updateActionBar();
                } else {
                    if (isDir) {
                        navigateToDir(file.name);
                    } else {
                        const isMedia = IMAGE_EXTS.includes(fileExtension) || VIDEO_EXTS.includes(fileExtension) || AUDIO_EXTS.includes(fileExtension);
                        if (!isMedia) {
                           editFile(file);
                        }
                    }
                }
            });

            item.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                clearTimeout(pressTimer);
                isLongPress = true;
                showContextMenu(e, file);
            });
            fragment.appendChild(item);
        });
    }
    el.fileList.innerHTML = '';
    el.fileList.appendChild(fragment);
    updateActionBar();
    processImagePlaceholders();
    
    if (state.shouldAnimateList) {
        state.shouldAnimateList = false;
    }
}
function loadThumbnailImage(container) {
    const imageUrl = container.dataset.imageUrl;
    const imageName = container.dataset.imageName;
    if (!imageUrl) return;

    const oldImg = container.querySelector('.file-thumbnail');
    if (oldImg) {
        oldImg.remove();
    }

    const img = new Image();
    img.className = 'file-thumbnail';

    const lastDotIndex = imageName.lastIndexOf('.');
    const nameWithoutExt = lastDotIndex > 0 ? imageName.substring(0, lastDotIndex) : imageName;
    img.alt = nameWithoutExt;
    
    img.onload = () => {
        container.appendChild(img);
        container.classList.remove('loading');
        container.classList.add('loaded');
        
        const fileItemEl = container.closest('.file-item');
        if (fileItemEl && fileItemEl.dataset.filePath) {
            const filePath = fileItemEl.dataset.filePath;
            const fileInState = state.files.find(f => f.path === filePath);
            if (fileInState) {
                fileInState.isImageLoaded = true;
            }
        }
    };
    
    img.onerror = () => {
        console.error('图片加载失败:', imageUrl);
        container.classList.remove('loading'); 
        container.classList.add('error');
    };
    
    img.src = imageUrl;
}

function processImagePlaceholders() {
    const placeholders = document.querySelectorAll('.file-thumbnail-container.loading');
    placeholders.forEach(container => {
        loadThumbnailImage(container);
    });
}

function renderPathNav() {
    el.pathNav.innerHTML = '';
    const rootItem = document.createElement('span');
    rootItem.className = 'path-item root';
    rootItem.innerHTML = '<i title="返回仓库根目录"></i>';
    rootItem.dataset.path = '';
    rootItem.addEventListener('click', () => {
        navigateToPath('');
    });
    el.pathNav.appendChild(rootItem);
    const parts = state.currentPath.split('/').filter(p => p);
    let currentPath = '';
    parts.forEach(part => {
        const separator = document.createElement('span');
        separator.className = 'path-separator';
        separator.textContent = '/';
        el.pathNav.appendChild(separator);
        currentPath += part + '/';
        const item = document.createElement('span');
        item.className = 'path-item';
        item.textContent = part;
        item.dataset.path = currentPath;
        item.addEventListener('click', () => {
            navigateToPath(item.dataset.path);
        });
        el.pathNav.appendChild(item);
    });
}

function navigateToDir(dirName) {
    const newPath = state.currentPath ? `${state.currentPath}${dirName}/` : `${dirName}/`;
    navigateToPath(newPath);
}

function navigateToPath(path) {
state.shouldAnimateList = true; 
    state.currentPath = path;
    const newState = {
        repo: state.currentRepo,
        path: path,
        branch: state.currentBranch
    };
    history.pushState(newState, '', `#/${state.currentRepo}/${path}`);
    fetchFiles();
    renderPathNav();
}

function updateSortDropdownUI() {
    const dropdown = el.customSortDropdown;
    if (!dropdown) return;
    Array.from(dropdown.children).forEach(item => {
        const value = item.dataset.value;
        const priority = item.dataset.priority;
        if (value) {
            item.classList.toggle('selected', state.sortBy === value);
        }
        if (priority) {
            item.classList.toggle('active', state.directorySortPriority === priority);
        }
    });
}

function hideMainMenuPopup() {
    el.mainMenuPopup.classList.add('hidden');
    const index = uiStateStack.indexOf(hideMainMenuPopup);
    if (index > -1) uiStateStack.splice(index, 1);
}

function showMainMenuPopup() {
    el.mainMenuPopup.classList.remove('hidden');
    uiStateStack.push(hideMainMenuPopup);
}

function hideSortDropdown() {
    el.customSortDropdown.classList.add('hidden');
    const index = uiStateStack.indexOf(hideSortDropdown);
    if (index > -1) uiStateStack.splice(index, 1);
}

function showSortDropdown() {
    el.customSortDropdown.classList.remove('hidden');
    uiStateStack.push(hideSortDropdown);
}

function showEditModal() {
    el.editModal.classList.remove('hidden');
    el.editModal.classList.add('flex');
    el.editorOverlay.classList.add('show');
    setTimeout(adjustEditorDimensions, 10);
    uiStateStack.push(hideEditModal);
}

function hideEditModal() {
    toggleEditorSearch(false);
    el.editModal.classList.add('hidden');
    el.editModal.classList.remove('flex');
    state.editingFile = state.fileSha = state.originalContent = '';
    el.saveEdit.classList.remove('modified');
    const index = uiStateStack.indexOf(hideEditModal);
    if (index > -1) uiStateStack.splice(index, 1);
}

function showEditStatus(text, type) {
    el.editStatus.textContent = text;
    el.editStatus.className = `edit-status ${type}`;
}

function adjustEditorDimensions() {
    const viewportHeight = window.innerHeight;
    const targetEditorHeight = viewportHeight * 0.6;
    const modal = el.editModal.querySelector('.modal-content');
    const headerHeight = modal.querySelector('.modal-header').offsetHeight;
    const statusHeight = el.editStatus.offsetHeight;
    const footerHeight = modal.querySelector('.modal-footer').offsetHeight;
    const paddingOffset = 20;
    const otherElementsHeight = headerHeight + statusHeight + footerHeight + paddingOffset;
    modal.style.height = `${targetEditorHeight + otherElementsHeight}px`;
    el.fileContent.style.height = `${targetEditorHeight}px`;
}

async function editFile(file) {
    state.editingFile = file;
    el.editFileName.textContent = `${file.name}`;
    el.fileContent.value = '';
    showEditStatus('', '');

    try {
        const shouldBeMaximized = localStorage.getItem('editor-maximized') !== 'false';
        if (shouldBeMaximized) {
            el.editModal.classList.add('maximized');
            
            const maximizeButton = document.getElementById('toggleMaximizeModal');
            const icon = maximizeButton.querySelector('i');
            icon.classList.remove('fa-expand');
            icon.classList.add('fa-compress');
            maximizeButton.title = '恢复';
            
        }
    } catch(e) { console.error("无法应用最大化状态:", e); }

    showEditModal();

    const cacheKey = `edit_cache_${state.currentRepo}_${state.currentBranch}_${state.editingFile.path}`;
    const cachedItem = localStorage.getItem(cacheKey);
    if (cachedItem) {
        try {
            const parsedData = JSON.parse(cachedItem);
            if (Date.now() - parsedData.timestamp < 3 * 60 * 1000) {
                el.fileContent.value = parsedData.content;
                el.editorOverlay.classList.remove('show');
                fetch(`https://api.github.com/repos/${state.currentRepo.split('/')[0]}/${state.currentRepo.split('/')[1]}/contents/${file.path}?ref=${state.currentBranch}`, { headers: { 'Authorization': `token ${state.token}` } })
                    .then(res => res.json())
                    .then(data => {
                        state.originalContent = decodeURIComponent(escape(atob(data.content)));
                        state.fileSha = data.sha;
                        el.fileContent.oninput = checkContentChanges;
                        checkContentChanges();
                        showEditorScaleHintOnce();
                    });
                return;
            } else {
                localStorage.removeItem(cacheKey);
            }
        } catch (e) {
            localStorage.removeItem(cacheKey);
        }
    }
    try {
        const res = await fetch(`https://api.github.com/repos/${state.currentRepo.split('/')[0]}/${state.currentRepo.split('/')[1]}/contents/${file.path}?ref=${state.currentBranch}`, {
            headers: { 'Authorization': `token ${state.token}`, 'User-Agent': 'Mozilla/5.0' }
        });
        if (!res.ok) throw new Error((await res.json()).message || '加载文件失败');
        
        const data = await res.json();
        const content = decodeURIComponent(escape(atob(data.content)));
        
        el.fileContent.value = content;
        state.originalContent = content;
        state.fileSha = data.sha;
        el.editorOverlay.classList.remove('show');
        el.fileContent.oninput = checkContentChanges;
        checkContentChanges();
        showEditorScaleHintOnce();
    } catch (e) {
        el.editorOverlay.classList.remove('show');
        showEditStatus(`错误：${e.message}`, 'error');
    }
}

function checkContentChanges() {
    const isModified = el.fileContent.value !== state.originalContent;
    el.saveEdit.classList.toggle('modified', isModified);
    el.revertEditBtn.disabled = !isModified;
}

async function saveEditedFile() {
    if (!state.editingFile || !state.fileSha) return;
    const currentContent = el.fileContent.value;
    if (currentContent === state.originalContent) {
        showToast('未检测到修改');
        return;
    }
    el.editorOverlay.classList.add('show');
    el.saveEdit.classList.add('btn-processing');
    try {
        const [owner, repo] = state.currentRepo.split('/');
        const encodedContent = btoa(unescape(encodeURIComponent(currentContent)));
        const url = `https://api.github.com/repos/${owner}/${repo}/contents/${state.editingFile.path}`;
        const requestBody = {
            message: `Update ${state.editingFile.name} via web editor`,
            content: encodedContent,
            sha: state.fileSha,
            branch: state.currentBranch
        };
        const requestHeaders = {
            'Authorization': `token ${state.token}`,
            'Content-Type': 'application/json',
            'User-Agent': 'Mozilla/5.0'
        };
        let res = await fetch(url, {
            method: 'PUT',
            headers: requestHeaders,
            body: JSON.stringify(requestBody)
        });
        if (!res.ok) {
            if (res.status === 409) {
                const latestInfoRes = await fetch(url, { headers: { 'Authorization': `token ${state.token}`, 'User-Agent': 'Mozilla/5.0' } });
                if (!latestInfoRes.ok) throw new Error('获取最新文件版本失败');
                const latestInfo = await latestInfoRes.json();
                
                requestBody.sha = latestInfo.sha;
                res = await fetch(url, {
                    method: 'PUT',
                    headers: requestHeaders,
                    body: JSON.stringify(requestBody)
                });
                if (!res.ok) {
                    const err = await res.json();
                    throw new Error(`保存失败: ${err.message}`);
                }
            } else {
                const err = await res.json();
                throw new Error(`保存失败: ${err.message}`);
            }
        }
        const result = await res.json();
        state.fileSha = result.content.sha;
        state.originalContent = currentContent;
        const cacheKey = `edit_cache_${state.currentRepo}_${state.currentBranch}_${state.editingFile.path}`;
    const cacheData = {
        content: currentContent, 
        timestamp: Date.now()
    };
    localStorage.setItem(cacheKey, JSON.stringify(cacheData));
        el.editorOverlay.classList.remove('show');
        showToast('文件已保存');
        showSaveNotification();
        fetchFiles(true);
        checkContentChanges();
    } catch (e) {
        el.editorOverlay.classList.remove('show');
        showEditStatus(`错误：${e.message}`, 'error');
        console.error(e);
    } finally {
        el.saveEdit.classList.remove('btn-processing');
    }
}

async function downloadFile(item) {
    if (item.type === 'dir') return;
    try {
        showToast(`准备下载 ${item.name}`);
        const rawUrl = (item.download_url) ? item.download_url : item.html_url.replace('github.com', 'raw.githubusercontent.com').replace('/blob/', '/');
        const url = getProxiedUrl(rawUrl);
        const response = await fetch(url);
        if (!response.ok) throw new Error(`下载失败 (${response.status})`);
        const blob = await response.blob();
        const objectUrl = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = objectUrl;
        a.download = item.name;
        document.body.appendChild(a);
        a.click();
        setTimeout(() => {
            document.body.removeChild(a);
            URL.revokeObjectURL(objectUrl);
        }, 500);
        showToast(`开始下载 ${item.name}`);
    } catch (e) {
        showToast(`下载出错: ${e.message}`);
        console.error(e);
    }
}

function copyLink(file) {
    const rawUrl = file.download_url || file.html_url.replace('github.com', 'raw.githubusercontent.com').replace('/blob/', '/');
    navigator.clipboard.writeText(rawUrl).then(() => {
        showToast('Raw 链接已复制');
    }).catch(e => {
        showToast(`复制失败: ${e.message || '应用剪切板权限没给'}`);
        console.error(e);
    });
}

function copyProxyLink(file) {
    const rawUrl = file.download_url || file.html_url.replace('github.com', 'raw.githubusercontent.com').replace('/blob/', '/');
    const activeProxy = state.proxies[state.activeProxyIndex];
    if (state.proxyGlobalEnable && activeProxy && activeProxy.url && activeProxy.type) {
        let proxiedUrl = rawUrl;
        const proxyDomain = getDomainFromUrl(activeProxy.url);
        
        if (activeProxy.type === 'prefix') {
            let base = activeProxy.url;
            if (!base.endsWith('/')) {
                base += '/';
            }
            proxiedUrl = base + rawUrl;
        } else if (activeProxy.type === 'raw_domain_replace') {
            proxiedUrl = rawUrl.replace(/^(https?:\/\/raw\.)githubusercontent\.com(\/.*)$/i, `$1${proxyDomain}$2`);
            if (!proxiedUrl.startsWith('http')) {
                proxiedUrl = 'https://' + proxiedUrl;
            }
        }
        navigator.clipboard.writeText(proxiedUrl).then(() => {
            const displayUrl = activeProxy.url.replace(/^https?:\/\//, '').replace(/\/$/, '');
            showToast(`已复制当前代理链接 [${displayUrl}]`);
        }).catch(e => {
            showToast(`复制失败: ${e.message || '应用剪切板权限没给'}`);
            console.error(e);
        });
    } else {
        navigator.clipboard.writeText(rawUrl).then(() => {
            showToast('代理未开启，已复制直连 Raw 链接');
        }).catch(e => {
            showToast(`复制失败: ${e.message || '应用剪切板权限没给'}`);
            console.error(e);
        });
    }
}

function positionContextMenu(e, menuWidth, menuHeight) {
    let clickX, clickY;
    if (e.touches && e.touches.length > 0) {
        clickX = e.touches[0].clientX;
        clickY = e.touches[0].clientY;
    } else {
        clickX = e.clientX;
        clickY = e.clientY;
    }
    const offsetX = 30;
    const offsetY = 30;
    let leftPos = clickX + offsetX;
    let topPos = clickY + offsetY;
    const windowWidth = window.innerWidth;
    const windowHeight = window.innerHeight;
    if (leftPos + menuWidth > windowWidth) {
        leftPos = clickX - menuWidth - offsetX;
    }
    if (topPos + menuHeight > windowHeight) {
        topPos = clickY - menuHeight - offsetY;
    }
    if (leftPos < 0) leftPos = 5;
    if (topPos < 0) topPos = 5;
    return { top: topPos, left: leftPos };
}

function renderContextMenuItems(file) {
    el.contextMenuItems.innerHTML = '';
    const isDir = file.type === 'dir';
    const category = isDir ? 'folder' : 'file';
    const fileExtension = file.name.split('.').pop()?.toLowerCase();

    const currentRepoObject = state.repos.find(repo => repo.full_name === state.currentRepo);
    const isRepoPublished = currentRepoObject ? currentRepoObject.has_pages : false;
    const isMainSiteRepo = state.user && currentRepoObject && currentRepoObject.name === `${state.user.login}.github.io`;

    const visibleItems = CONTEXT_MENU_DEFINITIONS[category].filter(item => {
        if (item.action === 'unzip' && !ZIP_EXTS.includes(fileExtension)) {
            return false;
        }
        if (item.action === 'copyPagesLink' && !isRepoPublished && !isMainSiteRepo) {
            return false;
        }
        // 新增逻辑：检查当前仓库是否已配置自定义域名
        if (item.action === 'copyCustomDomainLink') {
            return currentRepoObject && !!currentRepoObject.customDomain;
        }
        return state.contextMenuVisibility[category][item.action];
    });

    visibleItems.forEach(({ action, icon, text, className = '' }) => {
        const item = document.createElement('a');
        item.className = `context-menu-item ${className}`;
        item.dataset.action = action;
        item.innerHTML = `<i class="fa ${icon} mr-2"></i>${text}`;
        item.addEventListener('click', () => {
            handleContextMenuAction(action, state.selectedFile);
            hideContextMenu();
        });
        el.contextMenuItems.appendChild(item);
    });
}
function showContextMenu(e, file) {
    state.selectedFile = file;
    const menu = el.contextMenu;
    menu.style.opacity = '0';
    menu.style.transform = 'scale(0.8)';
    menu.classList.remove('hidden');
    renderContextMenuItems(file);
    const menuWidth = menu.offsetWidth;
    const menuHeight = menu.offsetHeight;
    const position = positionContextMenu(e, menuWidth, menuHeight);
    menu.style.top = `${position.top}px`;
    menu.style.left = `${position.left}px`;
    let start = null, duration = 150;
    function animate(timestamp) {
        if (!start) start = timestamp;
        const progress = Math.min((timestamp - start) / duration, 1);
        menu.style.opacity = progress.toString();
        menu.style.transform = `scale(${0.8 + 0.2 * progress})`;
        if (progress < 1) requestAnimationFrame(animate);
    }
    requestAnimationFrame(animate);
    uiStateStack.push(hideContextMenu);
}

async function showRepoContextMenu(e, repo) {
    state.selectedRepo = repo;
    const menu = el.contextMenu;
    menu.style.opacity = '0';
    menu.style.transform = 'scale(0.8)';
    menu.classList.remove('hidden');
    await renderRepoContextMenuItems(repo);
    const menuWidth = menu.offsetWidth;
    const menuHeight = menu.offsetHeight;
    const position = positionContextMenu(e, menuWidth, menuHeight);
    menu.style.top = `${position.top}px`;
    menu.style.left = `${position.left}px`;
    let start = null, duration = 150;
    function animate(timestamp) {
        if (!start) start = timestamp;
        const progress = Math.min((timestamp - start) / duration, 1);
        menu.style.opacity = progress.toString();
        menu.style.transform = `scale(${0.8 + 0.2 * progress})`;
        if (progress < 1) requestAnimationFrame(animate);
    }
    requestAnimationFrame(animate);
    uiStateStack.push(hideContextMenu);
}

async function renderRepoContextMenuItems(repo) {
    el.contextMenuItems.innerHTML = '';
    const isMainSiteRepo = state.user && repo.name === `${state.user.login}.github.io`;
    const isPublished = repo.has_pages;
    
    const pinnedRepos = JSON.parse(localStorage.getItem('pinned_repos') || '[]');
    const isPinned = pinnedRepos.includes(repo.id);

    const visibleItems = CONTEXT_MENU_DEFINITIONS.repo.filter(item => {
        if (!state.contextMenuVisibility.repo[item.action]) {
            return false;
        }

        if (item.action === 'copyMainSiteLink') {
            return isMainSiteRepo;
        }
        if (item.action === 'copyProjectSiteLink') {
            return isPublished && !isMainSiteRepo;
        }
        // 新增逻辑：仅当仓库对象中存在 customDomain 属性时才显示
        if (item.action === 'copyCustomDomainLink') {
            return !!repo.customDomain;
        }
        return true;
    });

    visibleItems.forEach(({ action, icon, text, className = '' }) => {
        const item = document.createElement('a');
        item.className = `context-menu-item ${className}`;
        item.dataset.action = action;
        
        if (action === 'togglePin') {
            text = isPinned ? '取消置顶' : '置顶';
        }
        
        item.innerHTML = `<i class="fa ${icon} mr-2"></i>${text}`;
        item.addEventListener('click', () => {
            handleRepoContextMenuAction(action, state.selectedRepo);
            hideContextMenu();
        });
        el.contextMenuItems.appendChild(item);
    });
}

const hideContextMenu = () => {
    if (isContextMenuClosing) return; 
    const menu = el.contextMenu;
    if (menu.classList.contains('hidden')) return;

    isContextMenuClosing = true;

    let start = null,
        duration = 150;
    function animate(timestamp) {
        if (!start) start = timestamp;
        const progress = Math.min((timestamp - start) / duration, 1);
        menu.style.opacity = (1 - progress).toString();
        menu.style.transform = `scale(${1 - 0.2 * progress})`;
        if (progress < 1) {
            requestAnimationFrame(animate);
        } else {
            menu.classList.add('hidden');
            state.selectedFile = null;
            state.selectedRepo = null;
            isContextMenuClosing = false; 
        }
    }
    requestAnimationFrame(animate);
    const index = uiStateStack.indexOf(hideContextMenu);
    if (index > -1) uiStateStack.splice(index, 1);
};

async function deleteSingleItem(item) {
    const [owner, repo] = state.currentRepo.split('/');
    const deleteFile = async (path, sha) => {
        const res = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${path}`, {
            method: 'DELETE',
            headers: { Authorization: `token ${state.token}`, 'Content-Type': 'application/json' },
            body: JSON.stringify({ message: `Delete ${item.name}`, sha: sha, branch: state.currentBranch })
        });
        if (!res.ok) {
            let errorMessage;
            if (res.status === 401) errorMessage = '令牌无效或已过期。';
            else if (res.status === 403) errorMessage = '权限不足。';
            else if (res.status === 404) errorMessage = '文件未找到。';
            else if (res.status === 409) errorMessage = '文件冲突，请刷新后重试。';
            else errorMessage = `发生未知网络错误 (HTTP ${res.status})。`;
            throw new Error(errorMessage);
        }
    };
    const getAllFiles = async (path) => {
        let allFiles = [];
        const res = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${path}?ref=${state.currentBranch}`, { headers: { Authorization: `token ${state.token}` } });
        const items = await res.json();
        if (!Array.isArray(items)) return [];
        for (const i of items) {
            if (i.type === 'dir') {
                allFiles = allFiles.concat(await getAllFiles(i.path));
            } else {
                allFiles.push(i);
            }
        }
        return allFiles;
    };
    if (item.type === 'dir') {
        const filesToDelete = await getAllFiles(item.path);
        for (const f of filesToDelete.reverse()) {
            await deleteFile(f.path, f.sha);
        }
    } else {
        await deleteFile(item.path, item.sha);
    }
}

function handleContextMenuAction(action, oldFileObject) {
    const currentFile = state.files.find(f => f.path === oldFileObject.path);
    if (!currentFile) {
        showToast('文件已更新，请重新选择或刷新页面');
        return;
    }
     switch (action) {
    case 'copyPagesLink':
        const [owner, repoName] = state.currentRepo.split('/');
        const isMainSiteRepo = state.user && repoName === `${state.user.login}.github.io`;
        
        const pagesUrl = isMainSiteRepo
            ? `https://${owner}.github.io/${currentFile.path}`
            : `https://${owner}.github.io/${repoName}/${currentFile.path}`;

        navigator.clipboard.writeText(pagesUrl).then(() => {
            showToast('项目网站链接已复制');
        }).catch(e => {
            showToast(`复制失败: ${e.message || '应用剪切板权限没给'}`);
        });
        break;
    // 新增 case 用于处理文件和文件夹的自定义域链接复制
    case 'copyCustomDomainLink': {
        const currentRepoObject = state.repos.find(repo => repo.full_name === state.currentRepo);
        if (currentRepoObject && currentRepoObject.customDomain) {
            const customUrl = `https://${currentRepoObject.customDomain}/${currentFile.path}`;
            navigator.clipboard.writeText(customUrl).then(() => {
                showToast(`自定义域名复制成功: ${customUrl}`);
            }).catch(e => {
                showToast(`复制失败: ${e.message}`);
            });
        }
        break;
    }
    case 'unzip':
        unzipFile(currentFile);
        break;
   
        case 'multiSelect':
            toggleMultiSelectMode(true);
            state.selectedItems.add(currentFile.path);
            renderFileList();
            updateActionBar();
            break;
        case 'download':
            downloadFile(currentFile);
            break;
        case 'downloadFolder':
            downloadFolderAsZip(currentFile);
            break;
        case 'copyLink':
            copyLink(currentFile);
            break;
        case 'copyProxy':
            copyProxyLink(currentFile);
            break;
        case 'copyGitHubLink':
            navigator.clipboard.writeText(currentFile.html_url).then(() => {
                showToast('GitHub 链接已复制');
            }).catch(e => {
                showToast(`复制失败: ${e.message || '应用剪切板权限没给'}`);
                console.error(e);
            });
            break;
        case 'edit':
            editFile(currentFile);
            break;
        case 'rename':
            showRenameModal(currentFile);
            break;
        case 'delete':
            showDeleteModal(currentFile);
            break;
    }
}

async function handleRepoContextMenuAction(action, repo) {
    const isMainSiteRepo = state.user && repo.name === `${state.user.login}.github.io`;

    switch (action) {
        case 'togglePin': {
            const pinnedRepos = JSON.parse(localStorage.getItem('pinned_repos') || '[]');
            const repoId = repo.id;
            const index = pinnedRepos.indexOf(repoId);

            if (index > -1) {
                pinnedRepos.splice(index, 1);
                showToast(`仓库 "${repo.name}" 已取消置顶`);
            } else {
                pinnedRepos.push(repoId);
                showToast(`仓库 "${repo.name}" 已置顶`);
            }

            localStorage.setItem('pinned_repos', JSON.stringify(pinnedRepos));
            renderRepoList();
            break;
        }
        case 'copyProjectSiteLink':
            const siteUrl = `https://${repo.owner.login}.github.io/${repo.name}/`;
            navigator.clipboard.writeText(siteUrl).then(() => {
                showToast('项目网站链接已复制', 'success');
            }).catch(err => {
                showToast('复制失败', 'error');
            });
            break;
        case 'copyMainSiteLink':
            const mainSiteUrl = `https://${repo.owner.login}.github.io/`;
            navigator.clipboard.writeText(mainSiteUrl).then(() => {
                showToast('主站链接已复制', 'success');
            }).catch(err => {
                showToast('复制失败', 'error');
            });
            break;
       
        case 'copyCustomDomainLink':
            if (repo.customDomain) {
                const customUrl = `https://${repo.customDomain}`;
                navigator.clipboard.writeText(customUrl).then(() => {
                    showToast(`自定义域名复制成功: ${customUrl}`);
                }).catch(err => {
                    showToast('复制失败', 'error');
                });
            }
            break;
        case 'copyRepoGitHubLink':
            navigator.clipboard.writeText(repo.html_url).then(() => showToast('仓库链接已复制'));
            break;
        case 'createBranch':
            showCreateBranchModal(repo);
            break;

        case 'downloadRepoDirect':
            downloadRepoAsZip(repo, false);
            break;
        case 'renameRepo':
            showRenameModal(repo);
            break;
        case 'deleteRepo':
            showDeleteRepoModal(repo);
            break;
    }
}

async function batchUnpublishSites() {
    const reposToUnpublish = state.repos.filter(r => r.has_pages && r.name !== `${state.user.login}.github.io`);

    if (reposToUnpublish.length === 0) {
        showToast('没有需要取消发布的网站。', 'info');
        return;
    }

    el.batchUnpublishAllBtn.disabled = true;
    el.batchUnpublishAllBtn.classList.add('btn-processing');

    let successCount = 0;
    
    for (const [index, repo] of reposToUnpublish.entries()) {
        showToast(`正在取消发布 (${index + 1}/${reposToUnpublish.length}): ${repo.name}`);
        const result = await unpublishSite(repo);
        if (result.success) {
            const repoInState = state.repos.find(r => r.id === repo.id);
            if (repoInState) {
                repoInState.has_pages = false;
            }
            successCount++;
        }
    }

    renderPublishManagerLists();

    el.batchUnpublishAllBtn.classList.remove('btn-processing');
    showToast(`批量取消发布完成！共处理 ${successCount} 个。`, 'success');
}

async function batchPublishSites() {
    const reposToPublish = state.repos.filter(r => !r.private && r.name !== `${state.user.login}.github.io` && !r.has_pages);

    if (reposToPublish.length === 0) {
        showToast('没有可发布的仓库。', 'info');
        return;
    }

    el.batchPublishAllBtn.disabled = true;
    el.batchPublishAllBtn.classList.add('btn-processing');
    
    let successCount = 0;
    let failCount = 0;

    for (const [index, repo] of reposToPublish.entries()) {
        showToast(`正在发布 (${index + 1}/${reposToPublish.length}): ${repo.name}`);
        const result = await publishProjectSite(repo);
        if (result.success) {
            const repoInState = state.repos.find(r => r.id === repo.id);
            if (repoInState) {
                repoInState.has_pages = true;
            }
            successCount++;
        } else {
            failCount++;
        }
    }
    
    renderPublishManagerLists();
    
    el.batchPublishAllBtn.classList.remove('btn-processing');
    showToast(`批量发布完成！成功 ${successCount} 个，失败 ${failCount} 个。`, 'success');
}

function findNextAvailableBackupName() {
    let maxNum = 0;
    const prefix = 'Github----';
    state.repos.forEach(repo => {
        if (repo.name.startsWith(prefix)) {
            const numPart = repo.name.substring(prefix.length);
            if (/^\d+$/.test(numPart)) {
                const num = parseInt(numPart, 10);
                if (num > maxNum) {
                    maxNum = num;
                }
            }
        }
    });
    return `${prefix}${maxNum + 1}`;
}

let repoToSetAsSite = null;
let branchToPublish = null;

function hideSetAsSiteModal() {
    el.setAsSiteModal.classList.add('hidden');
    repoToSetAsSite = null;
    branchToPublish = null;
    const index = uiStateStack.indexOf(hideSetAsSiteModal);
    if (index > -1) uiStateStack.splice(index, 1);
}






async function disablePages(repo) {
    try {
        // 使用 PATCH 更新仓库设置，这是禁用Pages更可靠的方法
        const res = await fetch(`https://api.github.com/repos/${repo.full_name}`, {
            method: 'PATCH',
            headers: {
                'Authorization': `token ${state.token}`,
                'Content-Type': 'application/json'
            },
            // 直接在仓库设置中关闭 has_pages 开关
            body: JSON.stringify({
                has_pages: false 
            })
        });

        if (!res.ok) {
            const errorData = await res.json().catch(() => ({}));
            const errorMessage = errorData.message || `禁用 Pages 失败 (HTTP ${res.status})`;
            throw new Error(errorMessage);
        }

        // 成功禁用后，立即更新本地缓存的仓库状态
        const repoInState = state.repos.find(r => r.id === repo.id);
        if (repoInState) {
            repoInState.has_pages = false;
        }

        return { success: true };

    } catch (error) {
        console.error(`禁用仓库 ${repo.name} 的 Pages 失败:`, error);
        // 将错误向上抛出，以便主流程能捕获并提示用户
        throw error;
    }
}




async function waitForRepoRename(oldRepoFullName, timeout = 30000) {
    const startTime = Date.now();
    const pollInterval = 2000;
    const [owner, oldRepoName] = oldRepoFullName.split('/');

    while (Date.now() - startTime < timeout) {
        await fetchRepos(true, false);
        const repoStillExists = state.repos.some(r => r.name === oldRepoName && r.owner.login === owner);
        if (!repoStillExists) {
            return true;
        }
        await new Promise(resolve => setTimeout(resolve, pollInterval));
    }
    throw new Error('等待旧主站重命名确认超时');
}







async function showPublishBranchSelectorModal(repo, publishType) {
    repoToSetAsSite = repo;
    branchToPublish = repo.default_branch;

    const modalTitle = el.setAsSiteModal.querySelector('.modal-title-text');
    modalTitle.textContent = (publishType === 'mainSite') ? '发布主网站' : '发布项目网站';

    el.setAsSiteModal.classList.remove('hidden');
    uiStateStack.push(hideSetAsSiteModal);

    const selectorWrapper = document.getElementById('setAsSiteBranchSelector');
    const triggerText = selectorWrapper.querySelector('span');
    const optionsPanel = selectorWrapper.querySelector('.custom-branch-select-options');
    const confirmBtn = el.setAsSiteConfirmBtn;

    triggerText.textContent = '加载分支中...';
    optionsPanel.innerHTML = '';
    confirmBtn.disabled = true;

    try {
        const res = await fetch(`https://api.github.com/repos/${repo.full_name}/branches`, {
            headers: { Authorization: `token ${state.token}` }
        });
        if (!res.ok) throw new Error('获取分支列表失败');
        
        const branches = (await res.json()).reverse();
        if (branches.length === 0) {
            triggerText.textContent = '无可用分支';
            return;
        }

        confirmBtn.disabled = false;
        triggerText.textContent = branchToPublish;

        branches.forEach(branch => {
            const option = document.createElement('div');
            option.className = 'custom-branch-select-option';
            if (branch.name === branchToPublish) option.classList.add('selected');
            option.textContent = branch.name;
            option.dataset.branchName = branch.name;
            option.addEventListener('click', () => {
                branchToPublish = branch.name;
                triggerText.textContent = branch.name;
                const currentSelected = optionsPanel.querySelector('.selected');
                if (currentSelected) currentSelected.classList.remove('selected');
                option.classList.add('selected');
                selectorWrapper.classList.remove('open');
            });
            optionsPanel.appendChild(option);
        });
    } catch (error) {
        triggerText.textContent = '加载失败';
        showToast(error.message);
    }

    confirmBtn.onclick = async () => {
        const repoToProcess = repoToSetAsSite;
        const branchToUse = branchToPublish;
        if (!repoToProcess || !branchToUse) return;

        hideSetAsSiteModal();

        if (publishType === 'projectSite') {
            const buttonInManager = document.querySelector(`.project-action-btn[data-repo-fullname="${repoToProcess.full_name}"]`);
            if (buttonInManager) {
                buttonInManager.textContent = '处理中...';
                buttonInManager.disabled = true;
            }
            const result = await publishProjectSite(repoToProcess, branchToUse);
            showToast(result.message, result.success ? 'success' : 'error');
            if (result.success) {
                const repoInState = state.repos.find(r => r.id === repoToProcess.id);
                if (repoInState) repoInState.has_pages = true;
            }
            renderPublishManagerLists();
        } else if (publishType === 'mainSite') {
            const mainSiteButton = document.querySelector(`.set-as-main-site-btn[data-repo-fullname="${repoToProcess.full_name}"]`);
            if (mainSiteButton) {
                mainSiteButton.textContent = '处理中...';
                mainSiteButton.disabled = true;
            }
            
            el.mainLoader.classList.remove('hidden');
            const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));

            async function enablePagesWithRetry(repo, branch, maxAttempts = 2, delayBetweenAttempts = 4000) {
                for (let attempt = 1; attempt <= maxAttempts; attempt++) {
                    showToast(`正在配置网站页面`, 'info');
                    try {
                        const pagesRes = await fetch(`https://api.github.com/repos/${repo.full_name}/pages`, {
                            method: 'POST',
                            headers: { 'Authorization': `token ${state.token}`, 'Content-Type': 'application/json' },
                            body: JSON.stringify({ source: { branch: branch, path: "/" } })
                        });

                        if (pagesRes.ok || pagesRes.status === 409) {
                            return { success: true };
                        }
                        
                        const updateRes = await fetch(`https://api.github.com/repos/${repo.full_name}/pages`, {
                            method: 'PUT',
                            headers: { 'Authorization': `token ${state.token}`, 'Content-Type': 'application/json' },
                            body: JSON.stringify({ source: { branch: branch, path: "/" } })
                        });
                        
                        if (updateRes.ok) {
                            return { success: true };
                        }

                        if (attempt < maxAttempts) {
                            await delay(delayBetweenAttempts);
                            continue;
                        }
                        
                        throw new Error(`API错误: ${updateRes.status}`);

                    } catch (error) {
                        if (attempt >= maxAttempts) {
                            throw error;
                        }
                        await delay(delayBetweenAttempts);
                    }
                }
                 throw new Error('配置网站失败');
            }

            const MAX_SETUP_ATTEMPTS = 3;
            let finalError = null;

            for (let setupAttempt = 1; setupAttempt <= MAX_SETUP_ATTEMPTS; setupAttempt++) {
                try {
                    showToast(`正在设置主站 (第 ${setupAttempt}/${MAX_SETUP_ATTEMPTS} 次)`, 'info', 7000);
                    const mainSiteName = `${state.user.login}.github.io`;
                    await fetchRepos(true, false);
                    const existingMainSite = state.repos.find(r => r.name === mainSiteName);
                    
                    if (existingMainSite && existingMainSite.id !== repoToProcess.id) {
                        if (existingMainSite.has_pages) {
                            await disablePages(existingMainSite);
                        }
                        const backupName = findNextAvailableBackupName();
                        await fetch(`https://api.github.com/repos/${existingMainSite.full_name}`, {
                            method: 'PATCH', headers: { 'Authorization': `token ${state.token}`, 'Content-Type': 'application/json' },
                            body: JSON.stringify({ name: backupName })
                        });
                    }
                    
                    if (repoToProcess.name !== mainSiteName) {
                        await fetch(`https://api.github.com/repos/${repoToProcess.full_name}`, {
                            method: 'PATCH', headers: { 'Authorization': `token ${state.token}`, 'Content-Type': 'application/json' },
                            body: JSON.stringify({ name: mainSiteName })
                        });
                    }
                    
                    await delay(6000);
                    await fetchRepos(true, false);
                    const finalRepoToPublish = state.repos.find(r => r.name === mainSiteName);

                    if (!finalRepoToPublish) {
                         throw new Error('主站信息同步失败');
                    }
                    
                    const result = await enablePagesWithRetry(finalRepoToPublish, branchToUse);

                    if (!result.success) {
                        throw new Error('配置网站失败，请稍后在GitHub官网手动开启Pages');
                    }

                    showToast('主站发布成功！', 'success');
                    await delay(2000);
                    finalError = null;
                    break;

                } catch (e) {
                    finalError = e;
                    if (setupAttempt < MAX_SETUP_ATTEMPTS) {
                        showToast(`${e.message}，自动重试中`, 'info');
                        await delay(1000);
                    }
                }
            }

            if (finalError) {
                 showToast(`操作最终失败: ${finalError.message}，请手动重试`, 'error');
                 if (mainSiteButton) {
                     mainSiteButton.textContent = '发布为主站';
                     mainSiteButton.disabled = false;
                 }
            }
            
            await fetchRepos(true, false);
            el.mainLoader.classList.add('hidden');
            renderPublishManagerLists();
        }
    };
}





function downloadRepoAsZip(repo) {
    const zipRaw = `https://github.com/${repo.full_name}/archive/refs/heads/${repo.default_branch || 'main'}.zip`;
    let zipUrl = zipRaw;
    let viaProxy = false;

    if (state.proxyGlobalEnable && state.proxies.length > 0 && state.activeProxyIndex !== -1) {
        const activeProxy = state.proxies[state.activeProxyIndex];
        if (activeProxy && activeProxy.url && activeProxy.type) {
            if (activeProxy.type === 'prefix') {
                let proxyBase = activeProxy.url;
                if (!proxyBase.endsWith('/')) {
                    proxyBase += '/';
                }
                zipUrl = proxyBase + zipRaw;
                viaProxy = true;
            } else if (activeProxy.type === 'raw_domain_replace') {
                try {
                    const proxyDomain = getDomainFromUrl(activeProxy.url);
                    if (proxyDomain) {
                        const originalUrl = new URL(zipRaw);
                        originalUrl.hostname = proxyDomain;
                        zipUrl = originalUrl.toString();
                        viaProxy = true;
                    }
                } catch (e) {
                    console.error("域名替换失败:", e);
                }
            }
        }
    }

    const a = document.createElement('a');
    a.href = zipUrl;
    a.download = `${repo.name}.zip`;
    a.classList.add('hidden');
    document.body.appendChild(a);
    a.click();
    setTimeout(() => document.body.removeChild(a), 500);
    showToast(`正在使用${viaProxy ? '代理' : '直连'}下载 ${repo.name}.zip `);

}


function handleUploadClick() {
    if (!state.currentRepo) {
        showToast('请先选择仓库');
        return;
    }
    el.fileUploadInput.click();
}

function handleFilesSelected(e) {
    const files = Array.from(e.target.files || []);
    if (files.length === 0) return;
    el.uploadPanel.classList.remove('hidden');
    el.uploadItems.innerHTML = '';
    files.forEach((file, index) => {
        let displayName = file.name;
        if (displayName.length > 25) {
            displayName = displayName.slice(0, 22) + '...';
        }
        const uploadItem = document.createElement('div');
        uploadItem.className = 'upload-item';
        uploadItem.innerHTML = `
            <div class="upload-info">
                <span class="upload-name" title="${file.name}">${displayName}</span>
                <span class="upload-size">${formatSize(file.size)}</span>
            </div>
            <div class="upload-progress-container">
                <div class="upload-progress" data-index="${index}">
                    <span class="percent-text" data-index="${index}">0%</span>
                </div>
            </div>
            <div class="upload-status" data-index="${index}">等待上传...</div>
        `;
        el.uploadItems.appendChild(uploadItem);
    });
    uploadFilesInSequence(files, 0);
    e.target.value = '';
}

async function uploadFilesInSequence(files, index) {
    if (index >= files.length) {
        setTimeout(() => {
            el.uploadPanel.classList.add('hidden');
        }, 200);
        return;
    }
    const file = files[index];
    const statusElement = document.querySelector(`.upload-status[data-index="${index}"]`);
    if (statusElement) statusElement.textContent = '准备上传...';
    try {
        await uploadSingleFile(file, index);
    } catch (error) {
        console.error(`Upload failed for file at index ${index}:`, error);
    } finally {
        invalidateCacheForPathAndParents(state.currentPath);
        
        state.shouldAnimateList = true;
        await fetchFiles(true);
    }
    await uploadFilesInSequence(files, index + 1);
}

async function uploadSingleFile(file, index) {
    const MAX_FILE_SIZE_BYTES = 100 * 1024 * 1024;
    return new Promise(async (resolve, reject) => {
        const progressBar = document.querySelector(`.upload-progress[data-index="${index}"]`);
        const statusElement = document.querySelector(`.upload-status[data-index="${index}"]`);
        const percentTextEl = progressBar ? progressBar.querySelector(`.percent-text[data-index="${index}"]`) : null;
        if (file.size > MAX_FILE_SIZE_BYTES) {
            if (statusElement) {
                statusElement.textContent = `文件过大 (限制100MB)`;
                statusElement.className = 'upload-status error';
            }
            showToast(`文件 "${file.name}" 超过100MB官方限制`);
            reject(new Error('文件过大'));
            return;
        }
        if (statusElement) statusElement.textContent = '正在上传...';
        const reader = new FileReader();
        reader.readAsArrayBuffer(file);
        reader.onload = async (e) => {
            let progress = 0;
            let progressInterval = null;
            const [owner, repo] = state.currentRepo.split('/');
            const fileName = file.name;
            const filePath = state.currentPath ? `${state.currentPath}${fileName}` : fileName;
            const verifyUpload = async () => {
                if (statusElement) statusElement.textContent = '上传超时，正在验证...';
                try {
                    await new Promise(res => setTimeout(res, 2000));
                    const verifyUrl = `https://api.github.com/repos/${owner}/${repo}/contents/${filePath}?ref=${state.currentBranch}&t=${Date.now()}`;
                    const verifyRes = await fetch(verifyUrl, {
                        headers: { 'Authorization': `token ${state.token}`, 'User-Agent': 'Mozilla/5.0' }
                    });
                    if (verifyRes.ok) {
                        return true;
                    }
                    return false;
                } catch (verifyError) {
                    return false;
                }
            };
            try {
                progressInterval = setInterval(() => {
                    if (progress < 95) {
                        progress += 1;
                        if (progressBar) progressBar.style.width = `${progress}%`;
                        if (percentTextEl) percentTextEl.textContent = `${progress}%`;
                    }
                }, 100);
                const base64String = arrayBufferToBase64(e.target.result);
                if (!state || !state.currentRepo) throw new Error('未选择仓库');
                let existingFileSha = null;
                try {
                    const checkUrl = `https://api.github.com/repos/${owner}/${repo}/contents/${filePath}?ref=${state.currentBranch}`;
                    const checkRes = await fetch(checkUrl, { headers: { 'Authorization': `token ${state.token}`, 'User-Agent': 'Mozilla/5.0' } });
                    if (checkRes.ok) existingFileSha = (await checkRes.json()).sha;
                } catch (e) { console.warn(`无法获取文件SHA: ${e.message}`); }
                const requestBody = {
                    message: `Upload ${fileName}`,
                    content: base64String,
                    branch: state.currentBranch
                };
                if (existingFileSha) requestBody.sha = existingFileSha;
                const response = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${filePath}`, {
                    method: 'PUT',
                    headers: { 'Authorization': `token ${state.token}`, 'Content-Type': 'application/json', 'User-Agent': 'Mozilla/5.0' },
                    body: JSON.stringify(requestBody),
                    signal: AbortSignal.timeout(300000)
                });
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.message || `上传失败: HTTP ${response.status}`);
                }
                clearInterval(progressInterval);
                progress = 100;
                if (progressBar) progressBar.style.width = '100%';
                if (percentTextEl) percentTextEl.textContent = '100%';
                if (statusElement) {
                    statusElement.textContent = '上传成功';
                    statusElement.className = 'upload-status success';
                }
                resolve();
            } catch (error) {
                let isVerifiedSuccess = false;
                if (error.name === 'AbortError' || error.message.includes('Failed to fetch')) {
                    isVerifiedSuccess = await verifyUpload();
                }
                if (isVerifiedSuccess) {
                    if (statusElement) {
                        statusElement.textContent = '上传成功 (已验证)';
                        statusElement.className = 'upload-status success';
                    }
                    resolve();
                } else {
                    if (statusElement) {
                        statusElement.textContent = '上传失败';
                        statusElement.className = 'upload-status error';
                    }
                    reject(new Error(`上传失败: ${error.message}`));
                }
            } finally {
                if (progressInterval) clearInterval(progressInterval);
                const itemContainer = statusElement ? statusElement.closest('.upload-item') : null;
                if (itemContainer && statusElement.classList.contains('success')) {
                    setTimeout(() => {
                        itemContainer.style.transition = 'opacity 0.5s, height 0.5s, margin 0.5s, padding 0.5s';
                        itemContainer.style.opacity = '0';
                        itemContainer.style.height = '0';
                        itemContainer.style.margin = '0';
                        itemContainer.style.padding = '0';
                        itemContainer.style.overflow = 'hidden';
                        setTimeout(() => itemContainer.remove(), 500);
                    }, 1500);
                }
            }
        };
        reader.onerror = () => {
            if (statusElement) {
                statusElement.textContent = '文件读取失败';
                statusElement.className = 'upload-status error';
            }
            reject(new Error('文件读取失败'));
        };
    });
}

function arrayBufferToBase64(buffer) {
    let binary = '';
    const bytes = new Uint8Array(buffer);
    const len = bytes.byteLength;
    for (let i = 0; i < len; i++) {
        binary += String.fromCharCode(bytes[i]);
    }
    return btoa(binary);
}

async function renameWithGitDataAPI(item, newName) {
    const [owner, repo] = state.currentRepo.split('/');
    const oldPath = item.path;
    const newPath = oldPath.substring(0, oldPath.lastIndexOf('/') + 1) + newName;
    const refResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/git/refs/heads/${state.currentBranch}`, {
        headers: { 'Authorization': `token ${state.token}` }
    });
    if (!refResponse.ok) throw new Error('无法获取分支信息');
    const refData = await refResponse.json();
    const latestCommitSha = refData.object.sha;
    const commitResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/git/commits/${latestCommitSha}`, {
        headers: { 'Authorization': `token ${state.token}` }
    });
    if (!commitResponse.ok) throw new Error('无法获取提交信息');
    const commitData = await commitResponse.json();
    const baseTreeSha = commitData.tree.sha;
    const createTreeResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/git/trees`, {
        method: 'POST',
        headers: { 'Authorization': `token ${state.token}`, 'Content-Type': 'application/json' },
        body: JSON.stringify({
            base_tree: baseTreeSha,
            tree: [
                { path: newPath, mode: '100644', type: 'blob', sha: item.sha },
                { path: oldPath, mode: '100644', type: 'blob', sha: null }
            ]
        })
    });
    if (!createTreeResponse.ok) throw new Error('创建新目录树失败');
    const treeData = await createTreeResponse.json();
    const newTreeSha = treeData.sha;
    const createCommitResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/git/commits`, {
        method: 'POST',
        headers: { 'Authorization': `token ${state.token}`, 'Content-Type': 'application/json' },
        body: JSON.stringify({
            message: `Rename ${item.name} to ${newName}`,
            tree: newTreeSha,
            parents: [latestCommitSha]
        })
    });
    if (!createCommitResponse.ok) throw new Error('创建新提交失败');
    const newCommitData = await createCommitResponse.json();
    const newCommitSha = newCommitData.sha;
    const updateRefResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/git/refs/heads/${state.currentBranch}`, {
        method: 'PATCH',
        headers: { 'Authorization': `token ${state.token}`, 'Content-Type': 'application/json' },
        body: JSON.stringify({ sha: newCommitSha })
    });
    if (!updateRefResponse.ok) throw new Error('更新分支引用失败');
}

async function renameFolderWithGitDataAPI(item, newName) {
    const [owner, repo] = state.currentRepo.split('/');
    const oldPath = item.path;
    const newPath = oldPath.substring(0, oldPath.lastIndexOf('/') + 1) + newName;
    const refResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/git/refs/heads/${state.currentBranch}`, {
        headers: { 'Authorization': `token ${state.token}` }
    });
    if (!refResponse.ok) throw new Error('无法获取分支信息');
    const refData = await refResponse.json();
    const latestCommitSha = refData.object.sha;
    const commitResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/git/commits/${latestCommitSha}`, {
        headers: { 'Authorization': `token ${state.token}` }
    });
    if (!commitResponse.ok) throw new Error('无法获取提交信息');
    const commitData = await commitResponse.json();
    const baseTreeSha = commitData.tree.sha;
    const createTreeResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/git/trees`, {
        method: 'POST',
        headers: { 'Authorization': `token ${state.token}`, 'Content-Type': 'application/json' },
        body: JSON.stringify({
            base_tree: baseTreeSha,
            tree: [
                { path: newPath, mode: '040000', type: 'tree', sha: item.sha },
                { path: oldPath, mode: '040000', type: 'tree', sha: null }
            ]
        })
    });
    if (!createTreeResponse.ok) throw new Error('创建新目录树失败');
    const treeData = await createTreeResponse.json();
    const newTreeSha = treeData.sha;
    const createCommitResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/git/commits`, {
        method: 'POST',
        headers: { 'Authorization': `token ${state.token}`, 'Content-Type': 'application/json' },
        body: JSON.stringify({
            message: `Rename ${item.name} to ${newName}`,
            tree: newTreeSha,
            parents: [latestCommitSha]
        })
    });
    if (!createCommitResponse.ok) throw new Error('创建新提交失败');
    const newCommitData = await createCommitResponse.json();
    const newCommitSha = newCommitData.sha;
    const updateRefResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/git/refs/heads/${state.currentBranch}`, {
        method: 'PATCH',
        headers: { 'Authorization': `token ${state.token}`, 'Content-Type': 'application/json' },
        body: JSON.stringify({ sha: newCommitSha })
    });
    if (!updateRefResponse.ok) throw new Error('更新分支引用失败');
}




function showDeleteRepoModal(repo) {
    showDeleteModal(null, false, '确认删除仓库', `确定要删除仓库 "${repo.name}" 吗？此操作不可撤销！`, async () => {
        try {
            const res = await fetch(`https://api.github.com/repos/${repo.full_name}`, {
                method: 'DELETE',
                headers: { 'Authorization': `token ${state.token}` }
            });

            if (!res.ok) {
                if (res.status === 403) {
                     throw new Error('权限不足，请确认令牌已勾选 delete_repo 权限');
                }
                throw new Error((await res.json()).message || '删除失败');
            }
            
            showToast(`仓库 "${repo.name}" 已成功删除`);
            
            await fetchRepos(true, true);

        } catch (e) {
            showToast(`删除失败: ${e.message}`, 'error');
        }
    });
}




function showUnpublishMainSiteModal(repo) {
    const extraSettingsContainer = document.getElementById('renameModalExtraSettings');
    extraSettingsContainer.innerHTML = ''; 

    el.renameTitle.querySelector('.modal-title-text').textContent = '取消发布主网站';

    el.renameWarn.innerHTML = '此操作会先禁用网站的静态页面配置，然后将仓库重命名，从而安全地下线。您的所有文件都会被保留。';
    el.renameWarn.classList.remove('text-red-400');
    el.renameWarn.style.color = '';
    el.renameWarn.style.fontSize = '0.7rem';
    el.renameWarn.style.marginBottom = '0.6rem';
    el.renameWarn.style.display = 'block';

    el.renameInput.value = '';
    el.renameInput.placeholder = '请输入新的仓库名';
    
    el.renameConfirm.disabled = true;
    el.renameModal.classList.remove('hidden');

    el.renameInput.oninput = function() {
        const newName = el.renameInput.value.trim();
        el.renameConfirm.disabled = !newName || newName === repo.name;
    };

    el.renameConfirm.onclick = async function() {
        const newName = el.renameInput.value.trim();
        if (!newName) return;

        this.disabled = true;
        this.classList.add('btn-processing');
        this.innerHTML = '处理中 <i class="fa fa-spinner fa-spin"></i>';

        try {
            showToast('步骤1/2: 正在禁用静态页面配置...');
            await disablePages(repo);
            
            showToast('步骤2/2: 正在重命名仓库以完成下线...');
            const res = await fetch(`https://api.github.com/repos/${repo.full_name}`, {
                method: 'PATCH',
                headers: { 'Authorization': `token ${state.token}`, 'Content-Type': 'application/json' },
                body: JSON.stringify({ name: newName })
            });
            if (!res.ok) throw new Error((await res.json()).message || '重命名失败');
            
            showToast('主网站已成功下线');
            hideRenameModal();
            await fetchRepos(true, false);
            renderPublishManagerLists();

        } catch (e) {
            showToast(`操作失败: ${e.message}`, 'error');
        } finally {
            this.disabled = false;
            this.classList.remove('btn-processing');
            this.innerHTML = '确认';
        }
    };

    uiStateStack.push(hideRenameModal);
}


function showRenameModal(item) {
    const isRepo = typeof item.full_name === 'string';
    const extraSettingsContainer = document.getElementById('renameModalExtraSettings');
    extraSettingsContainer.innerHTML = ''; 

    if (isRepo) {
        el.renameTitle.querySelector('.modal-title-text').textContent = `修改仓库`;
        
        const repo = item; 
        const mainSiteName = state.user ? `${state.user.login}.github.io` : null;
        const settingsHTML = `
            <textarea id="newRepoDesc" placeholder="仓库描述（可选）" style="margin-top: 0.6rem;">${repo.description || ''}</textarea>
            <div class="checkbox-container" style="margin: 0.6rem 0;">
                <input type="checkbox" id="newRepoPrivate">
                <label for="newRepoPrivate">公开仓库</label>
            </div>
        `;
        extraSettingsContainer.innerHTML = settingsHTML;

        const descTextarea = document.getElementById('newRepoDesc');
        const privateCheckbox = document.getElementById('newRepoPrivate');
        el.renameInput.value = repo.name;
        privateCheckbox.checked = !repo.private;
        
        function autoGrow(element) {
            element.style.height = 'auto';
            element.style.height = (element.scrollHeight) + 'px';
        }
        descTextarea.addEventListener('input', () => autoGrow(descTextarea));
        autoGrow(descTextarea);
        
        const updateButtonState = () => {
            const newName = el.renameInput.value.trim();
            const newDesc = descTextarea.value.trim();
            el.renameWarn.style.display = 'none';
            el.renameWarn.classList.remove('text-red-400', 'text-orange-400');
            if (mainSiteName) {
                if (repo.name === mainSiteName && newName !== mainSiteName) {
                    el.renameWarn.textContent = '提示：重命名主站仓库将导致您的主网站下线。';
                    el.renameWarn.classList.add('text-orange-400');
                    el.renameWarn.style.display = 'block';
                } else if (repo.name !== mainSiteName && newName === mainSiteName) {
                    el.renameWarn.textContent = '提示：手动命名为主站仓库不会自动发布网站。推荐使用“设为主站”功能。';
                    el.renameWarn.classList.add('text-orange-400');
                    el.renameWarn.style.display = 'block';
                }
            }
            const nameChanged = newName !== repo.name;
            const descChanged = newDesc !== (repo.description || '');
            const visibilityChanged = privateCheckbox.checked === repo.private;
            const isModified = nameChanged || descChanged || visibilityChanged;
            el.renameConfirm.disabled = !isModified || !newName;
        };

        el.renameInput.oninput = updateButtonState;
        descTextarea.oninput = updateButtonState;
        privateCheckbox.onchange = updateButtonState;
        updateButtonState();

        el.renameConfirm.onclick = async function() {
            const newName = el.renameInput.value.trim();
            const newDesc = descTextarea.value.trim();
            const isPrivate = !privateCheckbox.checked;
            const requestBody = { name: newName, description: newDesc, private: isPrivate };
            this.disabled = true;
            this.classList.add('btn-processing');
            this.innerHTML = '处理中 <i class="fa fa-spinner fa-spin"></i>';
            try {
                const res = await fetch(`https://api.github.com/repos/${repo.full_name}`, {
                    method: 'PATCH',
                    headers: { 'Authorization': `token ${state.token}`, 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });
                if (!res.ok) throw new Error((await res.json()).message || '修改失败');
                state.shouldAnimateList = true;
                showToast(`保存成功`);
                hideRenameModal();
                await fetchRepos(true, true);
            } catch (e) {
                showToast(`修改失败: ${e.message}`, 'error');
            } finally {
                this.disabled = false;
                this.classList.remove('btn-processing');
                this.innerHTML = '确认';
            }
        };

    } else {
        let itemTypeText = '文件';
        if (item.type === 'dir') { itemTypeText = '文件夹'; } 
        else if (item.type === 'branch') { itemTypeText = '分支'; }
        el.renameTitle.querySelector('.modal-title-text').textContent = `重命名${itemTypeText}`;
        el.renameInput.value = item.name;
        el.renameWarn.style.display = 'none';
        el.renameWarn.textContent = '';
        el.renameConfirm.disabled = true;

        el.renameInput.oninput = function() {
            const newName = el.renameInput.value.trim();
            el.renameConfirm.disabled = !newName || newName === item.name;
        };
        
        el.renameInput.dispatchEvent(new Event('input'));

        el.renameConfirm.onclick = async function() {
            const v = el.renameInput.value.trim();
            if (!v || v === item.name) return;
            this.disabled = true;
            this.classList.add('btn-processing');
            this.innerHTML = '保存中 <i class="fa fa-spinner fa-spin"></i>';
            try {
                if (item.type === 'branch') {
                    const repo = item.repo;
                    const oldBranchName = item.name;
                    const newBranchName = v;
                    const res = await fetch(`https://api.github.com/repos/${repo.full_name}/branches/${oldBranchName}/rename`, { method: 'POST', headers: { 'Authorization': `token ${state.token}`, 'Content-Type': 'application/json' }, body: JSON.stringify({ new_name: newBranchName }) });
                    if (!res.ok) { const errorData = await res.json(); throw new Error(errorData.message || '重命名分支失败'); }
                    showToast(`分支已重命名为: ${v}`);
                    hideRenameModal();
                    hideCreateBranchModal();
                    fetchRepos(true);
                } else {
                    const isDir = item.type === 'dir';
                    const ONE_MB = 1024 * 1024;
                    if (isDir) {
                        await renameFolderWithGitDataAPI(item, v);
                    } else {
                        if (item.size > ONE_MB) {
                            await renameWithGitDataAPI(item, v);
                        } else {
                            const [owner, repo] = state.currentRepo.split('/');
                            const oldPath = item.path;
                            const base = oldPath.slice(0, -item.name.length);
                            const newPath = base + v;
                            const d = await (await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${oldPath}?ref=${state.currentBranch}`, { headers: { Authorization: `token ${state.token}` } })).json();
                            await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${newPath}`, { method: 'PUT', headers: { Authorization: `token ${state.token}`, 'Content-Type': 'application/json' }, body: JSON.stringify({ message: `Rename to ${v}`, content: d.content, sha: d.sha, branch: state.currentBranch }) });
                            await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${oldPath}`, { method: 'DELETE', headers: { Authorization: `token ${state.token}`, 'Content-Type': 'application/json' }, body: JSON.stringify({ message: `Delete old file`, sha: d.sha, branch: state.currentBranch }) });
                        }
                    }
                    showToast(`重命名成功: ${v}`);
                    hideRenameModal();
                    state.shouldAnimateList = true;
                    fetchFiles(true);
                }
            } catch (e) {
                showToast(`失败: ${e.message}`);
            } finally {
                this.disabled = false;
                this.classList.remove('btn-processing');
                this.innerHTML = '确认';
            }
        };
    }
    
    el.renameModal.classList.remove('hidden');
    uiStateStack.push(hideRenameModal);
}

function hideCreateFolderModal() {
    el.createFolderModal.classList.add('hidden');
    const index = uiStateStack.indexOf(hideCreateFolderModal);
    if (index > -1) uiStateStack.splice(index, 1);
}

function showCreateFolderModal() {
    el.createFolderInput.value = '';
    el.createFolderModal.classList.remove('hidden');
    el.createFolderConfirm.disabled = true;
    el.createFolderConfirm.onclick = async function() {
        const name = el.createFolderInput.value.trim();
        if (!name || el.createFolderConfirm.classList.contains('btn-processing')) return;
        el.createFolderConfirm.classList.add('btn-processing');
        el.createFolderConfirm.innerHTML = '创建中 <i class="fa fa-spinner fa-spin"></i>';
        try {
            const [owner, repo] = state.currentRepo.split('/');
            const path = state.currentPath ? `${state.currentPath}${name}` : name;
            await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${path}/.gitkeep`, {
                method: 'PUT',
                headers: { Authorization: `token ${state.token}`, 'Content-Type': 'application/json', 'User-Agent': 'Mozilla/5.0' },
                body: JSON.stringify({ message: `create folder ${name}`, content: '', branch: state.currentBranch })
            });
            showToast(`已创建文件夹: ${name}`);
            hideCreateFolderModal();
            state.shouldAnimateList = true;
            fetchFiles(true);
        } catch (e) {
            showToast(`失败: ${e.message}`);
        } finally {
            el.createFolderConfirm.classList.remove('btn-processing');
            el.createFolderConfirm.innerHTML = '确认';
            el.createFolderConfirm.disabled = !el.createFolderInput.value.trim();
        }
    };
    uiStateStack.push(hideCreateFolderModal);
}

function hideCreateFileModal() {
    el.createFileModal.classList.add('hidden');
    const index = uiStateStack.indexOf(hideCreateFileModal);
    if (index > -1) uiStateStack.splice(index, 1);
}

function showCreateFileModal() {
    if (!state.currentRepo) {
        showToast('请先选择仓库');
        return;
    }
    el.createFileNameInput.value = '';
    el.createFileContentInput.value = '';
    el.createFileModal.classList.remove('hidden');
    el.createFileConfirm.disabled = true;
    el.createFileConfirm.onclick = async function() {
        const name = el.createFileNameInput.value.trim();
        const content = el.createFileContentInput.value;
        if (!name) return;
        el.createFileConfirm.disabled = true;
        el.createFileConfirm.classList.add('btn-processing');
        el.createFileConfirm.innerHTML = '创建中 <i class="fa fa-spinner fa-spin"></i>';
        try {
            const [owner, repo] = state.currentRepo.split('/');
            const path = state.currentPath ? `${state.currentPath}${name}` : name;
            const encodedContent = btoa(unescape(encodeURIComponent(content)));
            const res = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${path}`, {
                method: 'PUT',
                headers: { Authorization: `token ${state.token}`, 'Content-Type': 'application/json' },
                body: JSON.stringify({ message: `create file ${name}`, content: encodedContent, branch: state.currentBranch })
            });
            if (!res.ok) throw new Error('创建失败');
            showToast(`已创建文件: ${name}`);
            hideCreateFileModal();
            state.shouldAnimateList = true;
            fetchFiles(true);
        } catch (e) {
            showToast(`失败: ${e.message}`);
        } finally {
            el.createFileConfirm.disabled = false;
            el.createFileConfirm.classList.remove('btn-processing');
            el.createFileConfirm.innerHTML = '确认';
        }
    };
    uiStateStack.push(hideCreateFileModal);
}

function hideCreateBranchModal() {
    el.createBranchModal.classList.add('hidden');
    const index = uiStateStack.indexOf(hideCreateBranchModal);
    if (index > -1) uiStateStack.splice(index, 1);
}

async function showCreateBranchModal(repo) {
    el.createBranchNameInput.value = '';
    el.createBranchConfirm.disabled = true;
    el.createBranchModal.classList.remove('hidden');
    el.createBranchNameInput.oninput = () => {
        el.createBranchConfirm.disabled = !el.createBranchNameInput.value.trim();
    };
    const sourceSelector = {
        wrapper: document.getElementById('sourceBranchSelector'),
        trigger: document.getElementById('sourceBranchSelector').querySelector('.custom-branch-select-trigger'),
        optionsPanel: document.getElementById('sourceBranchSelector').querySelector('.custom-branch-select-options'),
        triggerText: document.getElementById('sourceBranchSelector').querySelector('span'),
        currentSelection: { name: null, sha: null }
    };
    sourceSelector.triggerText.textContent = '加载中...';
    sourceSelector.optionsPanel.innerHTML = '';

    const updateBranchActionButtonsState = () => {
        const selectedBranchName = sourceSelector.currentSelection.name;
        if (!selectedBranchName) {
            el.renameBranchBtn.disabled = true;
            el.deleteBranchBtn.disabled = true;
            el.renameBranchBtn.title = '重命名所选分支';
            el.deleteBranchBtn.title = '删除所选分支';
            return;
        };
        const isDefaultBranch = selectedBranchName === repo.default_branch;
        el.renameBranchBtn.disabled = false;
        el.renameBranchBtn.title = isDefaultBranch ? '不能重命名默认分支' : `重命名分支: ${selectedBranchName}`;
        el.deleteBranchBtn.disabled = false;
        el.deleteBranchBtn.title = isDefaultBranch ? '不能删除默认分支' : `删除分支: ${selectedBranchName}`;
    };

    try {
        await fetchBranches(repo);
        const populateBranchOptions = () => {
            sourceSelector.optionsPanel.innerHTML = '';
            if (!state.branches || state.branches.length === 0) {
                sourceSelector.triggerText.textContent = '无可用分支';
                sourceSelector.currentSelection = { name: null, sha: null };
                el.createBranchConfirm.disabled = true;
                return;
            }
            state.branches.forEach(branch => {
                const option = document.createElement('div');
                option.className = 'custom-branch-select-option';
                option.textContent = branch.name;
                option.dataset.branchName = branch.name;
                option.dataset.branchSha = branch.commit.sha;
                option.addEventListener('click', () => {
                    sourceSelector.currentSelection = { name: branch.name, sha: branch.commit.sha };
                    const previouslySelected = sourceSelector.optionsPanel.querySelector('.selected');
                    if (previouslySelected) previouslySelected.classList.remove('selected');
                    option.classList.add('selected');
                    sourceSelector.triggerText.textContent = branch.name;
                    sourceSelector.wrapper.classList.remove('open');
                    updateBranchActionButtonsState();
                });
                sourceSelector.optionsPanel.appendChild(option);
            });
            const defaultBranch = state.branches.find(b => b.name === repo.default_branch) || state.branches[0];
            if (defaultBranch) {
                sourceSelector.currentSelection = { name: defaultBranch.name, sha: defaultBranch.commit.sha };
                sourceSelector.triggerText.textContent = defaultBranch.name;
                const defaultOption = sourceSelector.optionsPanel.querySelector(`[data-branch-name="${defaultBranch.name}"]`);
                if (defaultOption) defaultOption.classList.add('selected');
            }
        };
        populateBranchOptions();
    } catch (error) {
        console.error("加载分支失败:", error);
        sourceSelector.triggerText.textContent = '加载分支失败';
        showToast('加载分支列表失败');
        sourceSelector.currentSelection = { name: null, sha: null };
        el.createBranchConfirm.disabled = true;
    }

    updateBranchActionButtonsState();

    sourceSelector.trigger.onclick = (e) => {
        if (!state.branches || state.branches.length === 0) return;
        e.stopPropagation();
        sourceSelector.wrapper.classList.toggle('open');
    };

    document.addEventListener('click', (e) => {
        if (!sourceSelector.wrapper.contains(e.target)) {
            sourceSelector.wrapper.classList.remove('open');
        }
    });

    el.renameBranchBtn.onclick = function() {
        const branchToRename = sourceSelector.currentSelection.name;
        if (!branchToRename) return;
        if (branchToRename === repo.default_branch) {
            showToast('禁止重命名默认分支');
            return;
        }
        showRenameModal({ name: branchToRename, type: 'branch', repo: repo });
    };

    el.deleteBranchBtn.onclick = function() {
    const branchToDelete = sourceSelector.currentSelection.name;
    if (!branchToDelete) return;
    if (branchToDelete === repo.default_branch) {
        showToast('禁止删除默认分支');
        return;
    }
    
    const restoreInteractivity = () => {
        el.createBranchModal.style.pointerEvents = 'auto';
    };

    el.createBranchModal.style.pointerEvents = 'none';

    showDeleteModal(
        null,
        false,
        '确认删除分支',
        `确定要删除分支 "${branchToDelete}" 吗？此操作不可撤销`,
        async () => {
            try {
                const res = await fetch(`https://api.github.com/repos/${repo.full_name}/git/refs/heads/${branchToDelete}`, {
                    method: 'DELETE',
                    headers: { 'Authorization': `token ${state.token}` }
                });
                if (!res.ok) throw new Error((await res.json()).message || '删除分支失败');
                showToast(`分支 &nbsp;${branchToDelete}已成功删除,请等待服务器刷新`);
                if (state.currentRepo === repo.full_name) {
                    await fetchBranches(repo);
                }
            } catch (e) {
                showToast(`删除失败: ${e.message}`);
            } finally {
                restoreInteractivity();
            }
        },
        '确认删除',
        'btn-danger',
        restoreInteractivity
    );
};

    el.createBranchConfirm.onclick = async function() {
        const newBranchName = el.createBranchNameInput.value.trim();
        const sourceBranchSha = sourceSelector.currentSelection.sha;
        if (!newBranchName || !sourceBranchSha) return;
        this.disabled = true;
        this.classList.add('btn-processing');
        this.innerHTML = '创建中 <i class="fa fa-spinner fa-spin"></i>';
        try {
            const res = await fetch(`https://api.github.com/repos/${repo.full_name}/git/refs`, {
                method: 'POST',
                headers: { 'Authorization': `token ${state.token}`, 'Content-Type': 'application/json' },
                body: JSON.stringify({ ref: `refs/heads/${newBranchName}`, sha: sourceBranchSha })
            });
            if (!res.ok) throw new Error((await res.json()).message || '创建分支失败');
            showToast(`分支 &nbsp;${newBranchName}创建成功,请等待服务器刷新`);
            hideCreateBranchModal();
            await fetchRepos(true);
            if (state.currentRepo === repo.full_name) {
                await fetchBranches(repo);
                renderBranchSwitcher();
            }
        } catch (e) {
            showToast(`创建失败: ${e.message}`);
        } finally {
            this.disabled = false;
            this.classList.remove('btn-processing');
            this.innerHTML = '创建分支';
        }
    };
    uiStateStack.push(hideCreateBranchModal);
}

function showRenameRepoModal(repo) {
    const mainSiteName = state.user ? `${state.user.login}.github.io` : null;
    
    const extraSettingsContainer = document.getElementById('renameModalExtraSettings');
    extraSettingsContainer.innerHTML = '';
    el.renameWarn.textContent = '';
    el.renameWarn.style.display = 'none';

    const settingsHTML = `
        <textarea id="newRepoDesc" placeholder="仓库描述（可选）" style="margin-top: 0.6rem;">${repo.description || ''}</textarea>
        <div class="checkbox-container" style="margin: 0.6rem 0;">
            <input type="checkbox" id="newRepoPrivate">
            <label for="newRepoPrivate">公开仓库</label>
        </div>
    `;
    extraSettingsContainer.innerHTML = settingsHTML;

    el.renameTitle.querySelector('.modal-title-text').textContent = `重命名`;
    const descTextarea = document.getElementById('newRepoDesc');
    const privateCheckbox = document.getElementById('newRepoPrivate');
    el.renameInput.value = repo.name;
    privateCheckbox.checked = !repo.private;
    el.renameConfirm.disabled = true;

    descTextarea.addEventListener('input', function() {
        autoGrow(this);
    });
    autoGrow(descTextarea);

    const updateButtonState = () => {
        const newName = el.renameInput.value.trim();
        const newDesc = descTextarea.value.trim();
        
        el.renameWarn.style.display = 'none';
        el.renameWarn.classList.remove('text-red-400', 'text-orange-400');
        
        if (mainSiteName) {
            if (repo.name === mainSiteName && newName !== mainSiteName) {
                el.renameWarn.textContent = '提示：重命名主站仓库将导致您的主网站下线。';
                el.renameWarn.classList.add('text-orange-400');
                el.renameWarn.style.display = 'block';
            } else if (repo.name !== mainSiteName && newName === mainSiteName) {
                el.renameWarn.textContent = '提示：手动命名为主站仓库不会自动发布网站。推荐使用“设为主站”功能。';
                el.renameWarn.classList.add('text-orange-400');
                el.renameWarn.style.display = 'block';
            }
        }
        
        const nameChanged = newName !== repo.name;
        const descChanged = newDesc !== (repo.description || '');
        const visibilityChanged = privateCheckbox.checked === repo.private;
        const isModified = nameChanged || descChanged || visibilityChanged;
        
        el.renameConfirm.disabled = !isModified || !newName;
    };

    el.renameInput.oninput = updateButtonState;
    descTextarea.oninput = updateButtonState;
    privateCheckbox.onchange = updateButtonState;

    el.renameConfirm.onclick = async function() {
        const newName = el.renameInput.value.trim();
        const newDesc = descTextarea.value.trim();
        const isPrivate = !privateCheckbox.checked;

        const requestBody = { name: newName, description: newDesc, private: isPrivate };
        
        this.disabled = true;
        this.classList.add('btn-processing');
        this.innerHTML = '处理中 <i class="fa fa-spinner fa-spin"></i>';
        try {
            const res = await fetch(`https://api.github.com/repos/${repo.full_name}`, {
                method: 'PATCH',
                headers: { 'Authorization': `token ${state.token}`, 'Content-Type': 'application/json' },
                body: JSON.stringify(requestBody)
            });
            if (!res.ok) throw new Error((await res.json()).message || '修改失败');
            state.shouldAnimateList = true;
            showToast(`保存成功`);
            
            hideRenameModal();
            await fetchRepos(true, true);
        } catch (e) {
            showToast(`修改失败: ${e.message}`, 'error');
        } finally {
            this.disabled = false;
            this.classList.remove('btn-processing');
            this.innerHTML = '确认';
        }
    };

    el.renameModal.classList.remove('hidden');
    uiStateStack.push(hideRenameModal);
}

function hideRenameModal() {
    el.renameModal.classList.add('hidden');

    // 核心修改：恢复布局和样式，避免影响其他功能
    el.renameInput.after(el.renameWarn); // 把提示框移回输入框下面
    el.renameWarn.style.color = '';
    el.renameWarn.style.fontSize = '';
    el.renameWarn.style.marginBottom = '';
    el.renameWarn.classList.add('text-red-400'); // 把默认的红色加回来
    
    const index = uiStateStack.indexOf(hideRenameModal);
    if (index > -1) uiStateStack.splice(index, 1);
}


function hideDeleteModal() {
    el.deleteModal.classList.add('hidden');
    const index = uiStateStack.indexOf(hideDeleteModal);
    if (index > -1) uiStateStack.splice(index, 1);
}


function showDeleteModal(item, isDir = false, title, description, onConfirm, confirmButtonText = '确认删除', confirmButtonClass = 'btn-danger', onCancel) {
    el.deleteTitle.querySelector('.modal-title-text').textContent = title || '确认操作';
    if (item) {
        isDir = item.type === 'dir';
        el.deleteDesc.textContent = description || (isDir ? `确定要删除文件夹 "${item.name}" 吗？
        注意：如果文件夹内文件过多，可能需要较长时间并消耗大量API额度，可在仪表盘查看额度使用情况。` : `确定要删除文件 "${item.name}" 吗？`);
    } else {
        el.deleteDesc.innerHTML = description;
    }

    el.deleteConfirm.textContent = confirmButtonText;
    el.deleteConfirm.className = `btn ${confirmButtonClass}`; 

    el.deleteModal.classList.remove('hidden');
    
    el.deleteConfirm.onclick = async function() {
        const confirmBtn = this;
        confirmBtn.disabled = true;
        confirmBtn.classList.add('btn-processing');
        confirmBtn.innerHTML = '处理中 <i class="fa fa-spinner fa-spin"></i>';
        try {
            if (onConfirm) {
                await onConfirm();
            } else if (item) {
                await deleteSingleItem(item);
                showToast(`"${escapeHtml(item.name)}" 已删除`);
                state.shouldAnimateList = true;
                fetchFiles(true);
            }
        } catch (error) {
            showToast(`操作失败: ${error.message}`);
        } finally {
            hideDeleteModal();
            confirmBtn.disabled = false;
            confirmBtn.classList.remove('btn-processing');
            confirmBtn.innerHTML = confirmButtonText; 
        }
    };

    el.deleteCancel.onclick = function() {
        if (typeof onCancel === 'function') {
            onCancel();
        }
        hideDeleteModal();
    };

    uiStateStack.push(hideDeleteModal);
}

function goUp() {
    history.back();
}

function closeProxySettingsModal() {
    el.proxySettingsModal.classList.add('hidden');
    const index = uiStateStack.indexOf(closeProxySettingsModal);
    if (index > -1) uiStateStack.splice(index, 1);
}

function openProxySettingsModal() {
    updateProxySettingsUI();
    renderProxyList();
    el.proxySettingsModal.classList.remove('hidden');
    uiStateStack.push(closeProxySettingsModal);
}

function updateProxySettingsUI() {
    updateProxyUI();
    const isAutoSelectEnabled = !!state.autoSelectProxy;
    el.proxyAutoSelectToggle.classList.toggle('active', isAutoSelectEnabled);
    el.proxyAutoSelectToggle.title = isAutoSelectEnabled ? '自动优选代理已开启' : '自动优选代理已关闭';
}

async function testProxyConnectivity(proxyDetails, sampleCount = 4) {
    const testRawUrl = PROXY_TEST_URL;
    const timings = [];
    let successes = 0;

    const singleTest = async () => {
        let proxiedTestUrl = '';
        const proxyInputUrl = (proxyDetails.url || '').trim();
        const proxyDomain = getDomainFromUrl(proxyInputUrl);

        if (!proxyInputUrl) return { ok: false, ms: Infinity };

        if (proxyDetails.type === 'prefix') {
            let base = proxyInputUrl;
            if (!base.endsWith('/')) base += '/';
            proxiedTestUrl = base + testRawUrl;
        } else if (proxyDetails.type === 'raw_domain_replace') {
            proxiedTestUrl = testRawUrl.replace(/^(https?:\/\/raw\.)githubusercontent\.com(\/.*)$/i, `$1${proxyDomain}$2`);
            if (!proxiedTestUrl.startsWith('http')) proxiedTestUrl = 'https://' + proxiedTestUrl;
        } else {
             return { ok: false, ms: Infinity };
        }

        const start = performance.now();
        try {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 3000);
            const r = await fetch(proxiedTestUrl, { method: 'GET', cache: 'no-store', signal: controller.signal });
            clearTimeout(timeoutId);
            if (!r.ok) return { ok: false, ms: Infinity };
            await r.text();
            return { ok: true, ms: Math.round(performance.now() - start) };
        } catch (e) {
            return { ok: false, ms: Infinity };
        }
    };

    for (let i = 0; i < sampleCount; i++) {
        const result = await singleTest();
        if (result.ok) {
            timings.push(result.ms);
            successes++;
        }
        if (i < sampleCount - 1) await new Promise(res => setTimeout(res, 50));
    }

    const successRate = successes / sampleCount;
    if (successes === 0) {
        return {
            averageLatency: Infinity,
            jitter: Infinity,
            successRate: 0
        };
    }

    timings.sort((a, b) => a - b);
    if (timings.length > 1) {
       timings.pop();
    }

    const averageLatency = timings.reduce((acc, t) => acc + t, 0) / timings.length;

    const mean = averageLatency;
    const variance = timings.reduce((acc, t) => acc + Math.pow(t - mean, 2), 0) / timings.length;
    const jitter = Math.sqrt(variance);

    return {
        averageLatency: Math.round(averageLatency),
        jitter: Math.round(jitter),
        successRate: successRate
    };
}
async function determineBestProxyTypeAndTest(proxyUrl) {
    const testProxyConnectivity_single = async (proxyDetails) => {
        const testRawUrl = PROXY_TEST_URL;
        let proxiedTestUrl = '';
        const proxyInputUrl = (proxyDetails.url || '').trim();
        const proxyDomain = getDomainFromUrl(proxyInputUrl);
        if (!proxyInputUrl) return { ok: false, ms: null, err: 'URL为空', type: proxyDetails.type };
        if (proxyDetails.type === 'prefix') {
            let base = proxyInputUrl;
            if (!base.endsWith('/')) base += '/';
            proxiedTestUrl = base + testRawUrl;
        } else if (proxyDetails.type === 'raw_domain_replace') {
            proxiedTestUrl = testRawUrl.replace(/^(https?:\/\/raw\.)githubusercontent\.com(\/.*)$/i, `$1${proxyDomain}$2`);
            if (!proxiedTestUrl.startsWith('http')) proxiedTestUrl = 'https://' + proxiedTestUrl;
        } else {
            return { ok: false, ms: null, err: '未知测试类型', type: proxyDetails.type };
        }
        const start = performance.now();
        try {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 1000);
            const r = await fetch(proxiedTestUrl, { method: 'GET', cache: 'no-store', signal: controller.signal });
            clearTimeout(timeoutId);
            if (!r.ok) {
                return { ok: false, ms: null, err: '连接失败 (404)', type: proxyDetails.type };
            }
            await r.text();
            return { ok: true, ms: Math.round(performance.now() - start), err: null, type: proxyDetails.type };
        } catch (e) {
            let errorMsg = '连接失败 (404)';
            if (e.name === 'AbortError') errorMsg = '连接失败 (超时)';
            else if (e.message.includes('Failed to fetch')) errorMsg = '连接失败 (网络错误)';
            return { ok: false, ms: null, err: errorMsg, type: proxyDetails.type };
        }
    };

    const results = await Promise.all([
        testProxyConnectivity_single({ url: proxyUrl, type: 'prefix' }),
        testProxyConnectivity_single({ url: proxyUrl, type: 'raw_domain_replace' })
    ]);
    let bestResult = { ok: false, ms: null, err: '所有模式均失败', type: null };
    let prefixResult = results[0];
    let rawDomainResult = results[1];
    if (prefixResult.ok && rawDomainResult.ok) {
        bestResult = prefixResult.ms < rawDomainResult.ms ? prefixResult : rawDomainResult;
    } else if (prefixResult.ok) {
        bestResult = prefixResult;
    } else if (rawDomainResult.ok) {
        bestResult = rawDomainResult;
    } else {
        bestResult = prefixResult;
    }
    return bestResult;
}

function renderProxyList() {
    const container = el.proxyListContainer;
    container.innerHTML = '';
    if (state.proxies.length === 0) {
        el.proxyListEmpty.classList.remove('hidden');
        el.proxyTestAllBtn.disabled = true;
        el.proxyClearAllBtn.disabled = true;
        el.proxyAutoSelectToggle.disabled = true;
    } else {
        el.proxyListEmpty.classList.add('hidden');
        el.proxyTestAllBtn.disabled = false;
        el.proxyClearAllBtn.disabled = false;
        el.proxyAutoSelectToggle.disabled = false;
    }
    state.proxies.forEach((proxy, index) => {
        const proxyItem = document.createElement('div');
        proxyItem.className = 'proxy-item';
        if (index === state.activeProxyIndex) proxyItem.classList.add('active');
        let statusClass = 'gray', latencyText = '未测试';
        if (proxy.status === 'testing') {
            latencyText = `<span class="spinner-small"></span>`;
        } else if (proxy.status === 'ok') {
            latencyText = `${proxy.latency} ms`;
            if (proxy.latency <= 500) statusClass = 'green';
            else if (proxy.latency <= 2000) statusClass = 'yellow';
            else statusClass = 'red';
        } else if (proxy.status === 'fail') {
            statusClass = 'red';
            latencyText = '失败';
        }
        proxyItem.innerHTML = `
            <div class="proxy-identity">
                <span class="status-dot ${statusClass}"></span>
                <span class="proxy-url" title="${proxy.url || ''}">${getDomainFromUrl(proxy.url) || '无效URL'}</span>
            </div>
            <div class="proxy-status-actions">
                <span class="latency-text ${statusClass}">${latencyText}</span>
                <div class="proxy-actions">
                    <button class="btn-icon-sm edit-proxy-btn" data-index="${index}" title="编辑"><i class="fa fa-pencil"></i></button>
                    <button class="btn-icon-sm delete-proxy-btn danger" data-index="${index}" title="删除"><i class="fa-regular fa-trash-can"></i></button>
                </div>
            </div>
        `;
        proxyItem.addEventListener('click', (e) => {
            if (e.target.closest('.edit-proxy-btn, .delete-proxy-btn')) return;
            if (index === state.activeProxyIndex) return;
            setActiveProxy(index);
        });
        container.appendChild(proxyItem);
    });
    container.querySelectorAll('.edit-proxy-btn').forEach(button => {
        button.onclick = (e) => { e.stopPropagation(); openAddEditProxyModal(parseInt(e.currentTarget.dataset.index)); };
    });
    container.querySelectorAll('.delete-proxy-btn').forEach(button => {
        button.onclick = (e) => { e.stopPropagation(); showConfirmDeleteProxyModal(parseInt(e.currentTarget.dataset.index)); };
    });
    saveProxyConfig();
}

function saveProxyConfig() {
    localStorage.setItem('proxies', JSON.stringify(state.proxies));
    localStorage.setItem('active_proxy_index', JSON.stringify(state.activeProxyIndex));
    localStorage.setItem('proxy_global_enable', JSON.stringify(state.proxyGlobalEnable));
    updateProxyUI();
}

function openAddEditProxyModal(index = null) {
    state.editingProxyIndex = index;
    const modal = el.addEditProxyModal;
    const titleTextSpan = el.addEditProxyTitle.querySelector('.modal-title-text');
    const urlInput = el.addEditProxyUrlInput;
    const saveBtn = el.addEditProxySaveBtn;
    const cancelBtn = document.getElementById('addEditProxyCancelBtn');
    urlInput.value = '';
    el.addEditProxyError.style.display = 'none';
    if (index !== null && state.proxies[index]) {
        const proxy = state.proxies[index];
        titleTextSpan.textContent = '编辑代理';
        urlInput.value = proxy.url;
        urlInput.placeholder = '修改代理地址';
    } else {
        titleTextSpan.textContent = '添加新代理';
        urlInput.placeholder = '例如：https://ghproxy.net/';
    }
    cancelBtn.onclick = closeAddEditProxyModal;
    saveBtn.onclick = null; 
    modal.classList.remove('hidden');
    validateAddEditProxyInput();
    uiStateStack.push(closeAddEditProxyModal);
}

function closeAddEditProxyModal() {
    el.addEditProxyModal.classList.add('hidden');
    state.editingProxyIndex = null;
    el.addEditProxySaveBtn.disabled = false;
    el.addEditProxySaveBtn.classList.remove('btn-processing');
    el.addEditProxySaveBtn.innerHTML = '保存';
    const index = uiStateStack.indexOf(closeAddEditProxyModal);
    if (index > -1) uiStateStack.splice(index, 1);
}

function validateAddEditProxyInput() {
    const url = el.addEditProxyUrlInput.value.trim();
    const saveBtn = el.addEditProxySaveBtn;
    let fullUrl = url;
    if (url && !/^https?:\/\//i.test(fullUrl)) fullUrl = 'https://' + fullUrl;
    const isDuplicate = state.proxies.some((proxy, index) => {
        if (state.editingProxyIndex !== null && index === state.editingProxyIndex) return false;
        let existingUrl = proxy.url;
        if (!/^https?:\/\//i.test(existingUrl)) existingUrl = 'https://' + existingUrl;
        return existingUrl === fullUrl;
    });
    if (!url) {
        saveBtn.disabled = true;
        saveBtn.onclick = null;
    } else if (isDuplicate) {
        saveBtn.disabled = true;
        saveBtn.onclick = () => { showToast('该代理已存在'); };
    } else {
        saveBtn.disabled = false;
        saveBtn.onclick = handleSaveProxy;
    }
    return !isDuplicate && !!url;
}

async function handleSaveProxy() {
    let url = el.addEditProxyUrlInput.value.trim();
    if (url && !/^https?:\/\//i.test(url)) url = 'https://' + url;
    const isEditing = state.editingProxyIndex !== null;
    let indexToTest;
    if (isEditing) {
        indexToTest = state.editingProxyIndex;
        const proxyToEdit = state.proxies[indexToTest];
        proxyToEdit.url = url;
        proxyToEdit.status = 'testing';
        proxyToEdit.latency = null;
        proxyToEdit.err = null;
        proxyToEdit.type = null;
        showToast('代理已更新，正在重新测试...');
    } else {
        const newProxy = { url: url, status: 'testing', latency: null, err: null, type: null };
        state.proxies.unshift(newProxy); 
        indexToTest = 0;
        showToast('代理已添加，正在后台测试...');
    }
    closeAddEditProxyModal();
    renderProxyList();
    const proxyToTest = state.proxies[indexToTest];
    if (!proxyToTest) return;
    const result = await determineBestProxyTypeAndTest(proxyToTest.url);
    proxyToTest.latency = result.ms;
    proxyToTest.status = result.ok ? 'ok' : 'fail';
    proxyToTest.err = result.err;
    proxyToTest.type = result.type;
    renderProxyList();
}

function showConfirmDeleteProxyModal(index) {
    const proxy = state.proxies[index];
    el.confirmDeleteProxyTitle.querySelector('.modal-title-text').textContent = '确认删除代理';
    el.confirmDeleteProxyMessage.innerHTML = `确定要删除代理 <strong>"${escapeHtml(proxy.url)}"</strong> 吗？此操作不可撤销。`;
    el.confirmDeleteProxyModal.classList.remove('hidden');
    el.confirmDeleteProxyConfirmBtn.onclick = null;
    el.confirmDeleteProxyCancelBtn.onclick = null;
    el.confirmDeleteProxyConfirmBtn.onclick = async () => {
        el.confirmDeleteProxyConfirmBtn.disabled = true;
        el.confirmDeleteProxyConfirmBtn.classList.add('btn-processing');
        el.confirmDeleteProxyConfirmBtn.innerHTML = `删除中 <span class="spinner-small"></span>`;
        try {
            await deleteProxy(index);
            hideConfirmDeleteProxyModal();
        } finally {
            el.confirmDeleteProxyConfirmBtn.disabled = false;
            el.confirmDeleteProxyConfirmBtn.classList.remove('btn-processing');
            el.confirmDeleteProxyConfirmBtn.innerHTML = '确认删除';
        }
    };
    el.confirmDeleteProxyCancelBtn.onclick = hideConfirmDeleteProxyModal;
    uiStateStack.push(hideConfirmDeleteProxyModal);
}

function hideConfirmDeleteProxyModal() {
    el.confirmDeleteProxyModal.classList.add('hidden');
    const index = uiStateStack.indexOf(hideConfirmDeleteProxyModal);
    if (index > -1) uiStateStack.splice(index, 1);
}

function showConfirmClearAllProxiesModal() {
    el.confirmClearAllProxiesModal.classList.remove('hidden');
    el.clearAllProxiesConfirmBtn.disabled = false;
    el.clearAllProxiesConfirmBtn.innerHTML = '确认清空';
    uiStateStack.push(hideConfirmClearAllProxiesModal);
}

function hideConfirmClearAllProxiesModal() {
    el.confirmClearAllProxiesModal.classList.add('hidden');
    const index = uiStateStack.indexOf(hideConfirmClearAllProxiesModal);
    if (index > -1) uiStateStack.splice(index, 1);
}

async function clearAllProxiesConfirmed() {
    el.clearAllProxiesConfirmBtn.disabled = true;
    el.clearAllProxiesConfirmBtn.classList.add('btn-processing');
    el.clearAllProxiesConfirmBtn.innerHTML = `清空中 <span class="spinner-small"></span>`;
    state.proxies = [];
    state.activeProxyIndex = -1;
    showToast('所有代理已清空');
    hideConfirmClearAllProxiesModal();
    renderProxyList();
    el.clearAllProxiesConfirmBtn.disabled = false;
    el.clearAllProxiesConfirmBtn.classList.remove('btn-processing');
    el.clearAllProxiesConfirmBtn.innerHTML = '确认清空';
}

async function deleteProxy(index) {
    state.proxies.splice(index, 1);
    if (state.activeProxyIndex === index) {
        state.activeProxyIndex = state.proxies.length > 0 ? 0 : -1;
    } else if (state.activeProxyIndex > index) {
        state.activeProxyIndex--;
    }
    showToast('代理已删除');
    renderProxyList();
}

function setActiveProxy(index, showNotification = true) {
    if (index < 0 || index >= state.proxies.length) return;
    state.proxyGlobalEnable = true;
    if (state.activeProxyIndex === index) {
        saveProxyConfig();
        return;
    }
    state.activeProxyIndex = index;
    if (showNotification) {
        showToast(`已切换全局代理`);
    }
    renderProxyList();
    if (state.currentRepo) {
        state.shouldAnimateList = false;
        //代理平滑更新fetchFiles();
    }
}



async function testAllProxies(showInitialToast = true) {
    if (state.proxies.length === 0) {
        if (showInitialToast) showToast('没有代理可供测试', 'info');
        return;
    }
    el.proxyTestAllBtn.disabled = true;
    el.proxyTestAllSpinner.classList.remove('hidden');
    el.proxyTestAllBoltIcon.classList.add('hidden');
    
    if (showInitialToast) {
        showToast(`正在测试 ${state.proxies.length} 个代理...`);
    }

    state.proxies.forEach(proxy => {
        proxy.status = 'testing';
        proxy.latency = null;
        proxy.err = null;
        proxy.type = null;
    });
    renderProxyList();
    const testPromises = state.proxies.map(proxy => determineBestProxyTypeAndTest(proxy.url));
    const results = await Promise.allSettled(testPromises);
    results.forEach((result, index) => {
        if (result.status === 'fulfilled') {
            const data = result.value;
            state.proxies[index].latency = data.ms;
            state.proxies[index].status = data.ok ? 'ok' : 'fail';
            state.proxies[index].err = data.err;
            state.proxies[index].type = data.type;
        } else {
            state.proxies[index].status = 'fail';
            state.proxies[index].err = '测试脚本错误';
        }
    });
    renderProxyList();
    el.proxyTestAllBtn.disabled = false;
    el.proxyTestAllBoltIcon.classList.remove('hidden');
    el.proxyTestAllSpinner.classList.add('hidden');
}

async function clearCache() {
    localStorage.removeItem('cached_repos');
    localStorage.removeItem('repos_cache_time');
    state.fileCache.clear();
    showToast('缓存已清除');
    if (state.currentRepo) {
        await fetchFiles(true);
    } else {
        await fetchRepos();
    }
    hideMainMenuPopup();
}



async function importProxiesFromUrl() {
    const importButton = el.importBtn;
    const importIcon = importButton.querySelector('.fa-cloud-download');
    const importSpinner = el.importSpinner;

    importButton.disabled = true;
    if (importIcon) importIcon.classList.add('hidden');
    if (importSpinner) importSpinner.classList.remove('hidden');
    showToast('正在导入并测试代理...', 'info');

    try {
        const response = await fetch(PROXY_TEST_URL + '?t=' + Date.now(), { cache: 'no-store' });
        if (!response.ok) throw new Error(`获取代理列表失败 (HTTP ${response.status})`);
        
        const text = await response.text();
        const urls = text.split('\n').map(url => url.trim()).filter(url => url && url.length > 5);
        
        if (urls.length > 0) {
            const newUrls = urls.filter(u => !state.proxies.some(p => p.url && p.url.replace(/\/$/, '') === u.replace(/\/$/, '')));
            if (newUrls.length > 0) {
                const newProxies = newUrls.map(url => ({ url, status: null, latency: null, type: null }));
                state.proxies.push(...newProxies);
                saveProxyConfig();
                renderProxyList();
            }
        }

        await testAllProxies(false);

        let bestLatency = Infinity;
        let bestIndex = -1;
        state.proxies.forEach((proxy, index) => {
            if (proxy.status === 'ok' && proxy.latency < bestLatency) {
                bestLatency = proxy.latency;
                bestIndex = index;
            }
        });

        if (bestIndex !== -1) {
            setActiveProxy(bestIndex, false);
            showToast(`操作完成，已切换至最低延迟节点: ${getDomainFromUrl(state.proxies[bestIndex].url)}`, 'success');
        } else {
            showToast('所有代理均测试失败', 'error');
        }

    } catch (error) {
        showToast(`操作失败: ${error.message}`, 'error');
        console.error("导入或测试时发生错误:", error);
    } finally {
        importButton.disabled = false;
        if (importIcon) importIcon.classList.remove('hidden');
        if (importSpinner) importSpinner.classList.add('hidden');
    }
}




async function findAndSetBestProxy(manual = false) {
    const autoSelectButton = el.proxyAutoSelectToggle;
    if (manual) {
        autoSelectButton.disabled = true;
        showToast('智能优选已启动，正在分析当前中', 'info', 2000);
        showToast('往后每次进入将会在后台自动执行智能优选代理.', 'info', 3000);
    }

    if (state.proxies.length === 0) {
        if (!manual) showToast('首次启动，自动配置代理...', 'info');
        
        try {
            const response = await fetch(PROXY_TEST_URL + '?t=' + Date.now(), { cache: 'no-store' });
            if (!response.ok) throw new Error(`获取代理列表失败`);
            const text = await response.text();
            const urls = text.split('\n').map(url => url.trim()).filter(url => url && url.length > 5);
            if (urls.length > 0) {
                state.proxies.push(...urls.map(url => ({ url, status: null, latency: null, type: null })));
                saveProxyConfig();
                renderProxyList();
            } else {
                 throw new Error("订阅链接为空");
            }
        } catch (error) {
            showToast(`自动导入代理失败: ${error.message}`, 'error');
            if (manual) autoSelectButton.disabled = false;
            return;
        }
    }
    
    const BATCH_SIZE = 3;
    const allProxies = [...state.proxies];
    const detailedResults = [];

    for (let i = 0; i < allProxies.length; i += BATCH_SIZE) {
        const batch = allProxies.slice(i, i + BATCH_SIZE);
        const batchPromises = batch.map(async (proxy) => {
            const typeResult = await determineBestProxyTypeAndTest(proxy.url);
            if (!typeResult.ok) {
                return { ...proxy, testResult: { averageLatency: Infinity, jitter: Infinity, successRate: 0 } };
            }
            proxy.type = typeResult.type;
            const testResult = await testProxyConnectivity(proxy, 4);
            return { ...proxy, testResult };
        });
        const batchResults = await Promise.all(batchPromises);
        detailedResults.push(...batchResults);
    }

    const usableProxies = detailedResults.filter(p => p.testResult.successRate > 0.5);

    if (usableProxies.length === 0) {
        showToast('所有代理均不可用或超时', 'error');
    } else {
        usableProxies.forEach(p => {
            p.score = p.testResult.averageLatency + (p.testResult.jitter * 2);
            if (p.testResult.successRate < 1) p.score += 500;
        });

        usableProxies.sort((a, b) => a.score - b.score);
        const bestProxy = usableProxies[0];
        const bestProxyIndex = state.proxies.findIndex(p => p.url === bestProxy.url);
        
        detailedResults.forEach((result) => {
            const originalProxyIndex = state.proxies.findIndex(p => p.url === result.url);
            if (originalProxyIndex !== -1) {
                state.proxies[originalProxyIndex].status = result.testResult.successRate > 0.5 ? 'ok' : 'fail';
                state.proxies[originalProxyIndex].latency = result.testResult.averageLatency;
                state.proxies[originalProxyIndex].type = result.type;
            }
        });

        renderProxyList();
        setActiveProxy(bestProxyIndex, false);
       // showToast(`代理优选完成: ${getDomainFromUrl(bestProxy.url)} (${bestProxy.testResult.averageLatency}ms)`, 'success');
    }
    
    if (manual) autoSelectButton.disabled = false;
}







async function handleRefreshApiStatus() {
    const refreshBtn = el.refreshApiStatusBtn;
    const icon = refreshBtn.querySelector('i');
    refreshBtn.disabled = true;
    icon.classList.add('fa-spin-custom');
    try {
        await fetchAndRenderApiStatus();
    } catch (error) {
        console.error("手动刷新API状态时出错:", error);
    } finally {
        refreshBtn.disabled = false;
        icon.classList.remove('fa-spin-custom');
    }
}

const closeMultiSelect = () => toggleMultiSelectMode(false);

function toggleMultiSelectMode(enable) {
    state.isMultiSelectMode = enable;
    const fileListEl = el.fileList;
    const toggleBtn = el.multiSelectToggleBtn;
    if (enable) {
        fileListEl.classList.add('multi-select-mode');
        el.multiSelectBar.classList.add('active');
        toggleBtn.classList.add('active');
        toggleBtn.title = '取消多选';
        uiStateStack.push(closeMultiSelect);
    } else {
        fileListEl.classList.remove('multi-select-mode');
        el.multiSelectBar.classList.remove('active');
        toggleBtn.classList.remove('active');
        toggleBtn.title = '多项选择';
        fileListEl.querySelectorAll('.file-item.selected').forEach(item => {
            item.classList.remove('selected');
        });
        state.selectedItems.clear();
        const index = uiStateStack.indexOf(closeMultiSelect);
        if (index > -1) uiStateStack.splice(index, 1);
    }
    updateActionBar();
}

function updateActionBar() {
    const count = state.selectedItems.size;
    const total = state.displayFiles.length;
    el.selectedCountSpan.textContent = count > 0 ? `已选 ${count} / ${total} 项` : '未选择';
    el.downloadBtn.disabled = count === 0;
    el.deleteBtn.disabled = count === 0;
    el.invertSelectBtn.disabled = count === 0;
    const selectAllIcon = el.selectAllBtn.querySelector('i');
    if (total > 0 && count === total) {
        selectAllIcon.className = 'fa-regular fa-square-minus';
        el.selectAllBtn.title = '取消全选';
    } else {
        selectAllIcon.className = 'fa-regular fa-square-check';
        el.selectAllBtn.title = '全选';
    }
}



async function downloadSelectedItemsAsZip() {
    if (state.selectedItems.size === 0) return;
    showToast(`正在准备打包 ${state.selectedItems.size} 个项目...`);
    const zip = new JSZip();
    const [owner, repo] = state.currentRepo.split('/');
    const fetchFileContent = async (path) => {
        try {
            const url = `https://api.github.com/repos/${owner}/${repo}/contents/${path}?ref=${state.currentBranch}`;
            const res = await fetch(url, { headers: { 'Authorization': `token ${state.token}` } });
            const data = await res.json();
            return atob(data.content);
        } catch (error) {
            console.error(`无法获取文件内容: ${path}`, error);
            return null;
        }
    };
    const addFolderToZip = async (folderPath, zipFolder) => {
        const url = `https://api.github.com/repos/${owner}/${repo}/contents/${folderPath}?ref=${state.currentBranch}`;
        const res = await fetch(url, { headers: { 'Authorization': `token ${state.token}` } });
        const items = await res.json();
        for (const item of items) {
            if (item.type === 'file') {
                const content = await fetchFileContent(item.path);
                if (content !== null) zipFolder.file(item.name, content, { binary: true });
            } else if (item.type === 'dir') {
                await addFolderToZip(item.path, zipFolder.folder(item.name));
            }
        }
    };
    const rootFiles = state.files.filter(file => state.selectedItems.has(file.path));
    for (const item of rootFiles) {
        if (item.type === 'file') {
            const content = await fetchFileContent(item.path);
            if (content !== null) zip.file(item.name, content, { binary: true });
        } else if (item.type === 'dir') {
            await addFolderToZip(item.path, zip.folder(item.name));
        }
    }
    try {
        const content = await zip.generateAsync({ type: "blob" });
        const objectUrl = URL.createObjectURL(content);
        const a = document.createElement('a');
        a.href = objectUrl;
        a.download = `${repo}-${state.currentBranch}-selection.zip`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(objectUrl);
        showToast('打包完成，下载已开始！');
    } catch(e) {
        showToast(`打包失败: ${e.message}`);
    }
}

async function downloadFolderAsZip(folderItem) {
    if (folderItem.type !== 'dir') return;
    showToast(`正在打包文件夹 &nbsp;${folderItem.name}&nbsp;`);
    const zip = new JSZip();
    const [owner, repo] = state.currentRepo.split('/');
    const fetchFolderContents = async (path, zipFolder) => {
        try {
            const url = `https://api.github.com/repos/${owner}/${repo}/contents/${path}?ref=${state.currentBranch}`;
            const res = await fetch(url, { headers: { 'Authorization': `token ${state.token}` } });
            if (!res.ok) throw new Error(`无法获取文件夹内容: ${path}`);
            const items = await res.json();
            for (const item of items) {
                if (item.type === 'file') {
                    const fileRes = await fetch(item.url, { headers: { 'Authorization': `token ${state.token}` } });
                    if (!fileRes.ok) continue;
                    const fileData = await fileRes.json();
                    if (fileData.content) zipFolder.file(item.name, atob(fileData.content), { binary: true });
                } else if (item.type === 'dir') {
                    await fetchFolderContents(item.path, zipFolder.folder(item.name));
                }
            }
        } catch (error) {
            console.error(`处理文件夹 &nbsp;${path}&nbsp; 失败:`, error);
            showToast(`打包文件夹出错: ${folderItem.name} 遇到问题`);
        }
    };
    try {
        await fetchFolderContents(folderItem.path, zip.folder(folderItem.name));
        const content = await zip.generateAsync({ type: "blob" });
        const objectUrl = URL.createObjectURL(content);
        const a = document.createElement('a');
        a.href = objectUrl;
        a.download = `${folderItem.name}.zip`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(objectUrl);
        showToast(`文件夹 &nbsp;${folderItem.name}.zip&nbsp; 已开始下载！`);
    } catch (e) {
        showToast(`打包失败: ${e.message}`);
    }
}

function saveContextMenuSettings() {
    localStorage.setItem('context_menu_visibility', JSON.stringify(state.contextMenuVisibility));
}

function loadContextMenuSettings() {
    const savedSettings = JSON.parse(localStorage.getItem('context_menu_visibility'));
    state.contextMenuVisibility = JSON.parse(JSON.stringify(DEFAULT_MENU_VISIBILITY));
    if (savedSettings) {
        for (const category in state.contextMenuVisibility) {
            if (savedSettings[category]) {
                for (const action in state.contextMenuVisibility[category]) {
                    if (savedSettings[category][action] !== undefined) {
                        state.contextMenuVisibility[category][action] = savedSettings[category][action];
                    }
                }
            }
        }
    }
}

function renderContextMenuSettings(category) {
    const content = el.contextMenuSettingsContent;
    content.innerHTML = '';
    const settings = state.contextMenuVisibility[category];
    const definitions = CONTEXT_MENU_DEFINITIONS[category];
    definitions.forEach(item => {
        if (category === 'repo' && (item.action === 'copyMainSiteLink')) return;
        let labelText = item.text;
        if (category === 'repo' && item.action === 'setAsMainSite') {
            labelText = '主站链接';
        }
        const isVisible = settings[item.action];
        const settingItem = document.createElement('div');
        settingItem.className = 'setting-item';
        settingItem.innerHTML = `
            <label for="toggle-${category}-${item.action}">${labelText}</label>
            <label class="switch">
                <input type="checkbox" id="toggle-${category}-${item.action}" data-category="${category}" data-action="${item.action}" ${isVisible ? 'checked' : ''}>
                <span class="slider round"></span>
            </label>
        `;
        content.appendChild(settingItem);
    });
}

function hideContextMenuSettingsModal() {
    el.contextMenuSettingsModal.classList.add('hidden');
    const index = uiStateStack.indexOf(hideContextMenuSettingsModal);
    if (index > -1) uiStateStack.splice(index, 1);
}

function openContextMenuSettingsModal() {
    el.contextMenuSettingsModal.classList.remove('hidden');
    const activeTab = el.contextMenuSettingsModal.querySelector('.context-menu-settings-tabs .tab-btn.active');
    if (activeTab) {
        const activeCategory = activeTab.dataset.tab;
        renderContextMenuSettings(activeCategory);
    } else {
        renderContextMenuSettings('file');
    }
    uiStateStack.push(hideContextMenuSettingsModal);
}

function loadLocalAvatar() {
    const savedAvatar = localStorage.getItem('user_avatar');
    if (savedAvatar) state.localAvatar = savedAvatar;
}

function handleAvatarChange(event) {
    const file = event.target.files[0];
    if (!file) return;
    if (!file.type.startsWith('image/')) {
        showToast('请选择一个图片文件');
        return;
    }
    if (file.size > 2 * 1024 * 1024) {
        showToast('图片文件不能超过 2MB');
        return;
    }
    const reader = new FileReader();
    reader.onload = () => {
        const base64String = reader.result;
        localStorage.setItem('user_avatar', base64String);
        state.localAvatar = base64String;
        updateUserUI();
        showToast('本地头像更新成功');
    };
    reader.onerror = () => { showToast('读取文件失败'); };
    reader.readAsDataURL(file);
}

function hideMediaPreview() {
    const preview = document.getElementById('mediaPreview');
    if (!preview.classList.contains('hidden')) {
        preview.classList.add('hidden');
        document.getElementById('mediaPreviewImg').src = '';
        const video = document.getElementById('mediaPreviewVideo');
        video.src = '';
        video.pause();
        const index = uiStateStack.indexOf(hideMediaPreview);
        if (index > -1) uiStateStack.splice(index, 1);
    }
}

function initMediaPreview() {
    const preview = document.getElementById('mediaPreview');
    const img = document.getElementById('mediaPreviewImg');
    const video = document.getElementById('mediaPreviewVideo');
    const audioExts = ['mp3', 'wav', 'ogg', 'flac', 'm4a'];
    let audioManager = {
        audio: null,
        currentUrl: '',
        currentName: '',
        isPlaying: false,
        init() {
            if (!this.audio) {
                this.audio = new Audio();
                this.audio.preload = 'none';
                this.audio.crossOrigin = 'anonymous';
                this.audio.addEventListener('play', () => { this.isPlaying = true; });
                this.audio.addEventListener('pause', () => { this.isPlaying = false; });
                this.audio.addEventListener('ended', () => { this.isPlaying = false; showToast(`播放完成: ${this.currentName}`); });
                this.audio.addEventListener('error', (e) => { this.isPlaying = false; showToast('播放出错'); console.error('Audio error:', e); });
                document.addEventListener('visibilitychange', () => {
                    if (!document.hidden && this.isPlaying && this.audio.paused) {
                        this.audio.play().catch(() => {});
                    }
                });
            }
        },
        play(url, name) {
            this.init();
            showToast(`正在播放: ${name}`);
            if (this.currentUrl === url) {
                if (this.audio.paused) { this.audio.play().catch(() => { showToast('播放失败'); }); }
                else { this.audio.pause(); showToast(`已暂停: ${name}`); }
                return;
            }
            this.currentUrl = url;
            this.currentName = name;
            this.audio.src = url;
            const playPromise = this.audio.play();
            if (playPromise !== undefined) {
                playPromise.catch((error) => { console.log('Autoplay prevented:', error); });
            }
        }
    };
    preview.onclick = function(e) {
        if (e) {
            e.stopPropagation();
            e.preventDefault();
        }
        hideMediaPreview();
    };
    document.getElementById('fileList').addEventListener('click', function(e) {
        if (state.isMultiSelectMode) return;
        if (e.target.classList.contains('multi-select-checkbox')) return;
        if (e.target.closest('.flex.gap-1,button')) return;
        const item = e.target.closest('.file-item');
        if (!item) return;
        const name = item.querySelector('.file-name') ? item.querySelector('.file-name').textContent : '';
        const ext = name.split('.').pop()?.toLowerCase();
        const file = state.files.find(f => f.name === name);
        if (!file || file.type !== 'file') return;
        const raw = file.download_url ? file.download_url : file.html_url.replace('github.com', 'raw.githubusercontent.com').replace('/blob/', '/');
        const url = getProxiedUrl(raw);
        if (audioExts.includes(ext)) {
            const nameWithoutExt = name.substring(0, name.lastIndexOf('.'));
            audioManager.play(url, nameWithoutExt);
            e.preventDefault();
            e.stopPropagation();
            return;
        }
        const openPreview = () => {
            preview.classList.remove('hidden');
            uiStateStack.push(hideMediaPreview);
            e.preventDefault();
            e.stopPropagation();
        };
        if (['png', 'jpg', 'jpeg', 'gif', 'webp', 'bmp', 'svg'].includes(ext)) {
            img.src = url;
            img.style.display = '';
            video.style.display = 'none';
            openPreview();
            return;
        }
        if (['mp4', 'webm', 'ogg', 'mov', 'avi', 'mkv'].includes(ext)) {
            video.src = url;
            video.style.display = '';
            img.style.display = 'none';
            openPreview();
            video.load();
            return;
        }
    }, true);
}

function hideCreateRepoModal() {
    el.createRepoModal.classList.add('hidden');
    const index = uiStateStack.indexOf(hideCreateRepoModal);
    if (index > -1) uiStateStack.splice(index, 1);
}

function showCreateRepoModal() {
    el.createRepoNameInput.value = '';
    el.createRepoDescInput.value = '';
    el.createRepoPrivate.checked = true;
    el.repoNameError.style.display = 'none';
    el.createRepoModal.classList.remove('hidden');
    el.createRepoConfirm.disabled = true;
    function validateRepoName(name) {
        if (/[\u4e00-\u9fa5]/.test(name)) return '仓库名称不能包含中文字符';
        if (name.length > 100) return '仓库名称不能超过100个字符';
        if (name.startsWith('.') || name.endsWith('.')) return '仓库名称不能以点号开头或结尾';
        return null;
    }
    el.createRepoNameInput.oninput = function() {
        this.value = this.value.replace(/[\u4e00-\u9fa5]/g, '');
        const name = el.createRepoNameInput.value.trim();
        const error = validateRepoName(name);
        if (error) {
            el.repoNameError.textContent = error;
            el.repoNameError.style.display = 'block';
            el.createRepoConfirm.disabled = true;
        } else {
            el.repoNameError.style.display = 'none';
            el.createRepoConfirm.disabled = !name;
        }
    };
    el.createRepoConfirm.onclick = async function() {
        const name = el.createRepoNameInput.value.trim();
        const description = el.createRepoDescInput.value.trim();
        const isPrivate = !el.createRepoPrivate.checked;
        const error = validateRepoName(name);
        if (error || !name) return;
        el.createRepoConfirm.disabled = true;
        el.createRepoConfirm.classList.add('btn-processing');
        el.createRepoConfirm.innerHTML = '创建中 <i class="fa fa-spinner fa-spin"></i>';
        try {
            const res = await fetch('https://api.github.com/user/repos', {
                method: 'POST',
                headers: { 'Authorization': `token ${state.token}`, 'Content-Type': 'application/json', 'User-Agent': 'Mozilla/5.0' },
                body: JSON.stringify({ name: name, description: description || undefined, private: isPrivate, auto_init: true })
            });
            if (!res.ok) throw new Error((await res.json()).message || '创建仓库失败');
            await res.json();
            showToast(`仓库 "${name}" 创建成功`);
            hideCreateRepoModal();
            state.shouldAnimateList = true;
            fetchRepos(true);
        } catch (e) {
            showToast(`创建失败: ${e.message}`);
        } finally {
            el.createRepoConfirm.disabled = false;
            el.createRepoConfirm.classList.remove('btn-processing');
            el.createRepoConfirm.innerHTML = '创建仓库';
        }
    };
    uiStateStack.push(hideCreateRepoModal);
}

function hideApiStatusPanel() {
    el.apiStatusOverlay.classList.remove('open');
    el.apiStatusPanel.classList.remove('open');
    setTimeout(() => {
        el.apiStatusOverlay.classList.add('hidden');
    }, 300);
    const index = uiStateStack.indexOf(hideApiStatusPanel);
    if (index > -1) uiStateStack.splice(index, 1);
}

function showApiStatusPanel() {
    el.apiStatusOverlay.classList.remove('hidden');
    setTimeout(() => {
        el.apiStatusOverlay.classList.add('open');
        el.apiStatusPanel.classList.add('open');
    }, 10);
    fetchAndRenderApiStatus();
    uiStateStack.push(hideApiStatusPanel);
}

async function fetchAndRenderApiStatus() {
    el.apiStatusContent.innerHTML = `<div class="loading-spinner" style="height: auto; padding: 2rem 0;"><div class="spinner"></div></div>`;
    try {
        const res = await fetch('https://api.github.com/rate_limit', {
            headers: { Authorization: `token ${state.token}`, 'User-Agent': 'Mozilla/5.0' }
        });
        if (!res.ok) throw new Error(`请求失败: ${res.status}`);
        const scopes = res.headers.get('x-oauth-scopes') || '你没有勾选任何权限，你玩个蛋，滚去官网重新勾选权限。';
        const data = await res.json();
        let contentHTML = '';
        const tokenScopesCardHTML = `
        <div class="api-status-card">
            <h4><i class="fa fa-key"></i>令牌勾选权限</h4>
            <div class="token-scopes">
                ${scopes.split(', ').map(scope => `<span class="token-scope">${scope}</span>`).join('')}
            </div>
        </div>`;
        const resources = ['core'];
        resources.forEach(key => {
            const resource = data.resources[key];
            if (!resource) return;
            const used = resource.used;
            const limit = resource.limit;
            const remaining = resource.remaining;
            const percentage = limit > 0 ? (used / limit) * 100 : 0;
            let progressClass = 'progress-green';
            if (percentage > 95) progressClass = 'progress-red';
            else if (percentage > 75) progressClass = 'progress-yellow';
            const resetTime = new Date(resource.reset * 1000).toLocaleTimeString();
            contentHTML += `
            <div class="api-status-card">
                <h4><i class="fa fa-cogs"></i>${key.charAt(0).toUpperCase() + key.slice(1)} API</h4>
                <div class="rate-limit-progress-bar">
                    <div class="${progressClass}" style="width: ${percentage}%;"></div>
                </div>
                <div class="rate-limit-details">
                    <p>已用: <span>${used}</span> / ${limit}</p>
                    <p>剩余: <span>${remaining}</span></p>
                    <p>重置时间: <span>${resetTime}</span></p>
                    <p>若令牌额度耗尽，本工具将无法正常使用</p>
                </div>
            </div>`;
        });
        
        

        contentHTML += `
        <div class="api-status-card">
            <h4><i class="fa fa-info-circle"></i>联系与反馈</h4>
            <div class="app-status-details" style="user-select: text; cursor: text;">
                <p style="padding-bottom:4px;">作者QQ：1473460411</p>
                <p>QQ反馈群：719050780</p>
               
                
  
            </div>
        </div>
        `;
        contentHTML += tokenScopesCardHTML;
        el.apiStatusContent.innerHTML = contentHTML;
    } catch (error) {
        el.apiStatusContent.innerHTML = `<div class="api-status-card"><p style="color: #f87171;">加载失败: ${error.message}</p></div>`;
    }
}


function toggleEditorSearch(show) {
    const { editorSearchPanel, editorSearchInput } = el;
    if (show) {
        editorSearchPanel.classList.remove('hidden');
        editorSearchInput.focus();
        editorSearchInput.select();
        performEditorSearch();
    } else {
        editorSearchPanel.classList.add('hidden');
        const textarea = el.fileContent;
        const currentScroll = textarea.scrollTop;
        textarea.scrollTop = currentScroll;
        state.editorSearchState = { query: '', matches: [], currentIndex: -1 };
        el.editorSearchInput.value = '';
        updateSearchUI();
    }
}
function performEditorSearch() {
    const query = el.editorSearchInput.value;
    const content = el.fileContent.value;
    state.editorSearchState.query = query;

    if (!query) {
        state.editorSearchState.matches = [];
        state.editorSearchState.currentIndex = -1;
    } else {
        const queryLower = query.toLowerCase();
        const contentLower = content.toLowerCase();
        const matches = [];
        let startIndex = 0;
        let index;
        while ((index = contentLower.indexOf(queryLower, startIndex)) > -1) {
            matches.push(index);
            startIndex = index + queryLower.length;
        }
        state.editorSearchState.matches = matches;
        state.editorSearchState.currentIndex = matches.length > 0 ? 0 : -1;
    }
    
    updateSearchUI();
    if (state.editorSearchState.currentIndex !== -1) {
        highlightCurrentMatch(false);
    }
}

function updateSearchUI() {
    const { matches, currentIndex } = state.editorSearchState;
    const total = matches.length;
    
    if (total > 0) {
        el.editorSearchMatchCount.textContent = `${currentIndex + 1} / ${total}`;
    } else {
        el.editorSearchMatchCount.textContent = '0 / 0';
    }

    el.editorSearchPrevBtn.disabled = total <= 1;
    el.editorSearchNextBtn.disabled = total <= 1;
}

function highlightCurrentMatch(shouldGrabFocus = false) {
    const { matches, currentIndex, query } = state.editorSearchState;
    if (currentIndex === -1) return;

    const textarea = el.fileContent;
    const startPos = matches[currentIndex];
    const endPos = startPos + query.length;

    if (shouldGrabFocus) {
        textarea.focus();
    }
    
    textarea.setSelectionRange(startPos, endPos);
    
    const textBefore = textarea.value.substring(0, startPos);
    const lineNum = textBefore.split("\n").length;
    const lineHeight = parseFloat(getComputedStyle(textarea).lineHeight);
    const targetScrollTop = (lineNum * lineHeight);
    const textareaHeight = textarea.clientHeight;

    textarea.scrollTop = targetScrollTop - (textareaHeight / 2);
}

function navigateSearchMatches(direction) {
    const { matches } = state.editorSearchState;
    const total = matches.length;
    if (total <= 1) return;

    let newIndex = state.editorSearchState.currentIndex + direction;

    if (newIndex < 0) {
        newIndex = total - 1;
    } else if (newIndex >= total) {
        newIndex = 0;
    }

    state.editorSearchState.currentIndex = newIndex;
    updateSearchUI();
highlightCurrentMatch(true);
}




function initPullToRefresh() {
    const mainEl = document.querySelector('main');
    const ptrIndicator = document.getElementById('pull-to-refresh');

    if (!mainEl || !ptrIndicator) return;

    let targetListEl = null;

    const resetPullState = () => {
        ptrIndicator.classList.remove('visible', 'ready', 'refreshing');
        ptrIndicator.style.transition = 'transform 0.3s ease';
        if (targetListEl) {
            targetListEl.style.transition = 'transform 0.3s ease';
            targetListEl.style.transform = 'translateY(0px)';
        }
        state.pullToRefresh.active = false;
        state.pullToRefresh.pullDistance = 0;
    };

    mainEl.addEventListener('touchstart', (e) => {
        if (mainEl.scrollTop === 0) {
            state.pullToRefresh.startY = e.touches[0].clientY;
            state.pullToRefresh.active = true;
            targetListEl = !el.repoList.classList.contains('hidden') ? el.repoList : 
                           !el.fileList.classList.contains('hidden') ? el.fileList : null;
            if(targetListEl) {
                ptrIndicator.style.transition = 'none';
                targetListEl.style.transition = 'none';
            }
        }
    }, { passive: true });

    mainEl.addEventListener('touchmove', (e) => {
        if (!state.pullToRefresh.active || !targetListEl) return;

        const currentY = e.touches[0].clientY;
        let pullDistance = currentY - state.pullToRefresh.startY;

        if (pullDistance < 0) pullDistance = 0;
        if (pullDistance > 0 && mainEl.scrollTop === 0) e.preventDefault();
        
        state.pullToRefresh.pullDistance = pullDistance;

        if (pullDistance > 10) {
            ptrIndicator.classList.add('visible');
            const dampedDistance = pullDistance * 0.4; // 阻尼效果，让拖动更自然
            ptrIndicator.style.transform = `translateY(${dampedDistance - 50}px)`;
            targetListEl.style.transform = `translateY(${dampedDistance}px)`;
            
            if (dampedDistance > state.pullToRefresh.threshold) {
                ptrIndicator.classList.add('ready');
            } else {
                ptrIndicator.classList.remove('ready');
            }
        }
    }, { passive: false });

    mainEl.addEventListener('touchend', async () => {
        if (!state.pullToRefresh.active || !targetListEl) return;

        const dampedDistance = state.pullToRefresh.pullDistance * 0.4;

        if (dampedDistance > state.pullToRefresh.threshold) {
            ptrIndicator.classList.add('refreshing');
            ptrIndicator.classList.remove('ready');
            ptrIndicator.style.transform = `translateY(${state.pullToRefresh.threshold - 50}px)`;
            targetListEl.style.transform = `translateY(${state.pullToRefresh.threshold}px)`;
            
            try {
                if (targetListEl === el.repoList) await fetchRepos(true);
                else if (targetListEl === el.fileList) await fetchFiles(true, false);
            } catch (error) {
                showToast('刷新失败', 'error');
            } finally {
                resetPullState();
            }
        } else {
            resetPullState();
        }
        state.pullToRefresh.active = false;
    });
}




async function publishProjectSite(repo, branchName) {
    try {
        const pagesRes = await fetch(`https://api.github.com/repos/${repo.full_name}/pages`, {
            method: 'POST',
            headers: { 'Authorization': `token ${state.token}`, 'Content-Type': 'application/json' },
            body: JSON.stringify({ source: { branch: branchName, path: "/" } })
        });

        if (pagesRes.status === 409) {
            return { success: true, message: '网站已存在或正在构建中。' };
        }
        
        if (!pagesRes.ok) {
            let errorMessage;
            if (pagesRes.status === 422) errorMessage = '仓库为空或分支无效。';
            else if (pagesRes.status === 403) errorMessage = '权限不足。';
            else errorMessage = `发生未知网络错误 (HTTP ${pagesRes.status})。`;
            throw new Error(errorMessage);
        }

        return { success: true, message: '发布成功！' };
    } catch (error) {
        console.error(`发布仓库 ${repo.name} 失败:`, error);
        return { success: false, message: error.message };
    }
}




async function unpublishSite(repo) {
    try {
        const res = await fetch(`https://api.github.com/repos/${repo.full_name}/pages`, {
            method: 'DELETE',
            headers: { 'Authorization': `token ${state.token}` }
        });
        if (!res.ok && res.status !== 404) {
            let errorMessage;
            if (res.status === 403) errorMessage = '权限不足。';
            else errorMessage = `发生未知网络错误 (HTTP ${res.status})。`;
            throw new Error(errorMessage);
        }
        return { success: true, message: '取消发布成功！' };
    } catch (error) {
        console.error(`取消发布仓库 ${repo.name} 失败:`, error);
        return { success: false, message: error.message };
    }
}









function renderPublishManagerLists() {
    if (state.publishManagerActiveTab === 'official') {
        el.officialConfigTabBtn.classList.add('active');
        el.customDomainTabBtn.classList.remove('active');
    } else {
        el.officialConfigTabBtn.classList.remove('active');
        el.customDomainTabBtn.classList.add('active');
    }

    const listEl = el.publishManageList;
    listEl.innerHTML = '';

    let mainSiteRepo = null;
    if (state.user && state.user.login) {
        const mainSiteName = `${state.user.login}.github.io`;
        mainSiteRepo = state.repos.find(r => r.name === mainSiteName);
    }
    
    // 关键改动：判断主站点仓库是否已存在
    const mainSiteExists = !!mainSiteRepo;

    let reposToRender;
    const isActiveTabOfficial = state.publishManagerActiveTab === 'official';

    if (isActiveTabOfficial) {
        const otherPublicRepos = state.repos.filter(r => !r.private && (!mainSiteRepo || r.id !== mainSiteRepo.id));
        const publishedRepos = otherPublicRepos.filter(r => r.has_pages);
        const unpublishedRepos = otherPublicRepos.filter(r => !r.has_pages);
        publishedRepos.sort((a, b) => a.name.localeCompare(b.name));
        unpublishedRepos.sort((a, b) => a.name.localeCompare(b.name));
        const sortedOtherRepos = [...publishedRepos, ...unpublishedRepos];
        reposToRender = mainSiteRepo ? [mainSiteRepo, ...sortedOtherRepos] : sortedOtherRepos;
    } else {
        let publishedRepos = state.repos.filter(r => r.has_pages);
        mainSiteRepo = publishedRepos.find(r => r.name === `${state.user.login}.github.io`);
        let otherPublishedRepos = publishedRepos.filter(r => !mainSiteRepo || r.id !== mainSiteRepo.id);
        
        otherPublishedRepos.sort((a, b) => {
            const aHasDomain = !!a.customDomain;
            const bHasDomain = !!b.customDomain;
            if (aHasDomain && !bHasDomain) return -1;
            if (!aHasDomain && bHasDomain) return 1;
            return a.name.localeCompare(b.name);
        });
        
        reposToRender = mainSiteRepo ? [mainSiteRepo, ...otherPublishedRepos] : otherPublishedRepos;
    }

    if (reposToRender.length === 0) {
        const emptyMessage = isActiveTabOfficial
            ? '没有可管理的公开项目'
            : '没有已发布的项目网站';
        listEl.innerHTML = `<p class="publish-list-empty">${emptyMessage}</p>`;
    } else {
        const mainSiteHasCustomDomain = mainSiteRepo && mainSiteRepo.customDomain;
        const projectSiteHasDomain = state.repos.some(r => r.has_pages && r.customDomain && (!mainSiteRepo || r.id !== mainSiteRepo.id));

        reposToRender.forEach(repo => {
            const item = document.createElement('div');
            item.className = 'publish-item';
            
            if (repo.has_pages) {
                item.classList.add('is-published');
                item.title = '点击复制网站链接';
            }

            if (isActiveTabOfficial) {
                const isPublished = repo.has_pages;
                const isMainSite = mainSiteRepo && repo.id === mainSiteRepo.id;

                let actionButtonHTML = '';
                if (isMainSite) {
                    if (isPublished && !repo.customDomain) {
                        actionButtonHTML = `<button class="btn btn-unpublish btn-sm main-site-action-btn">取消主站</button>`;
                    }
                } else {
                    if (isPublished) {
                        if (!repo.customDomain) {
                            actionButtonHTML = `<button class="btn btn-unpublish btn-sm project-action-btn">取消项目</button>`;
                        }
                    } else {
                        actionButtonHTML = `<button class="btn btn-primary btn-sm project-action-btn">发布项目</button>`;
                    }
                }

                // 关键改动：更新显示逻辑，仅在主站不存在时才显示按钮
                const showSetAsMainSiteButton = !isMainSite && !repo.customDomain && !mainSiteExists;

                item.innerHTML = `
                    <span class="repo-name" title="${repo.name}">${repo.name}</span>
                    <div class="publish-item-actions">
                        ${showSetAsMainSiteButton ? `<button class="btn btn-secondary btn-sm set-as-main-site-btn" data-repo-fullname="${escapeHtml(repo.full_name)}">发布为主站</button>` : ''}
                        ${actionButtonHTML}
                    </div>
                `;
                
                if (isMainSite) {
                    const mainSiteButton = item.querySelector('.main-site-action-btn');
                    if (mainSiteButton) {
                        mainSiteButton.onclick = () => {
                            showUnpublishMainSiteModal(repo);
                        };
                    }
                } else {
                    const projectButton = item.querySelector('.project-action-btn');
                    if (projectButton) {
                        if (isPublished) {
                            projectButton.onclick = async () => {
                                projectButton.textContent = '处理中...';
                                projectButton.disabled = true;
                                const result = await unpublishSite(repo);
                                showToast(result.message, result.success ? 'success' : 'error');
                                if (result.success) {
                                    const repoInState = state.repos.find(r => r.id === repo.id);
                                    if(repoInState) repoInState.has_pages = false;
                                    renderPublishManagerLists();
                                } else {
                                    projectButton.textContent = '取消发布';
                                    projectButton.disabled = false;
                                }
                            };
                        } else {
                            projectButton.dataset.repoFullname = repo.full_name;
                            projectButton.onclick = () => {
                                showPublishBranchSelectorModal(repo, 'projectSite');
                            };
                        }
                    }
                }

            } else {
                const isMainSite = mainSiteRepo && repo.id === mainSiteRepo.id;
                let showConfigureButton = false;
                if(isMainSite) {
                    showConfigureButton = !projectSiteHasDomain;
                } else {
                    showConfigureButton = !mainSiteHasCustomDomain;
                }

                let actionButtonsHTML = '';
                if (repo.customDomain) {
                    actionButtonsHTML += `<button class="btn btn-unpublish btn-sm remove-domain-btn" data-repo-fullname="${escapeHtml(repo.full_name)}">取消绑定</button>`;
                }
                if (showConfigureButton) {
                    actionButtonsHTML += `<button class="btn btn-primary btn-sm configure-domain-btn" data-repo-fullname="${escapeHtml(repo.full_name)}">配置域名</button>`;
                }
                
                item.innerHTML = `
                    <div class="repo-info-wrapper">
                        <span class="repo-name" title="${repo.name}">${repo.name}</span>
                        ${repo.customDomain ? `<p class="repo-domain-display"> ${repo.customDomain}</p>` : ''}
                    </div>
                    <div class="publish-item-actions">
                        ${actionButtonsHTML}
                    </div>
                `;
            }
            
            item.addEventListener('click', (e) => {
                if (e.target.closest('button')) return;

                const isMainSiteRepo = state.user && repo.name === `${state.user.login}.github.io`;

                if (state.publishManagerActiveTab === 'official') {
                    if (!repo.has_pages) {
                        showToast(isMainSiteRepo ? '主站未发布静态网页' : '项目未发布静态网页');
                        return;
                    }

                    const siteUrl = isMainSiteRepo
                        ? `https://${repo.owner.login}.github.io/`
                        : `https://${repo.owner.login}.github.io/${repo.name}/`;
                    
                    navigator.clipboard.writeText(siteUrl).then(() => {
                        showToast(isMainSiteRepo ? '主站链接已复制' : '项目链接已复制');
                    }).catch(() => {
                        showToast(isMainSiteRepo ? '主站链接复制失败' : '项目链接复制失败');
                    });
                } 
                else {
                    if (repo.customDomain) {
                        const siteUrl = `https://${repo.customDomain}`;
                        navigator.clipboard.writeText(siteUrl).then(() => {
                            showToast('自定义域名已复制');
                        }).catch(() => {
                            showToast('复制域名失败');
                        });
                    } else {
                        showToast('未配置域名');
                    }
                }
            });
            
            listEl.appendChild(item);
        });
    }
}



function showPublishHelpModal() {
    el.publishHelpModal.classList.remove('hidden');
    uiStateStack.push(hidePublishHelpModal);
}

function hidePublishHelpModal() {
    el.publishHelpModal.classList.add('hidden');
    const index = uiStateStack.indexOf(hidePublishHelpModal);
    if (index > -1) uiStateStack.splice(index, 1);
}


async function showPublishManagerModal() {
    hideMainMenuPopup();
    state.publishManagerActiveTab = 'official';
    el.publishManagerModal.classList.remove('hidden');
    
    el.publishManageList.innerHTML = '<div class="loading-spinner" style="height: 30px; font-size: 1.2rem; color: #10b981;"><i class="fa fa-spinner fa-spin"></i></div>';

    try {
        await fetchRepos(true, false); 
        
        const cachedDomains = JSON.parse(localStorage.getItem('custom_domains_cache') || '{}');
        state.repos.forEach(repo => {
            if (repo.has_pages && cachedDomains[repo.full_name]) {
                repo.customDomain = cachedDomains[repo.full_name];
            }
        });

        renderPublishManagerLists();
        prefetchCustomDomains();
    } catch (error) {
        el.publishManageList.innerHTML = '<p class="publish-list-empty">加载仓库列表失败</p>';
        showToast('加载仓库列表失败', 'error');
    }
    
    uiStateStack.push(hidePublishManagerModal);
}

function prefetchCustomDomains() {
    const cachedDomains = JSON.parse(localStorage.getItem('custom_domains_cache') || '{}');
    const reposToFetch = state.repos.filter(r => r.has_pages && r.customDomain === undefined);

    if (reposToFetch.length === 0) {
        return;
    }

    const fetchPromises = reposToFetch.map(repo => (async () => {
        try {
            const url = `https://api.github.com/repos/${repo.full_name}/contents/CNAME?t=${Date.now()}`;
            const response = await fetch(url, { headers: { 'Authorization': `token ${state.token}` } });
            
            let domain = null;
            if (response.ok) {
                const data = await response.json();
                domain = atob(data.content).trim();
            }
            
            repo.customDomain = domain;
            cachedDomains[repo.full_name] = domain;

        } catch (error) {
            repo.customDomain = null;
            cachedDomains[repo.full_name] = null;
        }
    })());
    
    Promise.all(fetchPromises).then(() => {
        localStorage.setItem('custom_domains_cache', JSON.stringify(cachedDomains));
        if (!el.publishManagerModal.classList.contains('hidden')) {
            renderPublishManagerLists();
        }
    });
}
function hidePublishManagerModal() {
    el.publishManagerModal.classList.add('hidden');
    const index = uiStateStack.indexOf(hidePublishManagerModal);
    if (index > -1) uiStateStack.splice(index, 1);

    if (!el.repoList.classList.contains('hidden')) {
        state.shouldAnimateList = false;
        renderRepoList();
    }
}





function setupEventListeners() {
function autoGrow(element) {


    
        element.style.height = 'auto';
        element.style.height = (element.scrollHeight) + 'px';
    }

    if (el.createRepoDescInput) {
        el.createRepoDescInput.addEventListener('input', function() {
            autoGrow(this);
        });
    }

    if (el.createFileContentInput) {
        el.createFileContentInput.addEventListener('input', function() {
            autoGrow(this);
        });
    }
if (el.menuThemeToggle) {
    el.menuThemeToggle.onclick = () => {
        themeManager.toggle();
    };
    
    el.showPublishHelpBtn.onclick = showPublishHelpModal;
    el.closePublishHelpBtn.onclick = hidePublishHelpModal;
    el.publishHelpModal.onclick = (e) => {
        if (e.target === el.publishHelpModal) {
            hidePublishHelpModal();
        }
    };
    
    el.searchInFileBtn.addEventListener('click', () => toggleEditorSearch(true));
el.editorSearchCloseBtn.addEventListener('click', () => toggleEditorSearch(false));

el.editorSearchInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
        e.preventDefault();
        if (e.shiftKey) {
             navigateSearchMatches(-1);
        } else {
             navigateSearchMatches(1);
        }
    }
});
    el.fileList.addEventListener('click', (e) => {
        const item = e.target.closest('.file-item');
        if (!item) return;

        const filePath = item.dataset.filePath;
        const file = state.displayFiles.find(f => f.path === filePath);
        if (!file) return;

        const retryTrigger = e.target.closest('.retry-trigger');
        if (retryTrigger) {
            e.stopPropagation();
            const allFailedContainers = document.querySelectorAll('#fileList .file-thumbnail-container.error');
            if (allFailedContainers.length > 0) {
                showToast(`正在重试 ${allFailedContainers.length} 个失败的图片...`);
                allFailedContainers.forEach(container => {
                    container.classList.remove('error');
                    container.classList.add('loading');
                    loadThumbnailImage(container);
                });
            }
            return;
        }

        if (state.isMultiSelectMode) {
            item.classList.toggle('selected');
            if (state.selectedItems.has(file.path)) {
                state.selectedItems.delete(file.path);
            } else {
                state.selectedItems.add(file.path);
            }
            updateActionBar();
        } else {
            if (file.type === 'dir') {
                navigateToDir(file.name);
            } else {
                const fileExtension = file.name.split('.').pop()?.toLowerCase();
                const isMedia = IMAGE_EXTS.includes(fileExtension) || VIDEO_EXTS.includes(fileExtension) || AUDIO_EXTS.includes(fileExtension);
                if (!isMedia) {
                   editFile(file);
                }
            }
        }
    });

    el.fileList.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        const item = e.target.closest('.file-item');
        if (!item) return;
        const filePath = item.dataset.filePath;
        const file = state.displayFiles.find(f => f.path === filePath);
        if (!file) return;
        showContextMenu(e, file);
    });
el.editorSearchInput.addEventListener('input', performEditorSearch);
el.editorSearchPrevBtn.addEventListener('click', () => navigateSearchMatches(-1));
el.editorSearchNextBtn.addEventListener('click', () => navigateSearchMatches(1));
}
el.setAsSiteCloseBtn.onclick = hideSetAsSiteModal;
el.setAsSiteCancelBtn.onclick = hideSetAsSiteModal;

const setAsSiteSelector = document.getElementById('setAsSiteBranchSelector');
setAsSiteSelector.querySelector('.custom-branch-select-trigger').addEventListener('click', (e) => {
    e.stopPropagation();
    setAsSiteSelector.classList.toggle('open');
});

document.addEventListener('click', (e) => {
    if (!setAsSiteSelector.contains(e.target)) {
        setAsSiteSelector.classList.remove('open');
    }
});


el.manageAccountsBtn.addEventListener('click', showAccountManagerModal);
el.menuSwitchAccount.addEventListener('click', () => {
    hideMainMenuPopup();
    showAccountManagerModal();
});
el.closeAccountManagerModalBtn.addEventListener('click', closeAccountManagerModal);
el.showAddAccountModalBtn.addEventListener('click', () => showAddEditAccountModal());


el.closeAddEditAccountModalBtn.addEventListener('click', closeAddEditAccountModal);
el.addEditAccountCancelBtn.addEventListener('click', closeAddEditAccountModal);
el.addEditAccountSaveBtn.addEventListener('click', handleSaveAccount);









let configuringDomainRepoFullName = null;

async function showCustomDomainModal(repoFullName) {
    state.configuringDomainRepoFullName = repoFullName;
    const repoName = repoFullName.split('/')[1];
    const repoToUpdate = state.repos.find(r => r.full_name === repoFullName);

    el.customDomainRepoName.textContent = `为仓库 "${repoName}" 设置域名`;
    el.customDomainInput.value = '';
    el.customDomainSaveBtn.disabled = true;
    el.customDomainError.style.display = 'none';
    el.customDomainModal.classList.remove('hidden');
    uiStateStack.push(hideCustomDomainModal);

    el.customDomainInput.disabled = true;

    try {
        const url = `https://api.github.com/repos/${repoFullName}/contents/CNAME`;
        const response = await fetch(url, {
            headers: { 'Authorization': `token ${state.token}` }
        });

        if (response.ok) {
            const data = await response.json();
            const currentDomain = atob(data.content);
            el.customDomainInput.value = currentDomain;
            if (repoToUpdate) repoToUpdate.customDomain = currentDomain;
        } else {
            
            if (repoToUpdate) repoToUpdate.customDomain = null;
        }

    } catch (error) {
        console.error('获取CNAME文件失败:', error);
        el.customDomainInput.placeholder = '加载域名失败，请重试';
    } finally {
        el.customDomainInput.disabled = false;
        el.customDomainInput.dispatchEvent(new Event('input'));
    }
}

function hideCustomDomainModal() {
    el.customDomainModal.classList.add('hidden');
    state.configuringDomainRepoFullName = null;
    const index = uiStateStack.indexOf(hideCustomDomainModal);
    if (index > -1) uiStateStack.splice(index, 1);
}

async function handleSaveCustomDomain() {
    const domain = el.customDomainInput.value.trim();
    if (!domain || !state.configuringDomainRepoFullName) return;

    const saveBtn = el.customDomainSaveBtn;
    const spinner = saveBtn.querySelector('i');
    saveBtn.disabled = true;
    spinner.classList.remove('hidden');
    el.customDomainError.style.display = 'none';

    try {
        const [owner, repo] = state.configuringDomainRepoFullName.split('/');
        const filePath = 'CNAME';
        const url = `https://api.github.com/repos/${owner}/${repo}/contents/${filePath}`;
        
        let existingFileSha = null;
        try {
            const checkRes = await fetch(url, { headers: { 'Authorization': `token ${state.token}` } });
            if (checkRes.ok) {
                existingFileSha = (await checkRes.json()).sha;
            }
        } catch (e) {}

        const encodedContent = btoa(unescape(encodeURIComponent(domain)));
        const requestBody = {
            message: `feat: Set custom domain to ${domain}`,
            content: encodedContent,
            branch: state.repos.find(r => r.full_name === state.configuringDomainRepoFullName)?.default_branch || 'main'
        };

        if (existingFileSha) {
            requestBody.sha = existingFileSha;
        }

        const res = await fetch(url, {
            method: 'PUT',
            headers: { 'Authorization': `token ${state.token}`, 'Content-Type': 'application/json' },
            body: JSON.stringify(requestBody)
        });

        if (!res.ok) {
            const errorData = await res.json();
            throw new Error(errorData.message || '配置域名失败');
        }

        const repoToUpdate = state.repos.find(r => r.full_name === state.configuringDomainRepoFullName);
        if (repoToUpdate) repoToUpdate.customDomain = domain;

        showToast(`仓库 ${repo} 的域名已配置为 ${domain}`);
        hideCustomDomainModal();
        renderPublishManagerLists(); 

    } catch (error) {
        el.customDomainError.textContent = `错误: ${error.message}`;
        el.customDomainError.style.display = 'block';
    } finally {
        saveBtn.disabled = false;
        spinner.classList.add('hidden');
    }
}




function showRemoveCustomDomainConfirmation(repo) {
    showDeleteModal(
        null,
        false,
        '确认取消域名绑定',
        `确定要为仓库 "${repo.name}" 取消自定义域名绑定吗？<br><br>此操作将从您的仓库中删除 CNAME 文件。`,
        async () => {
            await handleRemoveCustomDomain(repo);
        },
        '确认取消',
        'btn-danger'
    );
}

async function handleRemoveCustomDomain(repo) {
    showToast('正在取消域名绑定...');
    try {
        const [owner, repoName] = repo.full_name.split('/');
        const url = `https://api.github.com/repos/${owner}/${repoName}/contents/CNAME`;

        const checkRes = await fetch(url + `?ref=${repo.default_branch}`, {
            headers: { 'Authorization': `token ${state.token}` }
        });

        if (!checkRes.ok) {
            if (checkRes.status === 404) {
                showToast('域名配置已不存在', 'info');
                repo.customDomain = null;
                renderPublishManagerLists();
                return;
            }
            throw new Error('无法获取当前的域名配置');
        }

        const fileData = await checkRes.json();
        const existingFileSha = fileData.sha;

        const res = await fetch(url, {
            method: 'DELETE',
            headers: { 'Authorization': `token ${state.token}`, 'Content-Type': 'application/json' },
            body: JSON.stringify({
                message: `build: Remove custom domain`,
                sha: existingFileSha,
                branch: repo.default_branch
            })
        });

        if (!res.ok) {
            const errorData = await res.json();
            throw new Error(errorData.message || '取消绑定失败');
        }

        repo.customDomain = null;
        showToast(`仓库 "${repo.name}" 的自定义域名已成功取消绑定`);
        renderPublishManagerLists();

    } catch (error) {
        showToast(`操作失败: ${error.message}`, 'error');
        console.error(error);
    }
}











function validateAccountForm() {
    const name = el.accountNameInput.value.trim();
    const token = el.accountTokenInput.value.trim();

    if (editingAccountId) {
        el.addEditAccountSaveBtn.disabled = !name;
    } else {
        el.addEditAccountSaveBtn.disabled = !token;
    }
}
el.accountNameInput.addEventListener('input', validateAccountForm);
el.accountTokenInput.addEventListener('input', validateAccountForm);

    
    
    el.proxyQuickToggle.addEventListener('click', () => {
        setProxyGlobalState(!state.proxyGlobalEnable, true);
    });
    el.proxyGlobalEnableToggle.addEventListener('change', (e) => {
        setProxyGlobalState(e.target.checked, true);
    });
    el.refreshApiStatusBtn.addEventListener('click', handleRefreshApiStatus);
    el.currentRepo.addEventListener('click', showApiStatusPanel);
    el.closeApiStatusPanel.addEventListener('click', hideApiStatusPanel);
    el.apiStatusOverlay.addEventListener('click', hideApiStatusPanel);
    el.avatarContainer.addEventListener('click', () => {
        el.avatarUploadInput.click();
    });
    el.avatarUploadInput.addEventListener('change', handleAvatarChange);
    el.importBtn.addEventListener('click', importProxiesFromUrl);
    el.newFolderBtn.onclick = function() {
        if (!state.currentRepo) {
            showCreateRepoModal();
        } else {
            showCreateFolderModal();
        }
    };
   
el.authBtn.addEventListener('click', async () => {
    const token = el.tokenInput.value.trim();
    const btn = el.authBtn;
    const btnText = btn.querySelector('span');
    const spinner = btn.querySelector('i');
    btn.classList.remove('success', 'error');
    el.tokenInput.classList.remove('error');
    if (!token) {
        showToast('请输入GitHub访问令牌');
        el.tokenInput.classList.add('error');
        btn.classList.add('error');
        return;
    }
    btn.disabled = true;
    btnText.textContent = '正在验证';
    spinner.classList.remove('hidden');

    try {
        const res = await fetch('https://api.github.com/user', {
            headers: { Authorization: `token ${token}` }
        });

        if (!res.ok) {
            if (res.status === 401) {
                throw new Error('令牌无效或已过期');
            }
            throw new Error(`验证失败: ${res.statusText}`);
        }

        const userData = await res.json(); 

       
        let existingAccount = state.accounts.find(acc => acc.token === token);
        if (!existingAccount) {
            const newAccount = {
                id: `gh_${Date.now()}`,
                name: `${userData.login}`, 
                token: token
            };
            state.accounts.push(newAccount);
            saveAccounts();
            existingAccount = newAccount;
            showToast('新账号已自动保存');
        }
        
        
        setActiveAccount(existingAccount.id);
        
        btn.classList.add('success');
        btnText.textContent = '登录成功 ✓';
        spinner.classList.add('hidden');
        state.shouldAnimateList = true;
        
        await Promise.all([
            fetchUserInfo(), 
            fetchRepos(true)
        ]);

        setTimeout(async () => {
            showApp();
            showToast('欢迎回来！');

            if (state.proxies.length === 0) {
                findAndSetBestProxy();
            } else if (state.autoSelectProxy) {
                findAndSetBestProxy();
            } else {
                state.activeProxyIndex = parseInt(localStorage.getItem('active_proxy_index') || '0');
                state.proxyGlobalEnable = JSON.parse(localStorage.getItem('proxy_global_enable') || 'true');
                saveProxyConfig();
            }

            btn.disabled = false;
            btnText.textContent = '登录';
            btn.classList.remove('success');
        }, 1000);

    } catch (error) {
        showToast(error.message || '网络连接失败，请重试');
        el.tokenInput.classList.add('error');
        btn.classList.add('error');
        btn.disabled = false;
        btnText.textContent = '登录';
        spinner.classList.add('hidden');
    }
});


    el.mainMenuBtn.onclick = (e) => {
        e.stopPropagation();
        hideContextMenu();
        if (el.mainMenuPopup.classList.contains('hidden')) {
            showMainMenuPopup();
        } else {
            hideMainMenuPopup();
        }
    };
    el.createBranchCancel.onclick = function() {
        hideCreateBranchModal();
    };
    el.cancelSelectBtn.addEventListener('click', () => toggleMultiSelectMode(false));
    el.selectAllBtn.addEventListener('click', () => {
        const allVisiblePaths = state.displayFiles.map(f => f.path);
        const areAllSelected = allVisiblePaths.length > 0 && allVisiblePaths.every(path => state.selectedItems.has(path));
        allVisiblePaths.forEach(path => {
            if (areAllSelected) {
                state.selectedItems.delete(path);
            } else {
                state.selectedItems.add(path);
            }
        });
        renderFileList();
    });
    el.invertSelectBtn.addEventListener('click', () => {
        const allVisiblePaths = state.displayFiles.map(f => f.path);
        allVisiblePaths.forEach(path => {
            if (state.selectedItems.has(path)) {
                state.selectedItems.delete(path);
            } else {
                state.selectedItems.add(path);
            }
        });
        renderFileList();
    });
    el.downloadBtn.addEventListener('click', downloadSelectedItemsAsZip);
    el.deleteBtn.addEventListener('click', () => {
        if (state.selectedItems.size === 0) return;
        const selectedFiles = state.files.filter(f => state.selectedItems.has(f.path));
        const fileCount = selectedFiles.filter(f => f.type === 'file').length;
        const dirCount = selectedFiles.filter(f => f.type === 'dir').length;
        let desc = `确定要删除这 ${state.selectedItems.size} 个项目吗？`;
        if (fileCount > 0 && dirCount > 0) desc += ` (包含 ${fileCount} 个文件和 ${dirCount} 个文件夹)`;
        else if (fileCount > 0) desc += ` (共 ${fileCount} 个文件)`;
        else if (dirCount > 0) desc += ` (共 ${dirCount} 个文件夹)`;
        showDeleteModal(null, false, '确认批量删除', desc, async function() {
            showToast(`开始删除 ${selectedFiles.length} 个项目...`);
            for (const item of selectedFiles) {
                await deleteSingleItem(item);
            }
            showToast('批量删除完成！');
            toggleMultiSelectMode(false);
            state.shouldAnimateList = true;
            fetchFiles(true);
        });
    });
    function handleInteractionToCloseMenu(e) {
        if (!el.contextMenu.classList.contains('hidden') && !el.contextMenu.contains(e.target)) {
            hideContextMenu();
        }
    }
    document.addEventListener('mousedown', handleInteractionToCloseMenu);
    document.addEventListener('touchstart', handleInteractionToCloseMenu, { passive: true });
    document.addEventListener('click', function(e) {
        if (!el.mainMenuPopup.classList.contains('hidden') && !el.mainMenuPopup.contains(e.target) && !e.target.closest('#mainMenuBtn')) {
            hideMainMenuPopup();
        }
        if (!el.customSortDropdown.classList.contains('hidden') && !el.customSortDropdown.contains(e.target) && !e.target.closest('#sortToggleBtn')) {
            hideSortDropdown();
        }
    });
    
    
    
el.menuLogout.onclick = () => {
    hideMainMenuPopup();
    
    const performLogout = () => {
        state.token = null; 
        setActiveAccount(null);
        localStorage.removeItem('user_avatar');
        localStorage.removeItem('cached_repos');
        localStorage.removeItem('repos_cache_time');
        state.repos = [];
        state.currentRepo = null;
        state.user = null;
        showAuth();
    };

    showDeleteModal(
        null,
        false,
        '确认退出',
        '您确定要退出当前账号吗？',
        performLogout,
        '确认退出',
        'btn-danger'
    );
};
    el.menuProxySettings.onclick = () => {
        hideMainMenuPopup();
        openProxySettingsModal();
    };
    el.menuClearCache.onclick = () => {
    hideMainMenuPopup();
    showDeleteModal(
        null,
        false,
        '确认清除缓存',
        '这将清除包括仓库列表和文件缓存，但不会影响您的账号管理和菜单设置。',
        () => { 
            clearCache();
        },
        '确认清除',
        'btn-danger'
    );
};

el.menuBatchPublishSites.onclick = showPublishManagerModal;
    el.saveEdit.addEventListener('click', saveEditedFile);
    el.revertEditBtn.onclick = () => {
    showDeleteModal(
        null,
        false,
        '确认撤销',
        '确定要撤销所有未保存的修改吗？此操作不可恢复。',
        () => {
            el.fileContent.value = state.originalContent;
            checkContentChanges();
            showToast('已恢复至原始内容');
        },
        '确认撤销',
        'btn-primary'
    );
};
    el.closeEditModal.onclick = hideEditModal;
    el.cancelEdit.onclick = hideEditModal;
    
    el.backBtn.onclick = goUp;
    el.newFileBtn.onclick = showCreateFileModal;
    el.uploadBtn.onclick = handleUploadClick;
    el.fileUploadInput.addEventListener('change', handleFilesSelected);
    el.searchToggleBtn.addEventListener('click', () => {
        el.searchInput.classList.toggle('hidden');
        if (!el.searchInput.classList.contains('hidden')) {
            el.searchInput.focus();
            el.searchInput.style.display = 'block';
        } else {
            el.searchInput.value = '';
            state.searchQuery = '';
            applyFiltersAndSort();
            renderFileList();
            el.searchInput.style.display = 'none';
        }
    });
    if (el.searchInput) {
        el.searchInput.addEventListener('input', () => {
        state.shouldAnimateList = true;
            state.searchQuery = el.searchInput.value || '';
            applyFiltersAndSort();
            renderFileList();
        });
    }
    el.multiSelectToggleBtn.onclick = () => {
        toggleMultiSelectMode(!state.isMultiSelectMode);
    };
    el.sortToggleBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        if (el.customSortDropdown.classList.contains('hidden')) {
            showSortDropdown();
        } else {
            hideSortDropdown();
        }
    });
    el.customSortDropdown.addEventListener('click', (e) => {
        const item = e.target.closest('.dropdown-item');
        state.shouldAnimateList = true;
        if (!item) return;
        hideSortDropdown();
        const newSortBy = item.dataset.value;
        const newPriority = item.dataset.priority;
        if (newSortBy) {
            state.sortBy = newSortBy;
            localStorage.setItem('sort_by', state.sortBy);
        }
        if (newPriority) {
            state.directorySortPriority = newPriority;
            localStorage.setItem('directory_sort_priority', state.directorySortPriority);
        }
        updateSortDropdownUI();
        applyFiltersAndSort();
        renderFileList();
    });
    if (el.customSortDropdown) {
        Array.from(el.customSortDropdown.children).forEach(item => {
            if (item.dataset.value === state.sortBy) {
                item.classList.add('selected');
            }
        });
    }
    if (el.viewToggleBtn) {
        updateFileListViewMode();
        el.viewToggleBtn.addEventListener('click', () => {
            state.viewMode = state.viewMode === 'list' ? 'grid' : 'list';
            localStorage.setItem('view_mode', state.viewMode);
            updateFileListViewMode();
            state.shouldAnimateList = true;
            renderFileList();  
        });
    }
    el.proxyCancelSettingsBtn.addEventListener('click', closeProxySettingsModal);
        el.proxyAutoSelectToggle.addEventListener('click', async () => {
    state.autoSelectProxy = !state.autoSelectProxy;
    localStorage.setItem('proxy_auto_select', JSON.stringify(state.autoSelectProxy));
    updateProxySettingsUI();

    if (state.autoSelectProxy) {
        await findAndSetBestProxy(true);
    } else {
        showToast('已关闭自动优选');
    }
});
    el.proxyAddBtn.addEventListener('click', () => openAddEditProxyModal());
    el.proxyTestAllBtn.addEventListener('click', testAllProxies);
    el.proxyClearAllBtn.addEventListener('click', showConfirmClearAllProxiesModal);
    el.addEditProxyUrlInput.addEventListener('input', validateAddEditProxyInput);
    el.confirmDeleteProxyCancelBtn.addEventListener('click', hideConfirmDeleteProxyModal);
    el.clearAllProxiesCancelBtn.addEventListener('click', hideConfirmClearAllProxiesModal);
    el.clearAllProxiesConfirmBtn.addEventListener('click', clearAllProxiesConfirmed);
    el.renameInput.oninput = function() {
        el.renameConfirm.disabled = !el.renameInput.value.trim() || el.renameInput.value.trim() === state.selectedFile?.name;
    };
    el.renameCancel.onclick = function() {
        hideRenameModal();
    };
    el.deleteCancel.onclick = function() {
        hideDeleteModal();
    };
    el.createRepoCancel.onclick = function() {
        hideCreateRepoModal();
    };
    el.createFolderInput.oninput = function() {
        el.createFolderConfirm.disabled = !el.createFolderInput.value.trim();
    };
    el.createFolderCancel.onclick = function() {
        hideCreateFolderModal();
    };
    el.createFileNameInput.oninput = function() {
        el.createFileConfirm.disabled = !el.createFileNameInput.value.trim() || el.createFileNameInput.value.trim().endsWith('/');
    };
    el.createFileCancel.onclick = function() {
        hideCreateFileModal();
    };
    el.createBranchNameInput.oninput = function() {
        el.createBranchConfirm.disabled = !el.createBranchNameInput.value.trim();
    }
    el.menuContextMenuSettings.onclick = () => {
        hideMainMenuPopup();
        openContextMenuSettingsModal();
    };
    el.contextMenuSettingsCloseBtn.onclick = () => {
        hideContextMenuSettingsModal();
    };
    el.contextMenuSettingsModal.querySelector('.context-menu-settings-tabs').addEventListener('click', e => {
        if (e.target.matches('.tab-btn')) {
            const container = e.target.parentElement;
            container.querySelector('.active').classList.remove('active');
            e.target.classList.add('active');
            renderContextMenuSettings(e.target.dataset.tab);
        }
    });
    el.contextMenuSettingsContent.addEventListener('change', e => {
        if (e.target.matches('input[type="checkbox"]')) {
            const { category, action } = e.target.dataset;
            const isVisible = e.target.checked;
            state.contextMenuVisibility[category][action] = isVisible;
            if (action === 'setAsMainSite') {
                 state.contextMenuVisibility.repo.copyMainSiteLink = isVisible;
            }
            saveContextMenuSettings();
        }
    });
    
    el.closeCustomDomainModalBtn.onclick = hideCustomDomainModal;
el.customDomainCancelBtn.onclick = hideCustomDomainModal;
el.customDomainSaveBtn.onclick = handleSaveCustomDomain;
el.customDomainInput.addEventListener('input', () => {
    el.customDomainSaveBtn.disabled = el.customDomainInput.value.trim() === '';
});
el.publishManageList.addEventListener('click', (e) => {
    const configureBtn = e.target.closest('.configure-domain-btn');
    const copyLinkBtn = e.target.closest('.copy-site-link-btn');
    const setAsMainSiteBtn = e.target.closest('.set-as-main-site-btn');
    const removeBtn = e.target.closest('.remove-domain-btn');

    if (removeBtn) {
        const repoFullName = removeBtn.dataset.repoFullname;
        if (repoFullName) {
            const repo = state.repos.find(r => r.full_name === repoFullName);
            if (repo) {
                showRemoveCustomDomainConfirmation(repo);
            }
        }
        return;
    }

    if (configureBtn) {
        const repoFullName = configureBtn.dataset.repoFullname;
        if (repoFullName) {
            showCustomDomainModal(repoFullName);
        }
        return;
    }
    
    if (setAsMainSiteBtn) {
        const repoFullName = setAsMainSiteBtn.dataset.repoFullname;
        const repo = state.repos.find(r => r.full_name === repoFullName);
        if (repo) {
            showPublishBranchSelectorModal(repo, 'mainSite');
        }
        return;
    }

    if (copyLinkBtn) {
        const repoFullName = copyLinkBtn.dataset.repoFullname;
        if (repoFullName && state.user && state.user.login) {
            const [owner, repoName] = repoFullName.split('/');
            const isMainSiteRepo = repoName === `${state.user.login}.github.io`;
            const siteUrl = isMainSiteRepo
                ? `https://${owner}.github.io/`
                : `https://${owner}.github.io/${repoName}/`;
            navigator.clipboard.writeText(siteUrl).then(() => {
                showToast(isMainSiteRepo ? '主站链接已复制' : '项目链接已复制');
            });
        }
        return;
    }
});




//尾巴
}









(function() {
    const config = {
        minFontSize: 1, maxFontSize: 99, defaultFontSize: 10,
        storageKey: 'editor-font-size', scaleSensitivity: 0.01
    };
    function getSavedFontSize() { return parseInt(localStorage.getItem(config.storageKey)) || config.defaultFontSize; }
    function saveFontSize(size) { localStorage.setItem(config.storageKey, size); }
    function createFontSizeDisplay() {
        const display = document.createElement('div');
        display.style.cssText = `position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; padding: 6px 12px; border-radius: 12px; font-size: 12px; font-weight: bold; z-index: 1000; pointer-events: none; opacity: 0; transition: opacity 0.1s; background-color: rgba(0,0,0,0.5);`;
        return display;
    }
    function showFontSizeTooltip(display, size) {
        display.textContent = `${size}px`;
        display.style.opacity = '1';
        clearTimeout(display.hideTimeout);
        display.hideTimeout = setTimeout(() => { display.style.opacity = '0'; }, 1000);
    }
    function initGestureControls() {
        const observer = new MutationObserver(() => {
            const editModal = document.getElementById('editModal');
            const fileContent = document.getElementById('fileContent');
            const editorContainer = document.querySelector('.editor-container');
            if (editModal && fileContent && editorContainer && !fileContent.hasGestureControl) {
                fileContent.hasGestureControl = true;
                let currentSize = getSavedFontSize();
                fileContent.style.fontSize = currentSize + 'px';
                fileContent.style.lineHeight = (currentSize * 1.5) + 'px';
                const fontSizeDisplay = createFontSizeDisplay();
                editorContainer.appendChild(fontSizeDisplay);
                let initialDistance = 0, initialFontSize = currentSize, isPinching = false;
                function getTouchDistance(touches) { const dx = touches[0].clientX - touches[1].clientX, dy = touches[0].clientY - touches[1].clientY; return Math.sqrt(dx * dx + dy * dy); }
                function updateFontSize(newSize) {
                    newSize = Math.max(config.minFontSize, Math.min(config.maxFontSize, Math.round(newSize)));
                    if (newSize === currentSize) return;
                    const textarea = fileContent;
                    const oldScrollHeight = textarea.scrollHeight, oldScrollTop = textarea.scrollTop, viewportHeight = textarea.clientHeight;
                    const centerRatio = oldScrollHeight > viewportHeight ? (oldScrollTop + viewportHeight / 2) / oldScrollHeight : 0.5;
                    currentSize = newSize;
                    textarea.style.fontSize = newSize + 'px';
                    textarea.style.lineHeight = (newSize * 1.5) + 'px';
                    const newScrollHeight = textarea.scrollHeight;
                    const newScrollTop = (newScrollHeight * centerRatio) - (viewportHeight / 2);
                    textarea.scrollTop = newScrollTop;
                    showFontSizeTooltip(fontSizeDisplay, newSize);
                    saveFontSize(newSize);
                }
                fileContent.addEventListener('touchstart', (e) => { if (e.touches.length === 2) { e.preventDefault(); isPinching = true; initialDistance = getTouchDistance(e.touches); initialFontSize = currentSize; } }, { passive: false });
                fileContent.addEventListener('touchmove', (e) => { if (isPinching && e.touches.length === 2) { e.preventDefault(); const currentDistance = getTouchDistance(e.touches); const scale = currentDistance / initialDistance; const newSize = initialFontSize * scale; updateFontSize(newSize); } }, { passive: false });
                fileContent.addEventListener('touchend', () => { if (isPinching) isPinching = false; });
                fileContent.addEventListener('wheel', (e) => { if (e.ctrlKey || e.metaKey) { e.preventDefault(); const delta = e.deltaY > 0 ? -1 : 1; updateFontSize(currentSize + delta); } }, { passive: false });
                fileContent.addEventListener('keydown', (e) => {
                    if ((e.ctrlKey || e.metaKey) && (e.key === '+' || e.key === '=')) { e.preventDefault(); updateFontSize(currentSize + 1); }
                    else if ((e.ctrlKey || e.metaKey) && e.key === '-') { e.preventDefault(); updateFontSize(currentSize - 1); }
                    else if ((e.ctrlKey || e.metaKey) && e.key === '0') { e.preventDefault(); updateFontSize(config.defaultFontSize); }
                });
                const editModalObserver = new MutationObserver(() => { if (!editModal.classList.contains('hidden')) { currentSize = getSavedFontSize(); fileContent.style.fontSize = currentSize + 'px'; fileContent.style.lineHeight = (currentSize * 1.5) + 'px'; } });
                editModalObserver.observe(editModal, { attributes: true, attributeFilter: ['class'] });
            }
        });
        observer.observe(document.body, { childList: true, subtree: true });
    }
    if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', initGestureControls); } else { initGestureControls(); }
})();

(function() {
    'use strict';
    const config = { buttonId: 'toggleMaximizeModal', modalId: 'editModal', closeButtonId: 'closeEditModal', maximizedClass: 'maximized', expandIcon: 'fa-expand', compressIcon: 'fa-compress', buttonTitle: { maximize: '最大化', restore: '恢复' } };
    let maximizeButton = null, editModal = null, isToggling = false, modalObserver = null;
    
    function toggleMaximize() {
    if (!editModal || !maximizeButton || isToggling) return;
    isToggling = true;
    const icon = maximizeButton.querySelector('i');
    
    const isCurrentlyMaximized = editModal.classList.contains(config.maximizedClass);

    if (isCurrentlyMaximized) {
        editModal.classList.remove(config.maximizedClass);
        icon.classList.remove(config.compressIcon);
        icon.classList.add(config.expandIcon);
        maximizeButton.title = config.buttonTitle.maximize;
        try { if (typeof window.adjustEditorDimensions === 'function') setTimeout(window.adjustEditorDimensions, 100); } catch (e) { console.error('调整编辑器尺寸时出错：', e); }
    } else {
        editModal.classList.add(config.maximizedClass);
        icon.classList.remove(config.expandIcon);
        icon.classList.add(config.compressIcon);
        maximizeButton.title = config.buttonTitle.restore;
    }

    const newState = !isCurrentlyMaximized;
    try { localStorage.setItem('editor-maximized', newState.toString()); } catch (e) { console.error('保存最大化状态失败：', e); }

    setTimeout(() => { isToggling = false; }, 300);
}

    function resetMaximizedState() {
    if (isToggling || !editModal) return;

    if (editModal.classList.contains(config.maximizedClass)) {
        const icon = maximizeButton.querySelector('i');
        editModal.classList.remove(config.maximizedClass);
        if (icon) {
            icon.classList.remove(config.compressIcon);
            icon.classList.add(config.expandIcon);
        }
        maximizeButton.title = config.buttonTitle.maximize;
    }
}

function showEditorScaleHintOnce() {
    const hintKey = 'editor_scale_hint_shown';
    try {
        if (localStorage.getItem(hintKey)) {
            return;
        }
        const hintElement = el.editorScaleHint;
        if (!hintElement) {
            return;
        }
        
        hintElement.classList.remove('hidden');
        
        setTimeout(() => {
            hintElement.style.transition = 'opacity 0.5s ease-out';
            hintElement.style.opacity = '0';
            setTimeout(() => {
                hintElement.classList.add('hidden');
                hintElement.style.opacity = '';
                hintElement.style.transition = '';
            }, 500);
        }, 3000);

        localStorage.setItem(hintKey, 'true');
    } catch (e) {
        console.error("Could not show editor scale hint:", e);
    }
}
    
function initializeButton() {
    if (maximizeButton) return; 

    editModal = document.getElementById(config.modalId);
    maximizeButton = document.getElementById(config.buttonId);

    if (!editModal || !maximizeButton) return;

    maximizeButton.addEventListener('click', toggleMaximize);
}

    function init() {
        const observer = new MutationObserver(() => { if (!maximizeButton || !document.getElementById(config.buttonId) || !document.getElementById(config.modalId)) initializeButton(); });
        observer.observe(document.body, { childList: true, subtree: true });
        initializeButton();
        document.addEventListener('keydown', (e) => { if (editModal && !editModal.classList.contains('hidden')) { if (e.key === 'F11' || (e.ctrlKey && e.shiftKey && e.key === 'M')) { e.preventDefault(); toggleMaximize(); } } });
    }
    init();
})();


function initImageObserver() {
    imageObserver = new IntersectionObserver((entries, observer) => {
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                const container = entry.target;
                loadThumbnailImage(container);
                observer.unobserve(container);
            }
        });
    }, { rootMargin: '0px 0px 200px 0px' });
}


async function init() {
    try {
        const lastVersion = localStorage.getItem('last_app_version');
        if (lastVersion !== CURRENT_VERSION) {
            
            const keysToKeep = [
                'github_accounts',
                'active_github_account_id',
                'app_theme',
                'context_menu_visibility',
                'last_app_version'
            ];

            for (let i = localStorage.length - 1; i >= 0; i--) {
                const key = localStorage.key(i);
                if (!keysToKeep.includes(key)) {
                    localStorage.removeItem(key);
                }
            }
            
            state.fileCache.clear();

            localStorage.setItem('last_app_version', CURRENT_VERSION);
            
           // showToast('应用已更新，缓存已清除 (账号/主题/菜单设置已保留)', 'info');
        }
    } catch (e) {
        console.error('处理版本更新检查时出错:', e);
    }

    themeManager.init();
    loadLocalAvatar();
    loadContextMenuSettings();
    initImageObserver();
    setupEventListeners(); 
    updateSortDropdownUI();

    initializeActiveToken();

    if (state.token) {
        showApp();
        try {
            await Promise.all([
                fetchRepos(),
                fetchUserInfo()
            ]);
            
            // 关键改动：在仓库列表加载后立即预取自定义域名信息
            prefetchCustomDomains();

            if (state.proxies.length === 0) {
                findAndSetBestProxy();
            } else if (state.autoSelectProxy) {
                setTimeout(() => findAndSetBestProxy(), 1000);
            } else {
                state.activeProxyIndex = parseInt(localStorage.getItem('active_proxy_index') || '0');
                state.proxyGlobalEnable = JSON.parse(localStorage.getItem('proxy_global_enable') || 'true');
                saveProxyConfig();
            }
        } catch (e) {
            console.error("Auto-login failed:", e);
            showToast('自动登录失败，请重新选择账号');
            setActiveAccount(null);
            showAuth();
        }
    } else {
        showAuth();
    }
    
    el.closePublishManagerBtn.onclick = hidePublishManagerModal;
        el.officialConfigTabBtn.onclick = () => {
        state.publishManagerActiveTab = 'official';
        renderPublishManagerLists();
    };
    el.customDomainTabBtn.onclick = () => {
        state.publishManagerActiveTab = 'custom';
        renderPublishManagerLists();
    };
}


document.addEventListener('DOMContentLoaded', async function() {
    document.documentElement.style.userSelect = 'none';
    history.replaceState({ repo: null, path: '' }, '', window.location.pathname);
    await init();
    initMediaPreview();
    initPullToRefresh();
    window.addEventListener('popstate', async (event) => {
        if (handleBackPress()) {
            return;
        }
        state.shouldAnimateList = true;
        const historyState = event.state || {};
        state.currentRepo = historyState.repo;
        state.currentPath = historyState.path;
        if (!state.repos || state.repos.length === 0) {
            await fetchRepos(true);
        }
        if (state.currentRepo) {
            const repoData = state.repos.find(r => r.full_name === state.currentRepo);
            if (repoData) {
                state.currentBranch = historyState.branch || repoData.default_branch;
                const repoNameOnly = state.currentRepo.split('/')[1];
                el.currentRepo.textContent = repoNameOnly;
                renderPathNav();
                await fetchBranches(repoData);
                renderBranchSwitcher();
                await fetchFiles();
                toggleView(false);
            } else {
                showToast('仓库信息未找到，已返回仓库列表');
                showRepoListView();
            }
        } else {
            showRepoListView();
        }
    });
});




function injectModalStyles() {
    if (document.getElementById('dynamic-modal-styles')) {
        return;
    }

    const css = `
        .announcement-dialog,
        .update-dialog-container {
            position: relative; 
            max-width: 340px; 
            width: 90%;
            border-radius: 0.8rem; 
            background: linear-gradient(145deg, #1a1a2e, #16213e); 
            box-shadow: 0 10px 30px rgba(0,0,0,0.5); 
            border: 1px solid rgba(255,255,255,0.05); 
            color: #e0e7ff; 
            padding: 1.2rem; 
            transform: scale(0.9); 
            opacity: 0; 
            animation: zoomIn 0.4s 0.1s forwards;
        }
        .announcement-header { 
            font-size: 1rem; 
            font-weight: 600; 
            margin-bottom: 0.8rem; 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
        }
        .announcement-content { 
            font-size: 0.8rem; 
            color: #d1d5db; 
            line-height: 1.6; 
            max-height: 200px; 
            overflow-y: auto; 
            padding: 0.5rem; 
            background: rgba(0,0,0,0.2); 
            border-radius: 0.3rem; 
        }
        #closeAnnouncementBtn { 
            background: none; 
            border: none; 
            color: #e0e7ff; 
            font-size: 1.2rem; 
            cursor: pointer; 
            opacity: 0.7; 
        }
        .update-dialog-content { 
            position: relative; 
            z-index: 1; 
        }
        .update-dialog-header { 
            display: flex; 
            justify-content: space-between; 
            align-items: flex-start; 
            line-height: 1.6rem; 
            padding-bottom: 0.3rem; 
        }
        #closeUpdateModalBtn { 
            position: absolute; 
            top: 0; 
            right: 0; 
        }
        .update-log { 
            border-bottom: 1px solid rgba(255,255,255,0.1); 
            font-size: 0.8rem; 
            color: #d1d5db; 
            line-height: 1.6rem; 
            max-height: 300px; 
            overflow-y: auto; 
            padding: 0.68rem; 
            margin-bottom: 1.4rem; 
            background: rgba(0,0,0,0.2); 
            border-radius: 0.3rem; 
        }
        .update-buttons { 
    display: flex; 
    gap: 1rem; 
    margin-top: 1.2rem;
}
        .update-btn { 
            flex: 1; 
            padding: 0.6rem; 
            border: none; 
            border-radius: 0.4rem; 
            font-size: 0.8rem; 
            font-weight: 600; 
            cursor: pointer; 
            transition: transform 0.2s, box-shadow 0.2s; 
            opacity: 0.8; 
        }
        .update-btn:hover { 
            transform: translateY(-2px); 
            box-shadow: 0 4px 15px rgba(0,0,0,0.4); 
        }
        .btn-download { 
            background: linear-gradient(90deg, #a855f7, #6366f1, #3b82f6); 
            color: white; 
        }
        @keyframes zoomIn { 
            to { transform: scale(1); opacity: 1; } 
        }

        /* --- 新增的浅色主题样式 --- */
        .light-theme .announcement-dialog,
        .light-theme .update-dialog-container {
            background: linear-gradient(145deg, #ffffff, #eef2f7);
            box-shadow: 0 0px 0px rgba(0, 0, 0, 0);
            border: 0px solid #e5e7eb;
            color: #1f2937;
        }

        .light-theme .announcement-content,
        .light-theme .update-log {
            background: 0;
            color: #4b5563;
            border-bottom: 1px solid #e5e7eb;
        }

        .light-theme #closeAnnouncementBtn,
        .light-theme #closeUpdateModalBtn {
            color: #4b5563;
        }
        body.light-theme #closeUpdateModalBtn {
    color: #4b5563 !important;
}

body.light-theme .update-log {
    background-color: #e5e7eb;
}
        /* --- 浅色主题样式结束 --- */
    `;
    
    const styleSheet = document.createElement('style');
    styleSheet.id = 'dynamic-modal-styles';
    styleSheet.innerHTML = css;
    document.head.appendChild(styleSheet);
}

async function checkServerInfo() {
    injectModalStyles();
    const CONFIG_URL = './工具/更新2.0.json';
    const urlWithTimestamp = `${CONFIG_URL}?t=${new Date().getTime()}`;
    try {
        const finalUrl = getProxiedUrl(urlWithTimestamp);
        const response = await fetch(finalUrl);
        if (!response.ok) throw new Error(`Failed to fetch config: ${response.status}`);
        
        const serverInfo = await response.json();
        
        handleUpdate(serverInfo);
        handleAnnouncement(serverInfo);

    } catch (error) {
        console.error('Check for server info failed:', error);
    }
}

function handleAnnouncement(info) {
    if (info && info.公告开关 === '开' && info.公告) {
        showAnnouncementDialog(info);
    }
}

function handleUpdate(info) {
    if (info && isNewerVersion(info.版本, CURRENT_VERSION)) {
        showUpdateDialog(info);
    }
}

function isNewerVersion(remoteVersion, localVersion) {
    const remoteParts = remoteVersion.split('.').map(Number);
    const localParts = localVersion.split('.').map(Number);
    const len = Math.max(remoteParts.length, localParts.length);
    for (let i = 0; i < len; i++) {
        const remote = remoteParts[i] || 0;
        const local = localParts[i] || 0;
        if (remote > local) return true;
        if (remote < local) return false;
    }
    return false;
}

function showAnnouncementDialog(info) {
    if (document.getElementById('announcementModal')) return;

    const announcementText = info.公告 || '';
    let buttonsHTML = '';
    const hasLinkButton = info.公告链接 && info.公告链接.trim() !== '';
    const hasCopyButton = info.公告复制内容 && info.公告复制内容.trim() !== '';



    if (hasCopyButton) {
        const copyButtonText = info.公告复制按钮文本 || '复制内容';
        buttonsHTML += `<button id="announcementCopyBtn" class="update-btn btn-download">${escapeHtml(copyButtonText)}</button>`;
    }
    
    if (hasLinkButton) {
        const linkButtonText = info.公告链接按钮文本 || '前往链接';
        buttonsHTML += `<button id="announcementLinkBtn" class="update-btn btn-download">${escapeHtml(linkButtonText)}</button>`;
    }

    
    const modal = document.createElement('div');
    modal.id = 'announcementModal';
    modal.className = 'modal-overlay';
    modal.style.cssText = `z-index: 201; opacity: 0; transition: opacity 0.3s ease;`;
    
    modal.innerHTML = `
        <div class="announcement-dialog">
            <div class="announcement-header">
                <span>公告：</span>
                <button id="closeAnnouncementBtn" title="关闭"><i class="fa fa-times"></i></button>
            </div>
            <div class="announcement-content">${announcementText.replace(/\n/g, '<br>')}</div>
            ${buttonsHTML ? `<div class="update-buttons">${buttonsHTML}</div>` : ''}
        </div>
    `;

    document.body.appendChild(modal);
    setTimeout(() => { modal.style.opacity = '1'; }, 10);

    const closeModal = () => {
        modal.style.opacity = '0';
        modal.querySelector('.announcement-dialog').style.animation = 'zoomIn 0.3s reverse forwards';
        setTimeout(() => modal.remove(), 300);
    };

    document.getElementById('closeAnnouncementBtn').onclick = closeModal;
    modal.onclick = (e) => { if (e.target === modal) closeModal(); };

    if (hasLinkButton) {
        document.getElementById('announcementLinkBtn').onclick = () => {
            window.open(info.公告链接, '_blank');
        };
    }

      if (hasCopyButton) {
        const copyButtonText = info.公告复制按钮文本 || '复制内容';
        document.getElementById('announcementCopyBtn').onclick = () => {
            navigator.clipboard.writeText(info.公告复制内容).then(() => {
                showToast(`已${escapeHtml(copyButtonText)}`);
            }).catch(() => {
                showToast('复制失败');
            });
        };
    }
}

function showUpdateDialog(updateInfo) {
    if (document.getElementById('updateModal')) return;
    
    const modal = document.createElement('div');
    modal.id = 'updateModal';
    modal.className = 'modal-overlay';
    modal.style.cssText = `z-index: 200; opacity: 0; transition: opacity 0.3s ease;`;
    
    const isForced = updateInfo.强制更新 === '开';
    const updateLogHTML = (updateInfo.更新日志 || '').replace(/\n/g, '<br>');
    
    modal.innerHTML = `
        <div class="update-dialog-container">
            <div class="update-dialog-content">
                <div class="update-dialog-header">
                    <div style="flex-grow: 1;">
                        <span style="font-size:1rem; font-weight: 600;">版本更新： v${escapeHtml(updateInfo.版本)}</span>
                        <div style="font-size: 0.8rem; color: #ff0036; font-weight: 400; margin-top: 0.2rem; text-align: right;">当前： v${CURRENT_VERSION}</div>
                    </div>
                    ${!isForced ? `<button id="closeUpdateModalBtn" class="btn-icon-sm" style="color:white;" title="关闭"><i class="fa fa-times"></i></button>` : ''}
                </div>
                <div class="update-log">${updateLogHTML}</div>
                <div class="update-buttons">
                    <button id="copyUpdateLinkBtn" class="update-btn btn-download">复制下载链接</button>
                    <button id="downloadUpdateBtn" class="update-btn btn-download">下载更新</button>
                </div>
            </div>
        </div>
    `;

    document.body.appendChild(modal);
    setTimeout(() => { modal.style.opacity = '1'; }, 10);

    if (!isForced) {
        const closeModal = () => {
            modal.style.opacity = '0';
            modal.querySelector('.update-dialog-container').style.animation = 'zoomIn 0.3s reverse forwards';
            setTimeout(() => modal.remove(), 300);
        };
        document.getElementById('closeUpdateModalBtn').onclick = closeModal;
        modal.onclick = (e) => { if (e.target === modal) closeModal(); };
    }

    document.getElementById('copyUpdateLinkBtn').onclick = () => {
        navigator.clipboard.writeText(updateInfo.下载地址).then(() => {
            showToast('下载地址已复制!');
        }).catch(() => {
            showToast('复制失败,权限不足');
        });
    };
    
    document.getElementById('downloadUpdateBtn').onclick = () => {
        window.open(updateInfo.下载地址, '_blank');
    };
}

const originalInit = window.init;
window.init = async function() {
    if(originalInit) {
        await originalInit.apply(this, arguments);
    }
    checkServerInfo();
};




async function unzipFile(file) {
    const confirmUnzip = async () => {
        const [owner, repo] = state.currentRepo.split('/');
        
        try {
            showToast('正在下载压缩包...');
            const response = await fetch(getProxiedUrl(file.download_url));
            if (!response.ok) {
                throw new Error(`下载压缩包失败: ${response.statusText}`);
            }
            const blob = await response.blob();

            showToast('正在读取压缩包内容...');
            const zip = await JSZip.loadAsync(blob);
            const filesInZip = Object.values(zip.files).filter(item => !item.dir);
            const totalFiles = filesInZip.length;
            let uploadedCount = 0;

            if (totalFiles === 0) {
                showToast('压缩包为空或无法读取');
                return;
            }
            
            showToast(`开始上传 ${totalFiles} 个文件...`);

            for (const zipEntry of filesInZip) {
                const contentBase64 = await zipEntry.async('base64');
                const entryPath = zipEntry.name;
                const fullPath = state.currentPath ? `${state.currentPath}${entryPath}` : entryPath;
                
                const uploadUrl = `https://api.github.com/repos/${owner}/${repo}/contents/${fullPath}`;
                
                let existingFileSha = null;
                try {
                    const checkRes = await fetch(uploadUrl + `?ref=${state.currentBranch}`, {
                         headers: { 'Authorization': `token ${state.token}` }
                    });
                    if (checkRes.ok) {
                        existingFileSha = (await checkRes.json()).sha;
                    }
                } catch (e) {
                }

                const body = {
                    message: `Unzip ${file.name}: add ${entryPath}`,
                    content: contentBase64,
                    branch: state.currentBranch,
                };

                if (existingFileSha) {
                    body.sha = existingFileSha;
                    body.message = `Unzip ${file.name}: update ${entryPath}`;
                }

                const uploadResponse = await fetch(uploadUrl, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `token ${state.token}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(body)
                });

                if (!uploadResponse.ok) {
                    console.error(`上传失败: ${fullPath}`, await uploadResponse.json());
                    showToast(`文件 ${entryPath} 上传失败，已跳过。`);
                } else {
                    uploadedCount++;
                    showToast(`正在上传... (${uploadedCount}/${totalFiles})`);
                }
            }

            showToast(`解压完成！成功上传 ${uploadedCount} 个文件。`);
            state.shouldAnimateList = true;
            fetchFiles(true);

        } catch (error) {
            console.error('解压过程中发生错误:', error);
            showToast(`解压失败: ${error.message}`);
        }
    };

    showDeleteModal(
        null,
        false,
        '确认解压',
        `确定要将 "${escapeHtml(file.name)}" 解压到当前目录吗？同名文件将被覆盖。`,
        confirmUnzip,
        '确认解压',
        'btn-primary'
    );
}



// 粒子效果
const canvas = document.getElementById('particle-canvas'); 
const ctx = canvas.getContext('2d'); 
canvas.width = window.innerWidth; 
canvas.height = window.innerHeight; 
let particlesArray; 

// 自定义粒子的颜色
const particleColors = ['#00f5c3', '#ff2e88', '#66FF99', '#3366FF','#CC66FF'];


class Particle { 
    constructor(x, y, dX, dY, size, color) { 
        this.x=x; 
        this.y=y; 
        this.directionX=dX; 
        this.directionY=dY; 
        this.size=size; 
        this.color=color; 
    } 
    draw() { 
        ctx.beginPath(); 
        ctx.arc(this.x, this.y, this.size, 0, Math.PI*2, false); 
        ctx.fillStyle=this.color; 
        ctx.fill(); 
    } 
    update() { 
        if (this.x > canvas.width || this.x < 0) this.directionX = -this.directionX; 
        if (this.y > canvas.height || this.y < 0) this.directionY = -this.directionY; 
        this.x+=this.directionX; 
        this.y+=this.directionY; 
        this.draw(); 
    } 
}

function initParticles() { 
    particlesArray = []; 
    let num = (canvas.height*canvas.width)/9000; 
    for(let i=0;i<num;i++){
        let size=Math.random()*1.5+1,
            x=Math.random()*(innerWidth-size*4)+size*2,
            y=Math.random()*(innerHeight-size*4)+size*2,
            dX=(Math.random()*.3)-.15,
            dY=(Math.random()*.3)-.15,
            color=particleColors[Math.floor(Math.random()*particleColors.length)];
        particlesArray.push(new Particle(x,y,dX,dY,size,color));
    } 
}

function animateParticles() { 
    requestAnimationFrame(animateParticles); 
    ctx.clearRect(0,0,innerWidth,innerHeight); 
    for(let i=0;i<particlesArray.length;i++) particlesArray[i].update(); 
}

window.addEventListener('resize', ()=>{ 
    canvas.width=innerWidth; 
    canvas.height=innerHeight; 
    initParticles(); 
}); 

initParticles(); 
animateParticles();


const foldTitle = document.querySelector('.lp');
const foldContent = document.querySelector('.token-content');
foldTitle.addEventListener('click', function() {
  foldContent.classList.toggle('active');
});
</script>


<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
</body>
</html>
